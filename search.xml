<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C语言杂记(一)]]></title>
    <url>%2F2018%2F05%2F16%2FC%E8%AF%AD%E8%A8%80%E6%9D%82%E8%AE%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[笔记： 刚才，或许是自己打开的应用程序过多的缘故，还是这个xMind工具的缘故，电脑一下子黑屏了并且伴随着电脑的散热量也是轰轰之响。害得我重启电脑，前面写的一堆东西，现在回过头重新的写一遍。2018-5-7 1. URL：统一资源定位器(uniform resource location) 是用来定义标准的网络地址的书写形式的。譬如http://www.xxx......... 2. TFTP服务器：简单的文件传输协议，用于在远程服务器和本地的主机之间进行文件的传输。 DNS服务器：domain name(域名)。指的是保存有该网络中所有主机的域名和对应的IP地址，并且具有将域名转化成为IP地址的功能。 3. 计算机网络大致分为哪几类？ 局域网、城域网、广域网、互联网(Internet，也就是我们常说的www.xxx......) 4. 在Ubuntu中的vi编辑模式下 创建软连接：ln -s exit_file new_file。注意：在共享文件目录下面创建软连接是创建不成功的哦！换为非共享目录即可实现。 设置永久行号：a. 使用vi命令打开~/.vimrcb.在其输入set nu即可。 在命令模式下面：在光标闪烁的位置，输入dd删除掉该行；输入yy可以复制该行，p即可粘贴该行。 du -h命令可以很方便、直观的显示出文件的大小(KB、MB) 5. 关于void 类型的理解：void 类型，该指针的类型是不确定的。可能是int、float、double等等类型的。 1234567int a=5;void *p = &amp;a;printf(&quot;*p = %d\n&quot;,*((int *)p));printf(&quot;*p = %f\n&quot;,*((float *)p));运行结果：*p = 5*p = 0.000000 6. C语言中的数据类型转化 隐式类型转化：默认的朝着精度更高、范围更大的方向转化。 强制类型转化： 7. 数据类型的本质： 该数据在内存中是以何种方式储存的 、以及是以何种方式取出来的、以何种方式转化为二进制数的问题。一定要记住，内存只管存储这一些101010的数字而已，它只管存储的，至于拿到了这一串101010的数字之后怎么样去进行解析，这就是由数据类型来操控的。 8. 变量和常量 变量：局部变量(函数内部)和全局变量(函数外部)。 ​ 局部变量又分为普通局部变量、静态局部变量和register类型的局部变量。 我们平时见到的大部分都是普通局部变量，它的关键字是auto，只不过说我们平时给省略掉了。 静态局部变量，用关键字static修饰的变量，只有在第一次才经历变量的定义和初始化，以后该变量维持了上一次执行以后，该变量的值。也就是说，它的值是会”累加的”。静态局部变量和全局变量十分的相似，相同点在于生命周期都是很长的，区别在于它们的作用域是不同的。 register修饰的局部变量，在行为表现上和auto是一样的，它基本上没什么用。C语言的运行时环境承诺，会尽量的将该类型的变量存放在寄存器中(普通的变量一般都在内存中)，所以说register类型的变量的访问速度很快的，但是由于寄存器的数目也是非常的有限的，也就造成了register类型的变量有很多的限制。 全局变量：普通全局变量和静态全局变量 普通的全局变量，可以在多个文件中共同使用。所以，要确保该全局变量不重名。 静态全局变量，是用来解决重名的问题的。所以，静态的全局变量并不是给别的文件使用的，是给自己本文件所使用的。 跨文件引用全局变量：extern。在有多个.c文件的时候，可以在一个.c文件中定义全局变量g_a,然后在另一个.c文件中引用该变量(引用之前一定要用extern声明)。在这里要强调的是：使用extern定义变量的时候，是不可以进行赋值操作的。 局部变量和全局变量总结： 定义时没初始化，则局部变量的值是随机的，而全局变量的值是默认的 使用范围上：全局变量具有文件作用域，而局部变量只有代码块作用域 生命周期上：全局变量在开始运行之前的初始化阶段就已经诞生了，到了整个程序结束退出的时候才消亡的；而局部变量在进入局部变量所在的代码块时诞生，在该代码块退出的时候才消亡的。 变量分配位置：全局变量分配在数据段上，而局部变量分配在栈上面。 思考题1： 局部变量是否可以跨文件使用？答：否，因为局部变量属于代码块作用域，它的作用域仅仅在它定义的那个函数的内部。 思考题2： 静态局部变量是否可以跨文件使用呢？答：否，它本质上任然是一个局部变量。 9. 一些基本概念： 代码块：一个{}括起来的一段代码 数据段：存储的是数据、譬如说全局变量 代码段：存放程序代码，一般是只读的 10. C语言对内存的管理方式：大致分为5各部分。 代码段(code或text)，代码段是由各个函数产生，函数的每一个语句将最终经过编译、汇编生成二进制的机器码(具体生成哪一种体系的机器码由编译器所决定的) 数据段，分为只读数据段(RO Data)和可读可写数据段(RW Data)。其中RO Data程序中使用到的常量，会在编译的时候被放入到RO Data；而RW Data，又称为已经初始化的数据段，通常把已经初始化的全局变量和已经初始化的静态局部变量，在编译时放在了RW Data中。 BSS(未初始化的数据段)，该段中的数据是没有经过初始化的，不是目标文件(.obj)中的一部分。未初始化的数据段只有在运行的初始化阶段才会产生。因此说，BSS段的大小是不会影响目标文件的大小的。 堆，堆内存只有在程序运行的时候才出现，一般由程序员分配和释放(malloc,free)。注意分配好内存以后，要记得手工的将该内存给释放掉，以免发生内存泄漏。 栈，栈内存只在程序运行的时候出现。在函数内部使用的变量、函数的参数以及返回值将使用栈空间，栈空间是由编译器自动分配和释放的。 举个例子： 12char *p = &quot;abcdefg&quot;;其中的“abcdefg\0”这一坨存放在RO Data,也可以说在数据段；而变量p存放在栈上。 总结 ： 代码段、数据段(RO Data、RW Data)、BSS段，这3个段都属于程序中的静态区域，而 堆和栈都属于程序的动态区域。 C语言程序经过编译、链接生成的二进制可执行代码，只包含代码段、RO Data、RW Data。堆和栈是在程序运行以后才包含进去的，而BSS中的数据将会在程序运行之前置0。 使用const定义的变量将存放于程序的只读数据区(RO Data) 函数体中定义的变量通常是在栈上面的，是不需要在程序中进行管理的，由编译器来处理。 11. 常量：#define定义的常量、const关键字定义的常量、枚举常量(C++中实现了真正意义的枚举常量) 记着一个例子： 12char *strcpy(char *dst,const char *scr);把src这个字符串拷贝到dst里面去，src所指向的是复制源，使用const修饰表示我们是不会更改src所指向的内容的。 12. 1234#ifndef _A_H_#define _A_H_...#endif 作用：防止重复包含头文件。 写程序的时候最好不要在头文件中定义变量，最好在源文件中定义变量。 原因：很有可能该头文件被多个源文件所包含，这样就会导致重复定义问题。全局变量的定义因该在某一个源文件中，然后，其他的源文件想要使用该变量的时候，只需要在使用之前使用extern进行声明即可使用。 13. 程序运行的目的是什么？ 答：程序的目的是为了运行，而运行的目的是为了得到一定的结果。计算机程序是由代码+数据组成的。”代码”是一个动作，是一个加工数据的动作；而数据是被代码加工的原材料。所以说，程序运行的目的要么是结果、要么是过程。在C语言中，一些返回值为void类型的函数，该程序在乎的就是程序运行的过程；而一些返回值非void的函数，程序的运行有可能是在乎结果的，也有可能是过程和结果都是在乎的。 14. 计算机程序运行的过程？ 答：计算机程序运行的过程，其实就是很多个函数相互运行的过程。程序是由很多个函数组成的，程序的本质就是函数，而函数的本质就是加工数据的动作。 15. 冯诺依曼结构和哈弗结构： 冯诺依曼结构：数据和代码放在一起的(Cortex-A8中)；哈弗结构：数据和代码是分开存放的(C51中)。 代码：一个一个的函数 数据：全局变量、局部变量 16. 内存位宽： 硬件内存的实现本身是有宽度的，有一些内存条是8位的，一些内存条的宽度是16位的。需要注意的是，内存芯片之间是可以相互关联的，一个32位的内存芯片可以由4个8位的内存芯片并联实现。 内存编址的方法： 从逻辑角度而言，内存是由无限多个内存单元格组成的，每一个内存单元格都有一个固定的地址，叫做内存地址。这个内存地址和这个单元格是一一对应的关系，并且永久绑定的。 内存的编址是以字节为单位的，譬如说表格中的每一个数字标号，占1字节，即8个bit位。 内存编址的单元是以字节为单位的。 在内存中，一个字节代表一个编号……………….. 7 6 5 4 3 2 1 0 编号3 编号2 编号1 编号0 内存与数据类型的关系： C语言中基本的数据类型int、float、double，这一些数据类型与该类型的变量所占的内存长度(多少字节)有关系。 内存对齐： 对齐访问与硬件本身的结构是搭配的，所以执行的效率就会很高。 第一种：0 1 2 3 对齐访问 第二种：1 2 3 4或2 3 4 5或3 4 5 6 非对齐访问 指针变量(读上10遍不为过)： 指针变量也是一个变量，只不过它里面存放的是内存的地址，确切的来讲是内存的首地址。当我们用一个指针指向这个变量的时候，此时指针的值就是这个连续内存的首地址。使用指针取值操作读取变量值的时候，就是根据指针里面存放的地址，找到对应的内存，然后再根据规则(不同的数据类型)读取相应长度的内存中的数据。指针本身的存放也是需要使用内存的，只不过它是存放在另一个内存空间里面的，那个内存空间就是指针变量的存放空间。指针变量的大小是固定的，32位系统下面指针变量占4字节、64位系统下面是8字节。 指针变量占几个字节大小取决于：CPU寻址的最大寻址内存空间。 指针的大小为4字节：表示该指针可以记录的地址范围为0x0000 0000-0xFFFF FFFF,在这个范围的数字才属于指针变量的值。而比方说一个char类型的变量，既可以存放在0x0地址处，也可以存放在0xFFFF FFFF地址处，存放那一个地址处与char类型的变量本身占多大的字节是没有关系的。与你的系统是32位还是64位有关系的。 17. C语言中操作的变量，其实就是一个内存单元。C语言中变量名的实质就是内存地址(拓展开来，函数名的本质也是内存地址)；而数据类型的本质表示内存单元的长度以及解析的方法。 18. int a[10]; 编译器分配了4字节长度给a，并且把首元素首地址与符号a绑定起来。数组中第一个元素a[0]称之为首元素，数组中每一个元素都是int类型的，都占4个字节，其中第一个字节的地址就称之为首地址。首元素a[0]的地址，就称为首元素首地址。 19. 使用位运算对寄存器操作的要求： 在嵌入式领域当地中，涉及到的移位操作都是无符号数。在设定特定位的同时，是不可以影响其他位的。具体做法，我要往一个寄存器里面写数据去操控一个外设，不是直接的往里面写，而是先把先把原来寄存器整体的值读取出来，然后对其局部的改造，最后再把它写进去寄存器中。所谓的，”读改写“三部曲。 20. 利用移位操作设置特定位为1 第一题：设定bit3-bit7为1，0x1F&lt;&lt;3即可。 解题方法：bit3-bit7为1，即5个1(这里的5个1指的是，bit0-bit4)，即0x1F,将0x1F左移3位，即bit3-bit7全为1，从而达到目的。 第二题：设置bit3-bit7为1，同时bit23-bit25为1。 解题方法：bit3-bit7为1，即5个1(这里的5个1指的是，bit0-bit4),即0x1F,将0x1F，左移3位，即bit3-bit7全为1，从而实现目的一；bit23-bit25为1，即3个1(这里的3个1指的是，bit0-bit2)，即0x07,将0x07左移23位，即可实现。 综上：(0x1F&lt;&lt;3)|(0x07&lt;&lt;23) 利用移位结合取反，获得特定位为0 例子：设定bit3-bit7为0。 答案：~(0x1F&lt;&lt;3) 21. 位运算实战 实战1：给定一个整数a,设置a的bit3,保证其他位不变。 a = a|(1&lt;&lt;3) 实战2：给定一个整数a,设置a的bit3-bit7，保证其他位不变。 a = a|(0x1F&lt;&lt;3) 实战3：给定一个整数a,清除a的bit15，其他位不变。 a &amp;= ~(1&lt;&lt;15) 实战4：给定一个整数a,清除a的bit15-bit23,其他位保持不变。 a &amp;= ~(0x1FFF&lt;&lt;15) 实战5：给定一个整数a,取出a的bit3-bit8 思路：第一步，先将bit3-bit8不变，其余位全部清零。 a &amp;= (0x3F&lt;&lt;3) ​ 第二步，再将其右移3位，即可取出bit3-bit8. a = a&gt;&gt;3 实战6：给一个寄存器的bit7-bit17赋值为937,其余位不受影响。 思路：第一步，将bit7-bit17全部清零 a &amp;= ~(0x7FFF&lt;&lt;7) ​ 第二步，再将937写入到bit7-bit17中 a |= (937&lt;&lt;7) 22. 关于字体设置，在QT中配色方案选择Default，然后字型选择Consolas，注释看着很舒服！ 23. 为什么要引入指针的概念？ 答：指针的出现是为了实现间接寻址。直接寻址，CPU直接与内存打交道；而间接寻址CPU与内存之间通过一个寄存器这么一个桥梁，搭连在一块的。反映在C语言中，直接寻址就是通过定义变量来获取变量的数值。间接寻址通过指针的解引用的方式访问数据。 24. 左值、右值的概念： 放在赋值运算符左边的叫做左值，右边的叫做右值，所以，赋值操作其实就是：左值=右值。 当一个变量做左值时，编译器把这个变量符号的真实含义当做这个变量对应的那段内存空间；当一个变量做右值时，编译器把这个变量符号当做这个变量所对应的内存空间中存储的那一个值。 例如int a; 当a作为左值时，它代表那个内存格子所对应的空间，是一个框子。当a作为右值时，它就代表那个格子里面存放的那个值。 举例子，我们平时所说的，”我到家了”，这里的家指的是房子，类似于左值的概念；而我们说”家比事业更重要”，这里的家，更侧重于房子里面的人，类似于右值的概念。 25. 野指针问题： 定义：指针所指向的位置是不可知的、随机的、不正确的、没有明确限制的。 坏处：野指针很有可能触发运行时的段错误 避免方法：在指针的解引用之前一定要保证指针指向了一个绝对可用的内存空间。 26. NULL到底是什么？ 在C++中，NULL就是数字0；而在C语言中NULL是经过void *强制类型转换过的0 我们平时为什么if (NULL != p)来作为判断是否是野指针的条件呢？第一，0地址是一个特殊的地址，当指针指向这里的时候，我们就可以认为该指针没有被初始化，它就是野指针。第二，这个0地址，在一般的操作系统中是不可以访问的，假如程序员非要访问此地址，编译器会产生一个段错误，作为提示信息。 27. const修饰的变量真的就不可以更改嘛？ 1234567891011121314const int a = 5;int *p = (int *)&amp;a;int *q = (int *)&amp;a;printf(&quot;&amp;a = %p,p = %p,q = %p\n&quot;,&amp;a,p,q);printf(&quot;a = %d,*p = %d,*q = %d\n&quot;,a,*p,*q);*p = 6;*q = 66;printf(&quot;&amp;a = %p,p = %p,q = %p\n&quot;,&amp;a,p,q);printf(&quot;a = %d,*p = %d,*q = %d\n&quot;,a,*p,*q);运行结果：&amp;a = 0028feb4, p = 0028feb4, q = 0028feb4a = 5, *p = 5, *q = 5&amp;a = 0028feb4, p = 0028feb4, q = 0028feb4a = 5, *p = 66, *q = 66 自我的推测：从”a=5,p=66,q=66”结果来看，地址0028feb4这个位置，仿佛有一个”真身、假身”的味道在里面。 总结：使用const时，更多的是在传递一种信息，告诉编译器、告诉阅读程序的人，这个变量是不应该被修改的。 28. 数组 从内存角度来讲，数组变量就是一次分配多个变量，这多个变量的存储单元是依次相连的，但是这多个变量的访问却都是独立的访问的。 变量、变量名、变量类型的理解： 变量其实就是内存中的一块区域，变量名(做右值)就是这块区域的名字。当我们想要访问这个变量时，有两种方法：第一种，直接通过变量名进行访问(像局部变量这种) 第二种，通过它的地址，然后使用解引用的方式找到它(指针)。变量的类型，以某一个起始地址开头，对一定字节长度的数字的解析方式(譬如，char 1字节长度，int 4字节长度…)。 数组中a a[0] &amp;a &amp;a[0]理解(int a[10]): a 数组名(变量名)，当a作为左值时，代表整个数组的所有的空间(10*4=40Byte),但是C语言规定数组在操作时必须是单个操作的，不能够整体操作数组，所以a不可做左值。当a做右值时，代表：数组的首地址。即，数组的第一个元素，也就是a[0]的首地址。即，数组首元素的首地址(4字节中最开始的第一个字节的地址)。等价于&amp;a[0]。 a[0] a[0]做左值时，代表第0个元素所对应的内存空间(连续4字节)。a做右值时，表示第0个元素的值(第0个元素对应的内存空间中存储的那个数字)。 &amp;a 对数组名取地址，字面意思来看就是数组的地址。&amp;a不可以做左值(常量不可以在=左边的)。&amp;a做右值时，表示整个数组的首地址。 &amp;a[0] 对数组第0个元素取地址，也就是第0个元素的地址。做左值时，表示数组首元素所对应的内存空间。右值时，表示数组首元素首地址(首元素对应的内存空闲中存储的那个值) 12345678910111213int a[5] = &#123;1,2,3,4,5&#125;;int *p;printf(&quot;a = %p\n&quot;,a);printf(&quot;&amp;a[0] = %p\n&quot;,&amp;a[0]);printf(&quot;&amp;a = %p\n&quot;,&amp;a);printf(&quot;sizeof(a) = %d\n&quot;,sizeof(a));printf(&quot;sizeof(&amp;a) = %d\n&quot;,sizeof(&amp;a));运行结果：a = 0028feac&amp;a[0] = 0028feac&amp;a = 0028feacsizeof(a) = 20sizeof(&amp;a) = 4 总结： &amp;a和a和&amp;a[0]做右值时，&amp;a是整个数组的首地址，而a和&amp;a[0]是数组首元素的首地址。 1234int *p;int a[5];p = a;//p = &amp;a;//左边右边类型不匹配，一个是int *型，另一个是int (*)[5]即，数组指针类型。 29. 为什么指针变量加1之后实际上加的不是1，而是1*sizeof(指针类型)？？ 答：编译器希望，加1之后，指针刚好指向的是下一个元素，而并不是加1之后仅仅错位了1个字节而已。 30. 数组作为函数形参： 数组作为函数形参时，传递的并不是整个数组，而是数组的首元素的首地址，根本没有数组长度的这个信息。这也正验证了”数组作为函数形参时，[]中的数字是可有可无的。”这句话。 31. 关于传值调用和传址调用。 这个世界上压根就没有什么传址与传值调用之说。C语言本身函数调用时，一直都是传值的，只不过说，传递的值既可以是变量名，也可以是这个变量的指针。 32. 输入型参数与输出型与返回值问题。 对于一个函数，我们都知道函数名本质就是整个代码段的首地址，而形参时函数的输入部分，返回值是函数的输出部分。对函数的进一步理解：把函数当做是一个数据加工的机器，通过输入型参数放入加工原材料，通过返回值输出成品。 那么，假如一个函数既没有返回值，也没有形参列表，那么它的作用和全局变量的效果就一样了。使用全局变量可以省略传参的开销，相对效率要高一点；而在实战当中使用最多的还是传参的这种形式，这里假如参数很多传参的开销很大的话，通常的做法把很多参数打包成一个结构体，然后传结构体变量指针进去即可。 33. 函数需要向外部返回多个返回值时应该怎么办？ 现实编程中，一个函数需要多个返回值时非常普遍的,因此说仅仅依赖平时的那一种只有一个返回值的情况是无法实现的。所以，通常使用的方法是使用参数来实现多个返回值问题。 比较普遍的做法：编程中函数的输入和输出都是靠函数参数来实现的，返回值只是用来表示函数执行的是成功还是失败。如果这个参数是用来做输入的，就叫做输入型参数；如果是想把函数内部数据输出到函数外部的，这一种就叫做输出型参数。作为输入型参数的，一般是加了const的。 34. 1234567891011#define和typedef#define dpChar char *typedef char * tpChar;dpChar p1,p2;tpChar p3,p4;printf(&quot;sizeof(p1) = %d, sizeof(p2) = %d\n&quot;,sizeof(p1),sizeof(p2));printf(&quot;sizeof(p3) = %d, sizeof(p4) = %d\n&quot;,sizeof(p3),sizeof(p4));运行结果：sizeof(p1) = 4, sizeof(p2) = 1sizeof(p3) = 4, sizeof(p4) = 4说明：使用#define宏定义来定义变量的时候，是不可以连着定义变量的。 35. 指针数组与数组指针： 1234567891011121314151617181920212223242526//指针数组int i = 0;char *pChar[] = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;&#125;;for(i=0;i&lt;sizeof(pChar)/sizeof(pChar[0]);i++)&#123; printf(&quot;pChar[%d]=%s\n&quot;,i,pChar[i]);&#125;运行结果：pChar[0]=onepChar[1]=twopChar[2]=three//数组指针(等效为二维数组)int i = 0,j = 0;int a[2][4] = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;&#125;;int (*pa)[4] = a;for(i=0;i&lt;sizeof(a)/sizeof(a[0]);i++)&#123; for(j=0;j&lt;4;j++) &#123; printf(&quot;a[%d][%d]=%d\n&quot;,i,j,*(*(pa+i)+j)); &#125;&#125;运行结果：a[0][0]=1a[0][1]=2... 判断到底是数组指针、指针数组、函数指针、指针函数这一类的方法？ 第一步，找核心(函数名) 第二步，找与核心最接近的那个符号(即为本质) 第三步，逐层的向外扩展即可 36. 函数指针与指针函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465函数指针：第一种：这叫做函数指针没错，但是是最最基本的概念void func()&#123; printf(&quot;function pointer\n&quot;);&#125;main:void (*pFunc)() = func;void (*pFunc2)() = &amp;func; //(1)(2)的效果是等效的(*pFunc)();pFunc2(); // 下面的两行也是等效的第二种：函数指针通常用在函数传参中int compare_int(void *a,void *b)//比较两个整数&#123; if(*(int *a) == *(int *)b) return 0; else return 1;&#125;int compare_char(void *b,void *b)//比较两个字符&#123; if(*(char *)a == *(char *)b) return 0; else return 1;&#125;int Compare(void *a,void *b,int (*compare)(void *,void *))&#123; if(compare(a,b) == 0) printf(&quot;They are equal\n&quot;); else printf(&quot;They are not equal\n&quot;);&#125;main:int a=1,b=1;char c1=&apos;a&apos;,c2=&apos;b&apos;;Compare(&amp;a,&amp;b,compare_int);Compare(&amp;c1,&amp;c2,compare_char);运行结果：They are equalThey are not equal指针函数：该举例的功能是：利用指针函数，打印出二维数组(a[3][4])的某一行的内容float *pFind(float (*p)[4],int n)&#123; float *pf; pf = *(p+n); return pf;&#125;main:int i,n;float *p;float Array[3][4] = &#123;&#123;11,11,11,11&#125;,&#123;22,22,22,22&#125;,&#123;33,33,33,33&#125;&#125;;printf(&quot;请您输入要打印的行号:&quot;);scanf(&quot;%d&quot;,&amp;n);printf(&quot;第%d行的内容是:\n&quot;,n);p = pFind(Array,n-1);for(i=0;i&lt;4;i++) //目的：从起始位置(行)连续输出4个元素&#123; printf(&quot;%3.2f\t&quot;,*(p+i)) ;&#125;运行结果：请您输入要打印的行号: 1第1行的内容是：11.00 11.00 11.00 11.00 37. Linux中的命令默认是行缓冲的，行缓冲指的是程序printf输出时，Linux是不会一个字、一个字的输出我们输入的内容的，而是将其缓冲起来，放在一个缓冲区中，等这一行准备完了(遇到’\n’时)，然后再一次性的把整行的内容都给输出出来。 38. 二维数组 12345678910111213141516int Array[3][4] = &#123;&#123;0,1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;8,9,10,11&#125;&#125;;printf(&quot;Array的地址:%p\n&quot;,Array);printf(&quot;Array+1的地址:%p\n&quot;,Array+1);//差16字节printf(&quot;Array[0]的地址:%p\n&quot;,Array[0]);printf(&quot;Array[0]+1的地址:%p\n&quot;,Array[0]+1);//差4字节printf(&quot;%d\n&quot;,sizeof(Array));printf(&quot;%d\n&quot;,sizeof(Array[0]));运行结果：Array的地址:0028fe90Array+1的地址:0028fea0Array[0]的地址:0028fe90Array[0]+1的地址:0028fe944816另外一点：二维数组名a等价于&amp;a[0],a[0]等价于&amp;a[0][0],类比于一维数组名a等价于&amp;a[0]的味道。 Array 0 Array[0] 1 Array[0]+1 2 Array[0]+2 3 Array[0]+3 Array+1 4 Array[1] 5 Array[1]+1 6 Array[1]+2 7 Array[1]+3 Array+2 8 Array[2] 9 Array[2]+1 10 Array[2]+2 11 Array[2]+3 39. 程序中的内存是从哪里来的？ 对于程序来讲，内存是程序的立足之地，也就是说程序是放在内存当中运行的。程序在运行的时候，需要内存来存储一些临时变量。内存管理的实现是由操作系统所完成的。三种内存来源：栈(statck)、堆(heap)、数据区(data) 栈(statck):程序运行时自动分配、自动回收；反复的使用(脏内存)；函数是不可以返回栈变量的指针的；栈是会溢出的。 解释为什么函数是不可以返回栈变量的指针的？但是注意返回堆内存的指针是可以的。 答：局部变量的作用域，只在函数的内部(即{}内)，函数返回值后局部变量的内存就已经释放了。这样指针指向的内容就是不可预料的内容，调用就会出错的。 程序运行时使用malloc申请任意字节的内存，程序员自己负责何时free掉这些内存。动态内存的生存期是程序员自己来掌控的，所以，使用起来就特别的灵活。 什么是内存释放？所谓的释放，就是操作系统收回了你对这段内存的使用权限。 12345678910111213141516171819202122232425262728293031323334353637383940//返回存放在只读数据段(ORData)上面的变量的指针char *returnData()&#123; char *p = &quot;Good Morning\n&quot; ; return p;&#125;main:char *p;p = returnData();printf(&quot;%s\n&quot;,p);运行结果：hello world总结：&quot;Good Morning&quot;是一个字符串常量，存放在只读数据段ORData上面。把该字符串常量存放在只读数据段(ORData)的首地址赋值给了指针，所以returnData函数退出时，该字符常量的内存是不会被回收的。//返回指向堆内存的指针是可以的char *returnHeap(int num)&#123; char *p = (char *)malloc(sizeof(char *)*num) ; return p;&#125;main:char *p = NULL;p = returnHeap(100);strcpy(p,&quot;Good Morning&quot;);printf(&quot;%s\n&quot;,p);free(p);运行结果：Good Morning总结：见上。//返回栈变量的指针(是不正确的)char *returnStatck()&#123; char a[] = &quot;Good Morning&quot; ; return a;&#125;main:char *p = NULL;p = returnStatck();printf(&quot;%s\n&quot;,p);运行结果：输出的是乱码总结：returnStatck函数退出时，栈要清空，函数对内存的使用权限已经终止。这时，函数返回的是一个已经被释放掉了的内存地址，所以打印出来很可能是乱码。解决方法：非要返回一个局部变量的地址，加上static修饰，改变它的生存期，即可。 堆内存 栈内存的管理方式类似于统一的平均分配(小块内存)。所以，栈内存一般是不会很大的，它考虑的是每一个进程普遍的使用内存块的大小，来设置一个合适的、尽量可以满足大众所使用的内存块。而堆内存的管理方式是”按需分配”的。需要的多的话，那就多分配一点、需要少的话那就少分配一点。各个进程可以按照需求手动申请使用，使用完以后手动的将内存释放掉即可。 malloc实际返回的是本次申请的那一段内存空间的首地址。 malloc申请得到的内存在使用完以后要free掉的，把该内存给释放掉。 在调用free释放内存之前，指向这段内存的指针是不可以丢失的(p不可以再赋给其他值)，一旦p丢了，那就会造成内存泄漏。 在gcc编译环境下，当我malloc(1),malloc(2),malloc(3)……是编译器到底分配多少字节空间？ 答：在gcc环境下，malloc分配内存空间默认最小是16Byte。当我们需要多少字节的内存空间的话，只需要malloc(n),此时编译器给你分配的内存空间并不一定刚刚好恰好就是n，但是是不可以确保你够用的(设置一个无穷大的数除外)。 代码段：是由一个一个的函数堆垒而组成的 数据段：可以理解为C语言中的全局变量 BSS段：本质是初始化为0的 数据段 40. 小知识点：第一点：字符0的ASCII码为48 第二点：字符’\0’的ASCII码是0 123456char c1 = &apos;0&apos;;char c2 = &apos;\0&apos;;printf(&quot;c1 = %d\nc2 = %d\n&quot;,c1,c2);运行结果：c1 = 48c2 = 0 41. 字符常量与字符串常量 1234567891011121314char c1 = &apos;a&apos;;char *p = &quot;good&quot;;printf(&quot;c1 = %d\n&quot;,c1);printf(&quot;字符串的地址:0x%p\n&quot;,&quot;good&quot;);printf(&quot;p = 0x%p\n&quot;,p);printf(&quot;sizeof(c1) = %d\n&quot;,sizeof(c1));printf(&quot;sizeof(good) = %d\n&quot;,sizeof(&quot;good&quot;));运行结果：c1 = 97字符串的地址：0x00409077p = 0x00409077sizeof(c1) = 1sizeof(good) = 5总结：字符常量是用单引号括起来的一个字符，相当于一个整形值，可以参与表达式的运算；字符串常量是用双引号括起来的若干个字符，代表的是一个地址值，即该字符串在内存中存放的位置。字符常量只占用1字节，而字符串常量占若干字节，至少占用一个字节(&apos;\0&apos;结束标志)。 42. 字符数组和字符串的本质差别(内存分配角度) 字符数组char a[] = “linux”,定义了一个数组a,数组a占6个字节，等号右边的”linux”本身仅存在于编译器中，编译器将它用来初始化字符数组a之后就丢弃掉了(内存中是没有字符串”linux”的)，相当于是:char a[] = {‘l’,’i’,’n’,’u’,’x’,’\0’};共占6字节。 字符串char *p = “linux”;定义一个字符指针p,p占4字节，分配到栈上面；与此同时定义了字符串”linux”分配在代码段上，然后将代码段中的字符串的首地址赋值给指针p。共占10字节。 43. 结构体成员的访问方式：常见的(“.成员名”或者”-&gt;成员名”);底层实现的方式，这里重点讲底层实现原理。 12345678910111213141516171819202122232425262728293031323334struct A&#123; char a; int b; double c;&#125;;main: struct A a; a.a = &apos;A&apos;; a.b = 5; a.c = 12.34; printf(&quot;sizeof(a) = %d\n&quot;,sizeof(a)); char *pc = (char *)&amp;a; printf(&quot;%c\n&quot;,*pc); printf(&quot;***************************\n&quot;); int *pi = (int *)((int)&amp;a+4); printf(&quot;%d\n&quot;,*pi); int *pi2 = (int *)(int(&amp;a+4)-60);//加4相当于加4*sizeof(a)=64 printf(&quot;%d\n&quot;,*pi2); printf(&quot;***************************\n&quot;); double *pd = (double *)((int)&amp;a+8); printf(&quot;%.2lf\n&quot;,*pd); double *pd2 = (double*)(int(&amp;a+8)-120);//加8相当于加8*sizeof(a)=128 printf(&quot;%.2lf\n&quot;,*pd2);运行结果：sizeof(a) = 16A***************************55***************************12.3412.34总结：我们平时使用的&quot;.成员名&quot;或者&quot;-&gt;成员名&quot;的方式访问成员，其实是编译器对其做了封装的，底层的实现原理其实是这样子的(是比较麻烦的)。 44. 关于结构体成员对齐问题：(这是一个很大的坑，最好点到为止) 一般类型： 12345678910111213141516171819202122#pragma pack(4) //设置4字节对齐 //#pragma pack(2) 设置2字节对齐struct A&#123; char a; //1-&gt;2 //1-&gt;2 short b; //2-&gt;2 //2-&gt;2 int c; //4-&gt;4 //4-&gt;4 double d; //8-&gt;8 共计16 //8-&gt;8 共计16&#125;;struct A2&#123; char a; //1-&gt;4 //1-&gt;2 int b; //4-&gt;4 //4-&gt;4 short c; //2-&gt;4 //2-&gt;2 double d; //8-&gt;8 共计20 //8-&gt;8 共计16&#125;;struct A3&#123; char a; //1-&gt;4 //1-&gt;2 double b; //8-&gt;8 //8-&gt;8 short c; //2-&gt;4 //2-&gt;2 int d; //4-&gt;4 共计20 //4-&gt;4 共计16&#125;; 总结：现象一：char有时候是”1-&gt;2”，而有一些时候是”1-&gt;4”什么原因导致的呢？short有时候是”2-&gt;2”，而有一些时候是”2-&gt;4”，这又是什么原因导致的呢？答：这是一个非常考验语言总结能力的一次组织语言，写出来我都不一定完全懂。 在4字节对齐的情况下： 当char类型成员后面的成员类型是short时，short占2字节，要尽量的确保char占字节数与short保持接近；2 = 1 + 1 当char类型成员的成员类型为int时，int占4字节，要尽量的确保char占字节数与int保持接近；4 = 1 + 3 当char类型成员是double时，double占8字节，要尽量的确保char占字节数与double保持接近，但是，这里是4字节对齐的情况，所以说4 = 1 + 3 在2字节对齐的情况下： 当char类型后面是short类型时，short占2字节，要尽量的确保char占字节数与short保持接近；2 = 1 + 1 当char类型后面是int类型时，int占4字节，要尽量的确保char占字节数与int保持接近，因为我们这里是2字节对齐的情况，所以说，2 = 1 + 1 当char类型后面是double类型时，double占8字节，要尽量的确保char类型占字节数与double保持接近，但是我们这里是2字节对齐的情况，所以说，2 = 1 + 1 同理呢，short所遵守的规则是和char类型是一模一样的。 嵌套类型： 123456789101112131415161718192021#pragma pack(4)typedef struct A&#123; char a; //1-&gt;4 int b; //4-&gt;4 double c; //8-&gt;8 共计16&#125;sa;struct B&#123; int a; //4-&gt;4 char b; //1-&gt;4 sa s; //13-&gt;16 short c; //2-&gt;4 共计28&#125;;struct C&#123; char a; //1-&gt;4 int b; //4-&gt;4 char c[15]; //15-&gt;16 共计24&#125;; 最后，2个关于结构体内存对齐，小知识点： 第1：static修饰的结构体成员是不占用内存空间的。 第2：空的结构体占用1字节大小的内存空间。 45. 1关于__attribute__((packed))和__attribute__((aligned(n)))的使用，暂且混个脸熟。 1234567891011121314struct A&#123; char a; //1-&gt;4 int b; //4-&gt;4 short c; //2-&gt;4 double d; //8-&gt;8 共计15(4字节对齐时，20字节)&#125;__attribute__((packed));结果分析：(1)加上__attribute__((packed))和我们#pragma pack(1)----#pragma pack()的效果是一样的。关于__attribute__((packed))这个玩意的使用效果，亲测与传说中所谓的平台是有关联的。在QT编辑器中，__attribute__((packed))它是不起任何的效果的，而换到Ubuntu中相同的代码__attribute__((packed))这个玩意才真正的起到效果。(2)而__attribute__((aligned(n)))这个东西与#pragma pack(n) 所起到的效果是有点相似的。不同的是#pragma pack(n)是对结构体各元素设置n字节对齐，而它是对整个结构体设置成为n字节对齐方式。意思就是说：譬如，__attribute__((aligned(1024)))；结构体成员内部的数据该按照几字节对齐、还按照它原来的几字节去对齐，而整个结构体是按照1024字节对齐。也就是4+4+4+8+填充(1024-(4+4+4+8))。 怎么样设置不对齐的访问呢？ 要在想要设置的那一些结构体的区间加上: 1234#pragma pack(1)......#pragma pack() 那，要想设置在这一块区域中n字节对其呢，只需要将”1”替换成为”n”即可实现。 46. 12345678910111213141516#define offsetof(TYPE,MEMBER) ((int) &amp;((TYPE *)0)-&gt;MEMBER)struct A&#123; char a; //1-&gt;4 int b; //4-&gt;4&#125;;main:int cnt;cnt = offsetof(struct A,b);printf(&quot;cnt = %d\n&quot;,cnt);运行结果：4分析：(TYPE *)0 将0强转成(TYPE *)，0指向了该结构体((TYPE *)0)-&gt;MEMBER 利用指针引用结构体成员的方式访问MEMBER成员&amp;(((TYPE *)0)-&gt;MEMBER)取该MEMBER成员的地址，最后将该地址强转为int目的：已知结构体中某一个元素和整个结构体的类型，求该元素与结构体首地址之间的偏移量。 2018-5-14 20:21:48刚刚电脑再一次黑屏、导致这一些东西又要重新写。我揣测是VMWare中的Ubuntu14.04版本与电脑不兼容所导致的，我又下载了一个Ubuntu16.04版本的。 记得记得记得，没事就按Ctrl+S，百利而无一害呀。 47. 关于typeof的理解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//demo 1 定义指针类型int a = 5;typeof(int *) pi = &amp;a;printf(&quot;&amp;a = %p\n&quot;,&amp;a);printf(&quot;pi = %p\n&quot;,pi);printf(&quot;a = %d\n&quot;,a);printf(&quot;*pi = %d\n&quot;,*pi);运行结果：&amp;a = 0x7ffe9296ed3cpi = 0x7ffe9296ed3ca = 5*pi = 5//demo 2 定义整形1. 简单的整形int *p = NULL;typeof(*p) a = 5;printf(&quot;a = %d\n&quot;,a);运行结果：a = 52. 结合函数指针数组定义的整形int add(int a,int b)&#123; return a+b;&#125;int sub(int a,int b)&#123; return a-b;&#125;int mul(int a,int b)&#123; return a*b;&#125;main：int (*fpa[4])(int a,int b) = &#123;add,sub,mul&#125;;typeof(fpa[0](1,1)) a = 12;typeof(fpa[1](1,1)) b = 34;typeof(fpa[2](1,1)) c = 56;printf(&quot;a=%d\tb=%d\tc=%d\n&quot;,a,b,c);运行结果：a=12 b=34 c=56//demo 3 定义数组int i = 0;int *p = NULL;typeof(*p) array[4] = &#123;1,2,3,4&#125;;for(i = 0;i &lt; 4;i++)&#123; printf(&quot;array[%d] = %d\n&quot;,i,array[i]) ;&#125;运行结果：array[0] = 1array[1] = 2array[2] = 3array[3] = 4//demo 4 定义字符串数组int i = 0;typeof(typeof(char *) [4]) pa = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;&#125;;for(i=0;i&lt;4;i++)&#123; printf(&quot;pa[%d] = %s\n&quot;,i,pa[i]) ;&#125;运行结果：pa[0] = onepa[1] = twopa[2] = threepa[3] = four//demo 5 结合#define,定义字符串数组#define pointer(T) typeof(T *) #define array(T, N) typeof(T[N])main:int i = 0;array(pointer(char),4) pc = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;&#125;;//pointer(char)-&gt;typeof(char *) array(char *,4)-&gt;typeof(char *[4])for(i = 0;i &lt; 4;i++)&#123; printf(&quot;pc[%d] = %s\n&quot;,i,pc[i]) ;&#125;运行结果：pc[0] = onepc[1] = twopc[2] = threepc[3] = four//demo 6 linux源码摘录#define min(x,y) (&#123;typeof(x) _x=(x);typeof(y) _y=(y);(void) (&amp;_x==&amp;_y);_x&lt;_y?_x:_y;&#125;)main:float tmp ;tmp = min(1.2,3.4);printf(&quot;tmp = %f\n&quot;,tmp);运行结果：tmp = 1.200000解析：typeof(x) _x = (x);typeof(y) _y = (y);min()函数可以接受任何类型的参数(void)(&amp;_x == &amp;_y);使用指针类型来做比较，当两个指针类型不一致时，编译器就会给出相应的警告信息。总结：typeof就是用来获取变量的数据类型的。 48. 关于container_of宏： 12345678910111213141516171819#define container_of(ptr,type,member) (&#123; \ const typeof(((type *)0)-&gt;member) *__mptr = (ptr);\(type *) ((char *) __mptr - offsetof(type,member));&#125;)struct A&#123; int a; char b; double c;&#125;;main:struct A a;struct A *pa = NULL;char *pc = &amp;a.b;pa = container_of(pc,struct A,b);printf(&quot;pa = %p\n&quot;,pa);printf(&quot;&amp;a = %p\n&quot;,&amp;a);运行结果：pa = 0x7fff63258bb0&amp;a = 0x7fff63258bb0 关于container_of宏作用：通过结构体变量中某一个成员的首地址，从而获取整个结构体变量的首地址。 container_of(ptr,type,member) ptr:指向结构体成员的指针 type:整个结构体的类型 member:结构体中的数据成员 49. 关于共用体union 123456789101112131415161718192021222324252627282930struct S&#123; int a; char b;&#125;;union U&#123; int a; char b;&#125;;main:struct S s;union U u;s.a = 5;u.a = 5;printf(&quot;s.b = %d\n&quot;,s.b);printf(&quot;u.b = %d\n&quot;,u.b);printf(&quot;&amp;s.a = %p\t&amp;s.b = %p\n&quot;,&amp;s.a,&amp;s.b);printf(&quot;&amp;u.s = %p\t&amp;u.b = %p\n&quot;,&amp;u.a,&amp;u.b);printf(&quot;sizeof(s) = %d\n&quot;,sizeof(s));printf(&quot;sizeof(u) = %d\n&quot;,sizeof(u));运行结果：s.b = 0u.b = 5&amp;s.a = 0xbfb4e558 &amp;s.b = 0xbfb4e55c&amp;u.s = 0xbfb4e554 &amp;u.b = 0xbfb4e554sizeof(s) = 8sizeof(u) = 4分析：结构体变量a和b两者的地址是一样的，也就是它们是指向了同一块内存空间。当访问结构体成员a时，就按照int类型来解析这一段内存空间；当访问结构体成员b时，就按照char类型来解析这一段内存空间。 50. 关于大小端的概念 早起呢，在串口通信中，一次只可以发送一个字节，而当我们发送一个int类型的数据时，是先发送Byte0 Byte1 Byte2 Byte3呢，还是Byte3 Byte2 Byte1 Byte0呢？这就是通信中的大小端问题。 现在我们所讲的大小端问题指的是计算机存储系统的大小端问题。 1234567891011121314151617181920212223242526//采用union方式测试大小端union U&#123; int a; char b;&#125;;void endian(int data)&#123; if(data == 1) &#123; printf(&quot;小端模式\n&quot;); &#125; else &#123; printf(&quot;大端模式\n&quot;); &#125;&#125;main:union U u;u.a = 1;endian(u.b);运行结果：小端模式//采用指针方式测试大小端int a = 12345678;printf(&quot;%d\n&quot;,*(char *)&amp;a);运行结果：78 bit … … 7654 3210 每4bit为1组 小端 模式 7 8 大端 4 3 2 1 51. 枚举 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//demo 1 枚举类型的定义和枚举变量的声明分开来enum DAY&#123; Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday,&#125;;main:enum DAY d;d = Monday;switch(d)&#123; case Monday: printf(&quot;Today is Monday\n&quot;);Monday += 1;break; case Tuesday: printf(&quot;Today is Tuesday\n&quot;);Tuesday += 1;break; case Wednesday: printf(&quot;Today is Wednesday\n&quot;);Wednesday += 1;break; case Thursday: printf(&quot;Today is Thursday\n&quot;);Thursday += 1;break; case Friday: printf(&quot;Today is Friday\n&quot;);Friday += 1;break; case Saturday: printf(&quot;Today is Saturday\n&quot;);Saturday += 1;break; case Sunday: printf(&quot;Today is Sunday\n&quot;);Sunday += 1;break; default: break;&#125;运行结果：Today is Monday当d = Tuesday时，便会打印出Today is Tuesday//demo2 typedef的使用typedef enum workday //用workday代替enum workday&#123; Monday, Tuesday, Wednsday, Thursday, Friday, Saturday, Sunday,&#125;workday;main:workday w;w = Sunday;printf(&quot;w = %d\n&quot;,w);运行结果：w = 6 最后，在虚拟机中我把”加速3D图形”这一个选项给取消掉，目的是希望不要在我使用虚拟机的时候电脑给我突然地黑屏掉了，但愿如此。取消了之后，虚拟机开机变得很快的呢。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>标签</tag>
      </tags>
  </entry>
</search>
