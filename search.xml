<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[测试]]></title>
    <url>%2F2018%2F06%2F11%2F%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[哈哈哈哈哈哈哈 哈哈哈哈哈哈哈 哈哈哈哈哈哈哈 哈哈哈哈哈哈哈 哈哈哈哈哈哈哈]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言杂记]]></title>
    <url>%2F2018%2F06%2F11%2FC%E8%AF%AD%E8%A8%80%E6%9D%82%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. 预处理 从最开始的源程序到最后的可执行程序的过程： 工具：预处理器编译器 汇编器 链接器 过程：预处理 编译 汇编 链接 对应文件： (.i文件/源文件)(.s/汇编文件) (.o/目标 文件) (.elf/可执行文件) 上面的预处理器、编译器、汇编器、链接器再加上一些额外的可能会使用到的工具，合起来叫做编译工具链。gcc就是一个编译工具链。 预处理器存在的目的：帮助编译器做一些编译之前的杂碎的事，让编译器的功能聚焦。 常见的预处理操作： (1). 头文件包含 1#include &lt;stdio.h&gt;与#include &quot;a.h&quot;两种形式。带&quot;&lt;&gt;&quot;与带&quot; &quot;两类。 &lt;&gt; 第一点：专门用来包含系统提供的头文件的，也就是说这一些头文件是系统自带的，非程序员自己写的。第二点：C语言编译器只会到系统指定的目录，也就是编译器中配置好的目录中去寻找这个头文件，隐含的意思是说不回去到当前的目录下面寻找。假如找不到，那就会提示这个头文件不存在。譬如说。Linux中，所有的头文件都在/usr/include该目录下面存放着的。第三点：我们自己写的头文件也是可以使用&lt;&gt;来包含的，这种情况是：自己写了一个专门存放头文件的目录，将来在编译时使用-I参数来指定相应的目录。 “ “ 系统会默认的先从当前目录寻找相应的头文件，假如找不到则再去系统所指定的目录下面寻找。 头文件包含真正意义：在与处理阶段，将#include “a.h”这一行，将a.h这个头文件里面的内容原地展开、替换掉#include “a.h”这一句语句。 (2). 注释。 这预处理阶段，预处理器会拿掉程序中所有的注释语句，到了编译阶段以后程序中其实已经是没有注释了的。 (3). 条件编译 有时候程序希望可以有多种配置，我们在源代码编写时写好了各种的配置的代码，然后给它一个配置开关，然后在源码中修改配置开关来让程序可以编译出来不同的效果。 1234567891011121314151617181920212223242526272829303132//demo 1 #ifdef的使用#define TRUE 0 //这里无论为0，还是1，下面输出的结果是一样的，只要有定义。main:#ifdef TRUE printf(&quot;#define TRUE is exit\n&quot;);#else printf(&quot;#define TRUE is not exit\n &quot;);#endif 运行结果：#define TRUE is exit//demo 2 #ifdef的进一步使用，使用宏定义实现条件编译。#define DEBUG#undef DEBUG#ifdef DEBUG#define debug(x) printf(x)#else#define debug(x)#endifmain:debug(&quot;This is a debug info\n&quot;);运行结果：当使用&quot;#define DEBUG&quot;时，输出打印信息；当使用&quot;#undef DEBUG&quot;时无信息输出。//demo 3 #if的使用#define TRUE 1 //这里当TRUE定义为1时，打印第一句，否则打印第二句。main:#if (TRUE == 1) printf(&quot;TRUE is 1\n&quot;);#else printf(&quot;TRUE is 0\n&quot;);#endif运行结构：TRUE is 1需要注意：无论是#ifdef---#endif还是#if---#endif使用时一定要配对使用的。 (4). 宏定义 定义：宏定义就是原封不动的替换。 注意：使用宏定义时，是不可以吝啬使用”()”这个玩意的，以免引起不必要的错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//demo 1 1年中多少秒#define SEC_PER_YEAR (365*24*60*60UL)/*之所以加UL原因：保证在不同的设备上，都可以保证不会因为int的位数，而导致的溢出问题。*/main:unsigned int a = SEC_PER_YEAR;printf(&quot;a = %u\n&quot;,a); //%u以无符号整数的形式打印输出运行结果：a = 31536000总结：我们平时写的int a;此时编译器默认把当做a是一个有符号数。而当我们明确的写出unsigned int时，此时才是一个无符号的整数。8个二进制位，所能表示的无符号数范围：0~255；有符号数的范围-128~+127，当做结论记住这个规律。//demo 2 关于#define与typedef在预处理中的作用在源文件中#define pChar char * //顺口溜&quot;红富士&quot;来记忆typedef int * pInt;main:char a = &apos;A&apos;;int b = 5;pChar pc = &amp;a;pInt pi = &amp;b;printf(&quot;*pc = %c\n&quot;,*pc);printf(&quot;*pi = %d\n&quot;,*pi);运行结果：*pc = A*pi = 5在使用gcc -E a.c -o a.i命令进行预处理以后生成的的.i文件中2处改动。main函数上面的#define pChar char*这一句消失了；在main函数中的第3行变成了char * pc = &amp;a;总结：实验表明，宏定义的确在预处理阶段已经给搞定了，而typedef定义的是在编译阶段处理的。//demo 3 带参宏与带参函数得举例int max_f(int a,int b)&#123; if(a&gt;b) return a; else return b;&#125;#define max_i(a,b) (a)&gt;(b)?(a):(b)main:int f,i;f = max_f(1,6);i = max_i(1,6);printf(&quot;f = %d\n&quot;,f);printf(&quot;i = %d\n&quot;,i);运行结果：f = 6i = 6总结：2者的区别。(1). 带参宏在预处理阶段被处理的，而函数是在编译阶段处理的。(2). 带参宏是原地展开，是没有调用开销的，因此效率比较高的；而带参函数不是原地展开的，是跳转执行，然后再返回过来的过程，是有调用开销的，因此效率相对慢。(3). 宏定义不会做类型检查，返回值也不会附带类型的；而函数是有明确的参数类型与返回值类型的。带参函数编译器会帮助我们做类型检查工作，而当带参宏类型不匹配时，编译时不会报错，但是可能此时实验结果已经是错误的了。这里很自然的就引入了内联函数inline关键字。内联函数：兼具函数的类型检查、宏定义的不调用开销，效率高的2个优点。使用条件：通常一个3~5行代码的函数，可以考虑使用内联函数。 2. 浅谈函数 (1). 函数将来被编译成可执行代码段，变量(主要指全局变量)，经过编译以后变成数据或者在运行时变为数据。基本上，所有的函数都是要有代码和数据的。代码是为了加工数据，而数据必须依赖代码才得以起作用。 (2). 函数的实质，就是数据处理器。函数是程序的一个缩影，函数的参数列表其实是为了给函数输入原材料；函数的返回值以及输出型参数是为了想外部输出目标数据。 (3). 函数载没有被执行时，是位于硬盘当中的，就好比是一台没有开动的机器一样，此时只是占用了一些存储空间但是并不占用资源(CPU+内存)的；而函数的每一次运行，就好比每一次机器开机运行一样，运行时是需要耗费资源(CPU+内存)的，运行时可以对数据加工成为目标数据。函数运行完毕以后，会释放掉之前所占用的资源。 (4). 整个程序的运行其实就是很多个函数相继的、连续的执行的过程。 3. 递归函数 递归的概念：只要是递归函数，那么必须总从：”只有最内的一层函数完成了任务以后，才轮得到它外面的一层函数执行任务。” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//demo 1 正常的递归函数简单的实现int factorial(int a)&#123; if(a == 0&amp;&amp; a &lt; 1) return 1; else return a*factorial(a-1);&#125;main:int a = 0;a = factorial(3);printf(&quot;a = %d\n&quot;,a);运行结果：a = 6总结：这里意外的出现了由于有符号与无符号数而引出的段错误问题。当factorial(-5),此时会打印出Segmentation fault (core dumped)段错误的提示信息。原因：编译器默认的情况是无符号数，而当我们(a==0&amp;&amp;a&lt;1),此时问题就出在了(a&lt;1)的这个比较上面了。编译器会默认的把-5转化成为无符号数。就是，原先最高位1是符号位，而现在1也是填充了有效的数据位。导致了程序一直处在else处循环的执行，当栈内存耗尽时，就出现了段错误。写个简单的程序验证一下：signed int a = -5; //定义a为有符号数printf(&quot;a = 0x%x\ta = %u\n&quot;,a,a);运行结果：a = 0xfffffffb a = 4294967291//demo 2 通过一个简单的递归程序，展现递归实现的原理int factorial(int a)&#123; printf(&quot;before factorial: a = %d\t&amp;a = %p\n&quot;,a,&amp;a); if(a &gt; 1) factorial(a - 1); else printf(&quot;factorial is stop，now a = %d\t&amp;a = %p\n&quot;,a,&amp;a); printf(&quot;after factorial: a = %d\ta = %p\n&quot;,a,&amp;a);&#125;main:factorial(3);运行结果：before factorial: a = 3 &amp;a = 0xbffd8a30before factorial: a = 2 &amp;a = 0xbffd8a10before factorial: a = 1 &amp;a = 0xbffd89f0factorial is stop，now a = 1 &amp;a = 0xbffd89f0after factorial: a = 1 a = 0xbffd89f0after factorial: a = 2 a = 0xbffd8a10after factorial: a = 3 a = 0xbffd8a30总结:1. 每一级函数都有自己的变量； 2. 每一次函数调用都会有一次返回； 3. 在递归函数中，位于递归函数之前的语句和各级被调用函数具有相同的执行顺序； 4. 在递归函数中，位于递归函数之后的语句和各级被调用函数的顺序相反。5. 必须要有终止递归语句。//demo 3 菲波那切数列的实现//菲波那切数列：F(0)=0;F(1)=1;F(n)=F(n-1)+F(n-2),(n&gt;=2)int Fib(int a)&#123; if(a == 0|| a == 1) return a; else if(a &gt;= 2) return (Fib(a-1)+Fib(a-2));&#125;main:Fib(3);运行结果：a = 2 4. 函数库 定义：函数库是一些事先写好了的函数的集合，当我们使用库中的某一个函数时，只需要包含相应的头文件，之后就可以不需要自己写该函数，直接调用该函数即可。 函数库的提供形式：动态链接库与静态链接库 作用：作为参与链接过程的一份子，函数库与编译所生成的目标文件(.obj)，一起生成可执行代码(.exe)。由于，函数库是在此时可参与完成链接操作的，所以说它本身就是一连串的二进制序列。 5. (接下来的这一些概念，估计要至少记上个10几遍，这样才勉强把文字转化为自己的知识)。 角度1： 静态链接：把静态链接库文件中所使用到的函数代码直接链接进入目标程序，此时程序在运行的时候就不再需要其他的库文件了； 动态链接：把调用的函数所在的文件模块(DLL–动态链接库)——交代了使用的是那一个库文件，和调用函数在文件中的位置等信息链接入目标程序，此时仅仅是相当于把一个真正所需要的实体的一个引子链接进入了目标程序中。当程序运行的时候，再从DDL中通过这个引子来找到相应的函数代码，从而找到函数的实体，从而完成链接的这个动作。 角度2： 静态链接：库中所使用到的函数(指令)都全部的伴随着链接的过程，最终包含在了可执行文件中了。 动态链接：而使用动态链接的方式，库中所要使用到的函数(指令)在伴随着链接的过程中，所生成的可执行程序中并不包含，我们之前所需要的函数的实体，仅仅包含了这个实体的一个索引。 角度3： 站在开发者的角度 作为开发者我们只需要给用户提供库的.h头文件和库文件(是由ar工具将目标文件转化成为静态链接库文件)。客户拿到静态链接库文件(.a)和头文件(.h)时，通过.h文件可以得知函数的原型，然后就可以在自己的程序中直接拿来使用(调用)，在链接时，链接器会自动到.a文件中拿出这个函数所对应的.o文件，然后与自己本身程序所生成的.o文件结合起来，共同的来完成链接过程，最终生成可执行程序。 角度4： 静态链接库由于在链接时将库文件中函数的实体所对应的目标文件，与本身的目标文件一起扮演了链接的过程，所以说，当库文件内容更改时，那么程序将要重新的再执行编译、链接的过程。不利于代码的可维护性。 而动态链接库库文件与可执行文件是分离开来的，并且在运行时或者是加载时才与可执行程序拼凑在一块的，有利于程序的可维护性。 重点语句：动态链接的时机有2个：一个是在载入时动态链接；而另一是在运行时动态链接。 6. 加载：把硬盘上的程序调到内存中的过程。由于软件想要运行必须先加载到内存里面，加载就是把所需要的文件以及信息读取到内存中，一般在启动程序时都伴随着加载的过程。 7. 位置有关码与位置无关码 通俗的例子：教室里面有6排8列一共48个座位。标号分别给编为1-48。分别有甲、乙两人。 位置有关：甲，你坐在1号位置；乙，你坐在8号位置。 ​ (拘谨，不需要PC，每一次操作都需要提供特定的地址) ​ 位置有关码不依赖于PC，是根据所给定的链接地址，而完成相应的操作的。 位置无关：甲坐在乙的前面。(随意，只要给我一个PC，接下来我就按部就班的走) ​ 位置无关码依赖于当前的PC，在PC基础上有条不紊的连续+4操作。 B、BL、MOV都属于位置无关码。 LDR PC,=LABEL等类似的代码都属于位置有关码。 8. 加载地址与运行地址 加载地址存储地址，只是说法不同而已。程序保存在NandFlash中的地址。 运行地址链接地址，只是说法不同而已。程序在SRAM中执行时的地址。 当我们从NandFlash启动时，硬件会自动的将NandFlash前xxKB代码拷贝到SRAM中，CPU从SRAM中起始地址处开始执行。 9. 虚拟内存：从硬盘上面划分出来一部分空间来作为内存使用。 假如说虚拟内存对应的有实际的物理内存单元，那么两者的地址一般是不相等的。通过操作系统的某一种内存管理和映射技术，可以建立虚拟内存与实际物理内存之间的对应关系，当程序员在访问虚拟地址是会自动的转化成为另一个实际的物理地址。 10. 什么是进程？ 在操作系统中运行的程序，它是操作系统资源管理的最小的单位。进程是一个动态的实体，它是程序的一次执行过程。进程与程序的区别在于：进程是动态的，程序是静止的，进程是正在运行的程序，而程序是一些保存在硬盘上的一些可执行代码。 进程由3部分组成：代码段、数据段、堆栈段，也就是进程 = 程序段+数据段+进程控制块PCB。而代码段、数据段、bss段的内容是可执行文件中所对应的内容。 PCB进程控制块是进程存在的惟一的标识，操作系统通过PCB的存在而感知到进程的存在。进程控制块是通过一个名字叫做task_struct的结构体实现的，存在的主要目的是操作系统通过PCB对进程进行管理以及调度。进程与PCB是一一对应的关系。 每当创建一个进程时，便在内存中申请一个task_struct的结构体来表示。 总结： 加载程序时并不是把这些程序的内容从可执行程序中填充到内存当中，而是将它们的信息(基地址、长度)更新到PCB进程控制块(task_struct)中，当CPU第一次实际寻址执行时，会触发缺页中断，操作系统在这个过程中会再将实际的内容从可执行文件中复制内容到内存中去。 11. 编程中遇到十进制数与十六进制数相加时的处理方法 12345678int a = 0x1234;a = a + 12;printf(&quot;a = 0x%x\n&quot;,a); //以十六进制方式打印printf(&quot;a = %d\n&quot;,a); //以十进制方式打印运行结果：a = 0x1240a = 4672总结：当十六进制数与十进制数相加时，要么统一的都换算成为十六进制数来计算，OK；要么都换算成十进制来计算也是OK的。总之，就是要化成统一的形式来计算。 12. 关于返回值为指针和返回值为数组名的理解 1234567891011121314151617181920212223char *returnStr()&#123; char *p = &quot;Good Morning&quot;; //编译时&quot;Good Morning&quot;的值就已经确定了(ROData) return p;&#125;char *returnArray()&#123; char arr[] = &quot;hello world&quot;; //运行时初始化&quot;hello world&quot;的值才确定(栈) return arr;&#125;main:char *pS = NULL;char *pA = NULL;pS = returnStr();pA = returnArray();printf(&quot;pS = %s\n&quot;,pS);printf(&quot;pA = %s\n&quot;,pA);运行结果：pS = Good MorningSegmentation fault (core dumped)问题：什么导致了段错误的发生？解释原因。答：函数returnStr中p虽然是局部变量，被分配在栈上面，它的作用域是整个returnStr函数内部。但是它所指向的&quot;Good Morning&quot;是存放在只读数据段(ROData)中的，直到整个程序结束以后才会被销毁掉的。这也就意味着，我们在main函数中来引用这个指针里面的内容是有意义的。而returnArray函数中arr是一个数组名，被分配到栈上面，&quot;hello world&quot;作为数组中的各个元素值放进数组中，一点returnArray函数退出，栈中的这一块内存也就随之被释放掉了。而在main函数种，虽然说同样的返回了一个地址，但是这个地址所指向的存储区域已经失去了意义了，故，引发了段错误的发生。 13. 关于局部变量的地址排序有规则嘛？讨论 123456789101112//demo 1int a;int b;printf(&quot;&amp;a = %p\n&quot;,&amp;a);printf(&quot;&amp;b = %p\n&quot;,&amp;b);//运行结果：&amp;a = 0xbf8a3428 &amp;b = 0xbf8a342c//demo 2double a;int b ;printf(&quot;&amp;a = %p\n&quot;,&amp;a);printf(&quot;&amp;b = %p\n&quot;,&amp;b);//运行结果：&amp;a = 0xbfc319c8 &amp;b = 0xbfc319c4从实验结果观察、加上网上的查询结果暂且如下：局部变量在栈上面的排列顺序取决于编译器，也就是说随机的。一般来讲，当两个数据类型相同的变量时，地址排序是按照递增的方式进行排布的。 14. memcpy函数 原型：void memcpy(void dest, const void *src, size_t n) 作用：把src所指向的内存单元中的内容复制n字节带des所指向的内存单元中。 123456789101112131415161718192021222324//demo 1 对memcpy函数的简单使用char *p = &quot;Good Morning&quot;;char buf[1024];strcpy(buf,memcpy(buf,p,15));printf(&quot;buf = %s\n&quot;,buf);运行结果：buf = Good Morning//demo 2 对memcpy函数的实现void *_memcpy(void *des,const void *src,int cnt)&#123; char *d = des; const char *s = src; while(cnt--) &#123; *d++ = *s++; &#125; return des;&#125;main：char *p = &quot;Good Morning&quot;;char buf[1024];strcpy(buf,_memcpy(buf,p,15));printf(&quot;buf = %s\n&quot;,buf);运行结果：buf = Good Morning 15. memmove函数 原型：void memmove(void dest, const void *src, size_t n)通过man手册查知 作用：与memcpy函数一样。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//demo 1 简单使用memmove函数char *p = &quot;hello world&quot;;char buf[100];strcpy(buf,memmove(buf,p,11));printf(&quot;buf = %s\n&quot;,buf);运行结果：buf = hello world//demo 2 自己实现memmove函数void *_memmove(void *des,const void *src,int cnt)&#123; char *d = NULL; const char *s = NULL; if(des&gt;src+cnt || src&gt;des) &#123; d = des; s = src; while(cnt--) &#123; *d++ = *s++; &#125; &#125; else &#123; d = (des+cnt-1); s = (src+cnt-1); while(cnt--) &#123; *d-- = *s--; &#125; &#125; return des;&#125;main:char *p = &quot;hello world&quot;;char buf[1024];strcpy(buf,_memmove(buf,p,strlen(p)));printf(&quot;buf = %s\n&quot;,buf);运行结果：buf = hello worldd��总结：理解好以下几点。第一，void _memmove(void *des,const void *src,int cnt),形式参数中的void *理解void test(void *a,void *b)&#123; if(a&gt;b) printf(&quot;address a is larger than b\n&quot;); else printf(&quot;address a is smaller than b\n&quot;);&#125;main:int a = 2,b = 5;test(&amp;a,&amp;b);运行结果：address a is smaller than b第二，if(des&gt;src+cnt || src&gt;des)，这里涉及到一个小小的逻辑问题。des地址的大小满足src地址的大小+偏移量cnt，就不会发生重叠问题。第一反应的理解：src&gt;des,此时也是可以保证不会发生重叠的，但是src+cnt&gt;des，就不一定可以保证的哟。这里有一种&quot;比最大的值要大，小要比最小的值要小&quot;的味道，哈哈哈。第二反应的理解：看到一篇博客后，发现上面的第一反应是有错误的，&quot;src&gt;des&quot;此时，是有可能发生内存重叠的情况的。当des追上src的屁股尾巴以后，此时就发生了重叠问题。另外，只要把不发生重叠的这两种情况给理解好了，发生重叠的两种情况也就很好理解了。第三，strcpy(buf,_memmove(buf,p,strlen(p)));这句代码的理解。起初时，我写成buf = _memmove(buf,p,strlen)但是实践验证得知，是行不通的。这里面使用strcpy来给buf赋值时最好用的方法。第四，d = (des+cnt-1),s = (src+cnt-1)在else的src与des有重叠时，复制数据时要从高地址处开始复制地址。//demo 3 采用自己写的_memmove函数，访问结构体成员struct Stu&#123; char name[20]; int age;&#125;;main:struct Stu st;char *p = &quot;Good Morning&quot;;strcpy(st.name,_memmove(st.name,p,strlen(p)));printf(&quot;st.name = %s\n&quot;,st.name);运行结果：st.name = Good Morning��u� 总结：memcpy与memmove函数的主要区别：memmove是在memcpy之上做了进一步的改善工作，memcpy不可以处理src与des之间内存重叠的问题，而memmove函数可以。 16. memset函数 函数原型：void memset(void s, int c, size_t n) man手册查询得知 作用：将以s指向的内存单元的n字节填充为c,常用于内存空间的初始化,多用于清空数组。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//demo 1 简单演示用法char arr[] = &quot;abcdefg&quot;;memset(arr,&apos;A&apos;,sizeof(arr));printf(&quot;arr = %s\n&quot;,arr);memset(arr,0,sizeof(arr));printf(&quot;arr = %s\n&quot;,arr);运行结果：arr = AAAAAAAAarr = //demo 2 清除结构体变量中的内容struct Stu&#123; char name[1024]; int age;&#125;;main:struct Stu st;strcpy(st.name,&quot;auto man&quot;);st.age = 12;printf(&quot;st.name = %s\n&quot;,st.name);printf(&quot;st.age = %d\n&quot;,st.age);memset(&amp;st,0,sizeof(st));printf(&quot;st.name = %s\n&quot;,st.name);printf(&quot;st.age = %d\n&quot;,st.age);运行结果：st.name = auto manst.age = 12st.name = st.age = 0总结：写这个程序时遇到的问题：结构体成员变量是数组时的赋值如何操作？一开始我想到的是st.name=&quot;auto man&quot;可是编译时就给报错。解决的方法就是使用strcpy这个神器，即可轻松地搞定。//demo 3 对memset函数的实现void *_memset(void *s,int val,int cnt)&#123; if(s == NULL|| cnt &lt; 0) return 0; char *ret = s; while(cnt--) &#123; *ret++ = val; &#125; return ret;&#125;main:char arr[] = &quot;I am a good student&quot;;printf(&quot;%s\n&quot;,arr);_memset(arr,0,sizeof(arr));printf(&quot;%s\n&quot;,arr);运行结果：p = I am a good studentp = 17. memcmp函数 原型：int memcmp(const void s1, const void s2, size_t n); 作用：比较内存区域s1与s2的前n个字节。 12345678910111213141516171819202122232425262728293031323334353637//demo 1 memcmp简单使用int a = 0;const char *p = &quot;hello world&quot;;const char *q = &quot;hello earth&quot;;a = memcmp(p,q,7);printf(&quot;a = %d\n&quot;,a);a = memcmp(p,q,10);printf(&quot;a = %d\n&quot;,a);运行结果：a = 1a = 1实验结果：想要验证的是两者第7个字符&apos;w&apos;和&apos;e&apos;，以及第10个字符&apos;l&apos;和&apos;t&apos;的大小比较。但是实验的结果却显示都是a = 1.得出的结论是，当我们想比较第10个字符时，但是第10个字符之前一旦遇到有不相等的字符出现时，后面的字符的大小它将不会去理会了。//demo 2 memcmp的简单实现int _memcmp(const void *s1,const void *s2,int cnt)&#123; const char *str1 = s1; const char *str2 = s2; while(cnt != 0&amp;&amp;*str1 == *str2) &#123; str1++; str2++; cnt--; &#125; if(cnt == 0) &#123; return 0; &#125; return (*str1)&gt;*(str2)?1:-1;&#125;main:int a = 0;char *p = &quot;hello world&quot;;char *q = &quot;hello earth&quot;;a = _memcmp(p,q,7);printf(&quot;a = %d\n&quot;,a);运行结果：a = 1 18. memchr函数 原型：void memchr(const void s, int c, size_t n); 作用：s指向的字符串的前n个字节中，搜索第一次出现字符c的位置。若找到返回找到的这个字符的地址；若没有找到则返回NULL。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//demo 1 简单的使用char *p = &quot;hello world&quot;;char *q = NULL;q = memchr(p,&apos;w&apos;,5);if(q == NULL) printf(&quot;search failed\n&quot;);else printf(&quot;search success\n&quot;);运行结果：search failed//demo 2 更进一步理解参数列表中的void *s是什么意思const char *p = &quot;hello world&quot;;const char *q = NULL;q = memchr(p,&apos;o&apos;,12);if(q == NULL)&#123; printf(&quot;search error\n&quot;);&#125;else&#123; printf(&quot;search success\n&quot;); printf(&quot;the start:%p\tthe end:%p\tthe sub:%x\n&quot;,p,q,q-p); printf(&quot;the contents from %p is %s\n&quot;,q,q);&#125;运行结果：search successthe start:0x80485c0 the end:0x80485c4 the sub:4the contents from 0x80485c4 is: o world//demo 3 对memchr函数的实现void *_memchr(const void *s,int c,int cnt)&#123; const char *pTmp= s; char *pReturn = NULL; if(cnt&gt;0 &amp;&amp; s!=NULL) &#123; while(cnt) &#123; if(*pTmp == c) &#123; pReturn = pTmp; break; &#125; pTmp++; cnt--; &#125; &#125; return pReturn;&#125;运行结果：main函数利用demo 2中的代码，再匹配上我们自己实现的_memchr()函数，即可实现一模一样的效果。在书写demo 3的这一部分代码时，出现的疑惑还是蛮多的，这里给它一一的记录下来。第一点：充分的理解break在if、while、if嵌套的比较复杂的语境中的执行顺序。慎用自增、自减的运算符在有break的循环语句中。(自己遇到这种情况时，最好拆开一个一个的写)int a = 5;if(a &gt; 0)&#123; printf(&quot;I am count %d\n&quot;,a); while(a--) &#123; printf(&quot;start: Now I am count %d\n&quot;,a); if(a == 1) &#123; break; &#125; &#125; printf(&quot;End: Now I am count %d\n&quot;,a);&#125;运行结果：I am count 5start: Now I am count 4start: Now I am count 3start: Now I am count 2start: Now I am count 1End: Now I am count 1第二点：充分理解break、和continue的使用//使用break的情况int a = 0;for(a=0;a&lt;5;a++)&#123; printf(&quot;start:a = %d\n&quot;,a); if(a == 2) &#123; break; &#125; printf(&quot;End:a = %d\n&quot;,a);&#125;运行结果：start:a = 0End:a = 0start:a = 1End:a = 1start:a = 2//使用continue的情况int a = 0;for(a=0;a&lt;5;a++)&#123; printf(&quot;start:a = %d\n&quot;,a); if(a == 2) &#123; continue; &#125; printf(&quot;End:a = %d\n&quot;,a);&#125;运行结果：start:a = 0End:a = 0start:a = 1End:a = 1start:a = 2start:a = 3End:a = 3start:a = 4End:a = 4总结：当continue作为循环体的一部分时，一旦遇到continue时，立即结束本次循环，跳过循环体中尚未执行的部分，接着执行是否要继续执行的条件判断。而break作为循环体的一部分时，一旦遇到break立即退出当前的循环体，接着执行循环体之后的语句。 19. 昨天晚上，偶遇一道C语言题目，并且自己独立的解决掉了，收获蛮多的，特此记录下来。 2018-5-23 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//原始题目void get_memory(char *p)&#123; p = (char *)malloc(1024); strcpy(p,&quot;Hello World&quot;);&#125;void free_memroy(char *p)&#123; free(p);&#125;main:char *str;get_memroy(str);printf(&quot;%s\n&quot;,str);free_memroy(str);运行结果：*** Error in `./a.out&apos;: free(): invalid pointer: 0xb77ae000 ***Aborted (core dumped)//版本1 利用二重指针实现void get_memroy(char **p)&#123; *p = (char*)malloc(1024); strcpy(*p,&quot;Hello World&quot;);&#125;void free_memroy(char *p)&#123; free(p);&#125;main:char *str;get_memroy(&amp;str);printf(&quot;%s\n&quot;,str);free_memroy(str);运行结果：Hello World//版本2 利用设置一个中间变量作为返回值来实现void *get_memroy(char *p)&#123; char *pReturn = NULL; p = (char *)malloc(1024); pReturn = strcpy(p,&quot;Hello World&quot;); free(p); return pReturn;&#125;main:char *pTmp;char *str;pTmp = get_memroy(str);printf(&quot;%s\n&quot;,pTmp);运行结果：Hello World从版本1与版本2两个版本得出一个疑惑，为什么当传二重指针时，free内存就没有问题，而一级指针时就出现了问题呢？答：自己总结、感悟出来的。第一点：char *p = (char *)malloc(1024);p = p + 1;free(p);运行结果：Segmentation fault (core dumped)总结：在使用malloc时，malloc的是谁？那么我们就应该free谁。在中间过程中是不可以另外的赋值的。第二点：当我们传的是二级指针即p或者是&amp;str时，get_memory函数结束以后只是二级指针对一级指针的指向断掉了，而一级指针还是任然的存在的。而当我们传递的是一级指针时，get_memory函数结束以后一级指针对字符串的指向断掉了，此时还free一级指针时，就会报错。 20. 对二重指针的初步理解 123456789101112131415161718192021//demo 1 void dPointer(char **p)&#123; *p = &quot;change value success&quot;;&#125;main:char *p = &quot;Hello world&quot;;dPointer(&amp;p);printf(&quot;%s\n&quot;,p);运行结果：change value success//demo 2void dPointer(char **p)&#123; *p = (char *)malloc(1024);//这里强调、二级指针和一级指针本质是一模一样的， //也是一个指针，只不过它里面存储的值是一个一级的指针而已。 strcpy(*p,&quot;change value success&quot;)&#125;main:char *p = &quot;Good Morning&quot;;dPointer(&amp;p);printf(&quot;%s\n&quot;,p);运行结果：change value success 21. strcpy函数 原型：char strcpy(char dest, const char *src); 作用：将src起始地址开始且含有’\0’结束符的字符串复制到以dest开始的地址空间。返回值的类型为char*型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//demo 1 strcpy把字符串复制到数组中char arr[1024];strcpy(arr,&quot;Hello world&quot;);printf(&quot;%s\n&quot;,arr);运行结果：Hello world//demo 2 strcpy把字符串复制到指针变量所指向的内存单元中，指针--mallocchar *p = (char *)malloc(1024);strcpy(p,&quot;Hello world&quot;);printf(&quot;%s\n&quot;,p);运行结果：Hello world特殊案例：char *p;strcpy(p,&quot;Hello world&quot;);运行结果：Segmentation fault (core dumped)总结:p未被初始化，所以&quot;Hello world&quot;字符串有可能被赋值到任何的地方，因而触发的段错误。//demo 3 对strcpy函数的简单实现char *_strcpy(char *dest,const char *src)&#123; char *pReturn = dest; if(dest==NULL || src==NULL) return 0; while((*dest++ = *src++)!= &apos;\0&apos;); return pReturn;&#125;main:char *p = (char *)malloc(1024);_strcpy(p,&quot;Hello world&quot;);printf(&quot;%s\n&quot;,p);运行结果：Hello world//demo 4 对strcpy函数做进一步的了解char p[] = &quot;abcdefgh&quot;;char q[] = &quot;ABCD&quot;;_strcpy(p,q);printf(&quot;%s\n&quot;,p);运行结果：ABCD解释：我们都知道strcpy()函数赋值字符串时是连带&apos;\0&apos;一起都赋值过来的。这就是问题的根本所在。须知点：printf函数在遇到第一个&apos;\0&apos;时，就会停止往外输出。char *p = &quot;Hello\nworld\n&quot;;char *q = &quot;Hello\n\0world\n&quot;;printf(&quot;%s\n&quot;,p);printf(&quot;%s\n&quot;,q);运行结果：HelloworldHello看到这里以后，再回过头来看上面的调用strcpy函数打印出来的信息也就不足为怪了。 22. strncpy函数 函数原型：char strncpy(char dest, const char *src, size_t n); 作用：将字符串src中最多n个字符复制到字符数组dest中，返回指向dest的指针。 它在复制过程中相比strcpy()有2个终止条件，1. 当遇到’\0’是终止复制 2. 当复制到了第n个字符，此时还没有赋值完时也会自动的终止。 首先给函数中涉及到的3个长度，起3个名字。 n :指定长度 strlen(src) :源长度 strlen(dest) :目标长度 特点： 当指定长度小于源长时，将源长中按指定长度拷贝到目标字符串，此时不包括’\0’ 当指定长度大于源长时，将源长全部拷贝到目标字符串，(指定长度-源长)这么长空间使用’\0’来作为填充 当指定长度大于目标长度时，由于会产生数组越界，故会产生报错” stack smashing detected : ./a.out terminated Aborted (core dumped)” 补充一点：NULL与’\0’是等价的验证 123456789101112char arr[1024] = &#123;NULL,NULL,NULL&#125;;printf(&quot;arr[0] = %c\n&quot;,arr[0]);printf(&quot;arr[0] = %d\n&quot;,arr[0]);运行结果：arr[0] = arr[0] = 0char arr[1024] = &#123;&apos;\0&apos;,&apos;\0&apos;,&apos;\0&apos;&#125;;printf(&quot;arr[0] = %c\n&quot;,arr[0]);printf(&quot;arr[0] = %d\n&quot;,arr[0]);运行结果：arr[0] = arr[0] = 0 接下来使用一个一个的demo来理解strncpy函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//demo 1 指定长度小于源长度char a[20] = &quot;abcde fghij&quot;;char b[20] = &quot;ABCDE&quot;;strncpy(a,b,2);printf(&quot;%s\n&quot;,a);运行结果：ABcde fghij//demo 2 指定长度等于源长度char a[20] = &quot;abcde fghij&quot;;char b[20] = &quot;ABCDE&quot;;strncpy(a,b,5);printf(&quot;%s\n&quot;,a);运行结果：ABCDE fghij//demo 3 指定长度大于源长度char a[20] = &quot;abcde fghij&quot;;char b[20] = &quot;ABCDE&quot;;strncpy(a,b,6);printf(&quot;%s\n&quot;,a);运行结果：ABCDE//demo 4 对strncpy函数的简单实现，版本1char *_strncpy(char *dest,const char *src,int cnt)&#123; char *pReturn = dest; while(cnt &amp;&amp; (*dest = *str)!=&apos;\0&apos;) &#123; dest++; src++; cnt--; &#125; while(cnt--) &#123; *dest++ = &apos;\0&apos;; &#125;&#125;//demo 5 对strncpy函数的简单实现，版本2char *_strncpy(char *dest,const char *src,int cnt)&#123; int offset = 0; char *pReturn = dest; while(!(src!=NULL &amp;&amp;dest!=NULL)); if(cnt &gt; strlen(src)) &#123; offset = cnt-strlen(src); cnt = strlen(src); &#125; while(cnt--) &#123; *dest++ = *src++; &#125; while(offset--) &#123; *dest++ = &apos;\0&apos;; &#125; return pReturn;&#125;注意点：在&quot;if(cnt&gt;strlen(src))&quot;这个判断中，是不可以写成为&quot;if(cnt-strlen(src))&gt;0&quot;这一种形式的，假如写成为是这样子的话，就会报段错误。原因：cnt-strlen(src)之差是一个负数，相当于一个有符号数，它自动的转化成为无符号数。你想，此时把那个负数的最高位1，转成了实打实的无符号数，那么条件就会一直的成立，因此会出现段错误的情况。//demo 6 这是我们通常容易犯的错误的一种写法，但是是错误的。char *_strncpy(char *dest,const char *src,int cnt)&#123; char *pReturn = dest; while(!(src!=NULL &amp;&amp; dest!=NULL)); while(cnt--) &#123; *dest++ = *src++; &#125; return pReturn;&#125;问题出在：当指定长度大于源长度时，这份代码是没有做处理的。 23. strcat函数 函数原型：char strcat(char dest, const char *src); 函数作用：将src指向的字符串内容追加到dest所指向的字符串的后面，dest末尾的’\0’将会被覆盖掉，所以，’\0’这东西要自己添加上。 123456789101112131415161718//demo 1 strcat函数简单的使用char a[20] = &quot;abcde fghij&quot;;char b[20] = &quot;ABCDE&quot;;strcat(a,b);printf(&quot;%s\n&quot;,a);运行结果：abcde fghijABCDE//demo 2 strcat函数简单的实现char *_strcat(char *dest,const char *src)&#123; char *pReturn = dest; if(dest==NULL || src==NULL) return 0; while(*dest != &apos;\0&apos;) dest++; while((*dest++ = *src++)!=&apos;\0&apos;); *dest = &apos;\0&apos;; return pReturn;&#125; 24. strncat函数 函数原型：char strncat(char dest, const char *src, size_t n); 函数作用：把src指向的前n个字符追加到dest的末尾，dest末尾的’\0’将会被覆盖掉，所以，自己要给添加上去。 12345678910111213141516171819202122//demo 1 strncat函数简单的使用char a[20] = &quot;abcde fghij&quot;;char b[20] = &quot;ABCDE&quot;;strcat(a,b,2);printf(&quot;%s\n&quot;,a);运行结果：abcde fghijAB//demo 2 strncat函数的简单实现char *_strncat(char *dest,const char *src,int cnt)&#123; int i; char *pReturn = dest; if(dest==NULL || src==NULL || cnt&lt;0) return 0; while(*dest != &apos;\0&apos;) dest++; for(i=0;i&lt;cnt;i++) &#123; *dest++ = *src++; &#125; *dest = &apos;\0&apos;; return pReturn;&#125; 25. strcmp函数 函数原型：int strcmp(const char s1, const char s2); 函数作用：比较两个字符串s1、s2,当s1&gt;s2时，返回1；当s1&lt;s2时，返回-1；当s1=s2时返回0 。以遇到的第一个字符判断条件成立的为标准。 1234567891011121314151617181920212223//demo 1int _strcmp(const char *s1,const char *s2)&#123; int ret; while(!(ret=*s1-*s2) &amp;&amp; *s2!=&apos;\0&apos;) &#123; s1++; s2++; &#125; if(ret&gt;0) return 1; else if(ret&lt;0) return -1; else return 0;&#125;main:int ret;char a[20] = &quot;abcde fghij&quot;;char b[20] = &quot;abcde fghik&quot;;ret = _strcmp(a,b);printf(&quot;%d\n&quot;,ret);运行结果：-1 26. strncmp函数 函数原型：int strncmp(const char s1, const char s2, size_t n); 函数作用：比较s1与s2字符串的大小，比较的个数为n个。 1234567891011121314151617181920212223242526//demo 1int _strncmp(const char *s1,const char *s2,int cnt)&#123; int i,ret; for(i=0;i&lt;cnt;i++) &#123; while(!(ret=*s1-*s2) &amp;&amp; *s2!=&apos;\0&apos;) &#123; s1++; s2++; &#125; if(ret&gt;0) return 1; else if(ret&lt;0) return -1; else return 0; &#125;&#125;main:int ret;char a[20] = &quot;abcde fghij&quot;;char b[20] = &quot;azcde fghij&quot;;ret = _strncmp(a,b,2);printf(&quot;%d\n&quot;,ret);运行结果：-1 27. strdup函数 函数原型：char strdup(const char s); 函数功能：将字符串拷贝到新建的位置处 12345678910111213141516171819202122//demo 1 strdup函数的简单使用char *p = &quot;Hello world&quot;;char *q;q = strdup(p);printf(&quot;%s\n&quot;,q);运行结果：Hello world//demo 2 strdup函数的简单实现char *_strdup(const char *s)&#123; if(s==NULL) return 0; char *pReturn =(char *)malloc(strlen(s)+1); strcpy(s,pReturn); return pReturn;&#125;main:char *p = &quot;Hello world&quot;;char *q;q = _strdup(p);printf(&quot;%s\n&quot;,q);运行结果：Hello world 28. strndup函数 函数原型：char strndup(const char s, size_t n); 函数作用：将字符串s的前n字节拷贝到新的位置 123456789101112131415161718192021//demo 1 strndup函数的简单使用char *p = &quot;Hello world&quot;;char *q;q = strndup(p,5);printf(&quot;%s\n&quot;,q);运行结果：Hello//demo 2 strndup函数的简单实现char *_strndup(const char *s,int cnt)&#123; if(s==NULL || cnt&lt;0) return 0; char *pReturn = (char *)malloc(cnt+1); strncpy(pReturn,s,cnt); return pReturn;&#125;main:char *p = &quot;Hello world&quot;;char *q;q = strndup(p,5);printf(&quot;%s\n&quot;,q);运行结果：Hello 29. strchr函数 函数原型：char strchr(const char s, int c); 函数作用：查找字符串s中首次出现c的位置，并且返回给位置处的指针，假如找不到则返回NULL。 1234567891011121314151617181920//demo 1 strchr函数的简单使用char *p = &quot;Hello world&quot;;char *q;q = strchr(p,&apos;w&apos;);printf(&quot;%c\n&quot;,q);运行结果：world//demo 2 strchr函数的简单实现char *_strchr(const char *s,int c)&#123; if(s==NULL || c&lt;0) return 0; char *pReturn = s; while(!(*pReturn == c) &amp;&amp; *pReturn!=&apos;\0&apos;) &#123; pReturn++; if(*pReturn == c) break; &#125; return pReturn?pReturn:NULL;//pReturn为真则返回pReturn，若为假则返回NULL&#125; 30. strstr函数 函数原型：char strstr(const char str1, const char *str2); 函数作用：字符串str2是否是str1的子串，若是，则该函数返回str2在str1中首次出现的地址，若不是则返回NULL。 1234567891011121314151617181920212223242526272829303132333435//demo 1 strstr函数简单的使用char *p = &quot;Hello world&quot;;char *q = &quot;wo&quot;;char *r;r = strstr(p,q);printf(&quot;%s\n&quot;,r);运行结果：world//demo 2 strstr函数的简单实现char *_strstr(const char str1,const char *str2)&#123; if(str1==NULL || str2==NULL) return 0; while(*str1 != &apos;\0&apos;) &#123; char *p = str1; char *q = str2; char *pReturn = NULL; if(*p==*q) &#123; pReturn = p; while(*p&amp;&amp;*q&amp;&amp;*p==*q) &#123; p++; q++; &#125; if(*q == &apos;\0&apos;) return pReturn; &#125; str1++; &#125;&#125;总结：这个函数的实现还是有一些难度的。一开始书写时我犯的2个错误。第一个，将p,q,pReturn这3个指针变量的声明放在了while(*str1!=&apos;\0&apos;)的外面，导致编译、运行时报段错误。原因，p所指向的字符串内容是会随着str++的变化而变化的，是不断在更新值的，假如我们把它放到了while循环的外面，它所指向的从一开始就一直的不变，一直是str1字符串中第一个字符。第二个，while(*p&amp;&amp;*q&amp;&amp;*p++==*q++),这样书写是不可以的，++自增运算符要写在括号里面。原因，假设*p和*q都成立，而*p==*q不成立时，自增运算符不放在括号时，它仍旧会进行+1操作，这就不是我们所想要的结果了。总结，像这种库函数是非常的多的，至此先到这里了，花了将近一个星期总结这10多个库函数。 31. 数学库函数 12345678910111213141516171819202122232425262728//demo 1#include &lt;stdio.h&gt;int main()&#123; int a = 9; a = sqrt(a);//这里括号里面要是写&quot;9&quot;,则不会报链接时错误的。 printf(&quot;a = %d\n&quot;,a); return 0;&#125;运行结果：gcc a.c a.c: In function ‘main’:a.c:10:6: warning: incompatible implicit declaration of built-in function ‘sqrt’ [enabled by default] a = sqrt(a); ^/tmp/ccPhSlhz.o: In function `main&apos;:a.c:(.text+0x19): undefined reference to `sqrt&apos;collect2: error: ld returned 1 exit status从运行结果看，前面的4行表示&quot;函数未声明&quot;，属于编译时错误。加#include &lt;math.h&gt;即可。后面的3行，&quot;.text+0x19&quot;属于链接时错误。加gcc a.c -lm即可。这个链接错误表示的是，函数有声明(math.h)、有引用(a.c)，但是没有定义，链接器(ld)找不到函数体。1. 为什么说链接器(ld)会找不到函数体呢？答：首先要明确的一点是：链接器(ld)的作用是，到库函数中去搜索到我们所需要的函数。由于库函数的数量实在是太大了，所以链接器(ld)通常的做法是，它会默认的去那几个比较常用的库中去寻找。假如说，我们所需要的函数，它正好不在那几个比较常用的库中，那么需要我们程序员自己特意的指出来(gcc a.c -lm)。我们这里使用的是数学库，所以用的是&quot;-lm&quot;。假如说使用的是其他的库，那就需要加另外的符号。2. 使用ldd a.out可以来查看，可执行程序a.out到底使用到了那一些库。就本例子而言：ldd a.out打印内容： linux-gate.so.1 =&gt; (0xb773b000) libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7575000) /lib/ld-linux.so.2 (0xb773c000) 32. 静态链接库的创建并且使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647(一)静态链接库的创建分3步骤：第一步，新建一个sLib.c和sLib.h文件sLib.c:#include &lt;stdio.h&gt;void func1()&#123; printf(&quot;void func1()\n&quot;);&#125;int func2(int a,int b)&#123; printf(&quot;int func2(int a,int b)\n&quot;); return (a+b);&#125;sLib.h:void func1();int func2(int a,int b);第二步，gcc sLib.c -o sLib.o -c(-o指定目标文件，-c只编译、不链接)，生成sLib.o第三步，ar -rc libsLib.a sLib.o(libsLib.a中lib只固定的，后面sLib.a是静态链接库名)ar和gcc差不多都只是一个工具，ar是用来生成静态链接库的。(二)使用刚刚创建的静态链接库第一步，新建一个main.c，然后将libsLib.a和sLib.h这2个文件和main.c放在同一目录下main.c:#include &quot;sLib.h&quot;#include &lt;stdio.h&gt;int main()&#123; int a = 0; func1(); a = func2(5,5); printf(&quot;a = %d\n&quot;,a); return 0;&#125;第一次编译：gcc main.c错误信息：/tmp/cc0SMkCk.o: In function `main&apos;:main.c:(.text+0xa): undefined reference to `func1&apos;main.c:(.text+0x1e): undefined reference to `func2&apos;collect2: error: ld returned 1 exit status分析，由&quot;.text&quot;可知该错误属于链接时错误。那是因为func1()和func2()函数是在sLib.a这个库中的，而sLib.a这个库并不是链接器默认寻找的库。故，需要给指出链接器需要寻找的库名。第二次编译：gcc main.c -lsLib(-l命令指定库名。需要注意这里是-lsLib而不是-lsLib.a噢)错误信息：/usr/bin/ld: cannot find -lsLibcollect2: error: ld returned 1 exit status分析，&quot;cannot find -lsLib&quot;说明，链接器去找了，但是没找着。我们需要给它明确的路径，才可以确保链接器可以找得到对应的库。第三次编译：gcc main.c -lsLib -L.(-L命令指定库的位置。由于我们的sLib.a和main.c在同一目录下，故使用&quot;-L.&quot;)。最终编译通过，没有任何警告信息。最后，&quot;./a.out&quot;void func1()int func2(int a,int b)a = 10 最后，再安利一个很好用的命令mn,用来查看该静态链接库文件一共包含了几个目标文件，以及每一个目标文件有那一些函数。 1234567mn libsLib.a (前面的lib是固定不变的，后面的sLib.a是静态链接库名)显示结果：sLib.o:00000000 T func100000014 T func2 U puts值得注意的是，这里面细节还是蛮多的，这里是&quot;sLib.a&quot;而上面的一处是&quot;sLib&quot;，细节很多。 33. 动态链接库的创建并且使用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556(一)动态链接库的创建第一步，新建一个dLib.c和dLib.h文件dLib.c:#include &lt;stdio.h&gt;void func1()&#123; printf(&quot;void func1()\n&quot;);&#125;int func2(int a,int b)&#123; printf(&quot;int func2(int a,int b)\n&quot;); return (a+b);&#125;dLib.h:void func1();int func2(int a,int b);第二步，gcc dLib.c -o dLib.o -c -fPIC(生成目标文件dLib.o,-c只编译不链接，fPIC位置无关码)第三步，gcc -o libdLib.so dLib.o -shared(libdLib.so中&quot;lib&quot;是固定的，后面一部分是动态链接库名字)，至此，动态链接库已经制作成功。(二)动态链接库的使用第一步，新建一个main.c，把libdLib.so和dLib.h这2个文件放在与main函数同一个目录下。main.c:#include &quot;dLib.h&quot;#include &lt;stdio.h&gt;int main()&#123; int a = 0; func1(); a = func2(5,5); printf(&quot;a = %d\n&quot;,a); return 0;&#125;第二步，gcc main.c /tmp/ccknLm4r.o: In function `main&apos;:main.c:(.text+0x12): undefined reference to `func1&apos;main.c:(.text+0x26): undefined reference to `func2&apos;collect2: error: ld returned 1 exit status第三步，gcc main.c -ldLib(-l指定动态链接库名，注意这里不是dLib.so哦，而是dLib)/usr/bin/ld: cannot find -llibdLibcollect2: error: ld returned 1 exit status第四步，gcc main.c -ldLib -L.(-L指定动态链接库位置)，至此编译没有问题。第五步，但是./a.out时，出现错误。原因，该程序使用的是动态链接，链接器在使用库时(它不再默认的库存放的目录下面)，是找不到库在那里存放的。因此，需要指定库的位置。2种方法：1. 在默认路径/usr/lib，中添加一个libdLib.so文件。即cp libdLib.so /usr/lib，再次执行即可。2. 使用LD_LIBRARY_PATH指定目录。因为操作系统在加载/usr/lib目录之前，会先到环境变量LD_LIBRARY_PATH该路径下面去寻找，该路径下找不着时，才会到/usr/lib目录下寻找。具体步骤：&lt;1&gt;使用pwd命令，查找出libdLib.so的目录，譬如叫做list&lt;2&gt;export LD_LIBRARY_PATH=list,即可。需要注意的是，&quot;=&quot;的两边是不可以有空格的哦。最后，ldd命令可以帮助我们在不需要&quot;./a.out&quot;来预先得知该可执行程序是否出现问题。具体使用方法：ldd a.out(export LD_LIBRARY_PATH=)，即环境变量置空。linux-gate.so.1 =&gt; (0xb76e5000)libdLib.so =&gt; not foundlibc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb751f000)/lib/ld-linux.so.2 (0xb76e6000)上面的&quot;libdLib.so=&gt;not found&quot;表示这里出了问题——找不到libdLib.so库文件。 34. 深入理解结构体 由于关于结构体的代码量有点大，所以代码是边参考、边码字的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//demo 1 接下来2个代码属于自己可以看得懂写不出来的代码，没事多温习、温习#include &lt;stdio.h&gt;struct Company&#123; int num; char name[20]; float score[30]; float aver;&#125;;void input(struct Company st[]);struct Company max(struct Company st[]);void print(struct Company st);int main()&#123; struct Company st[3]; struct Company *p = st; input(p); print(max(p)); return 0;&#125;void input(struct Company st[])&#123; int i; printf(&quot;请依次输入学号、姓名、3科成绩:\n&quot;); for(i=0;i&lt;3;i++) &#123; scanf(&quot;%d %s %f %f %f&quot;,&amp;st[i].num,(char *)&amp;st[i].name,&amp;st[i].score[0],&amp;st[i].score[1],&amp;st[i].score[2]); st[i].aver=(st[i].score[0]+st[i].score[1]+st[i].score[2])/3.0; &#125;&#125;struct Company max(struct Company st[])&#123; int i,m=0; for(i=1;i&lt;3;i++) &#123; if(st[i].aver&gt;st[m].aver) m=i; &#125; return st[m];&#125;void print(struct Company st)&#123; printf(&quot;成绩最高的同学成绩如下:\n&quot;); printf(&quot;学号:%d\n姓名:%s\n3科成绩:%5.1f,%5.1f,%5.1f\n平均成绩:%5.1f\n&quot;, st.num,st.name,st.score[0],st.score[1],st.score[2],st.aver);&#125;运行结果：请依次输入学号、姓名、3科成绩:1 a 12 12 122 b 45 45 453 c 80 80 80成绩最高的同学成绩如下:学号:3姓名:c3科成绩: 80.0, 80.0, 80.0平均成绩: 80.0总结：尽管是边参考代码边自己敲，但是中间还是遇到了不少的问题的。第一，input函数中scanf(&quot;%d %s %f %f %f&quot;),这其中也是很有讲究的，%d与%f之间是不可以加&quot;,&quot;间隔的，以实现连续输入；而且一开始把后面的&quot;%f&quot;写成了&quot;%d&quot;导致程序运行的结果是错误的。其二，末尾出是不可以加&quot;\n&quot;的，暂且不明白为什么，经过实践可得，加了&apos;\n&apos;之后运行结果是会出现问题的。第二，注意结构体数组在引用成员时，下标的书写。 深入理解结构体2 同样的由于代码量还是偏大的，所以一边看着一边敲一边。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122//demo 2#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct Company&#123; int num; //工号 char *tel; //电话 int *score; //积分&#125;;struct Social&#123; int id; //身份证号 char name[10]; //姓名 int *age; //年龄 struct Company st; struct Company *pSt; int (*fpAdd)(int a,int b); int (*fpSub)(int a,int b); int (*fpMult)(int a,int b);&#125;;int add(int a,int b)&#123; return (a+b);&#125;int sub(int a,int b)&#123; return (a-b);&#125;int mult(int a,int b)&#123; return (a*b);&#125;void usage(char *p)&#123; printf(&quot;%s &lt;para1&gt; &lt;para2&gt;\n&quot;,p);&#125;int cnt=2018,cnt1;struct Company zhang = &#123; .num = 2017, .tel = &quot;110&quot;, .score = &amp;cnt,&#125;;struct Company wang = &#123; .num = 2018, .tel = &quot;119&quot;, .score = &amp;cnt1,&#125;;int main(int argc,char **argv)&#123; int a,b; struct Social boss[] = &#123; &#123; .id = 411302199, .name = &quot;小张&quot;, .age = &amp;b, .st = &#123; .num = 111, .tel = &quot;110&quot;, .score = &quot;666&quot;, &#125;, .pSt = &amp;zhang, .fpSub = sub, .fpMult = mult, &#125;, &#123; .id = 411302199, .name = &quot;小王&quot;, .age = &amp;a, .st = &#123; .num = 222, .tel = &quot;119&quot;, .score = &quot;999&quot;, &#125;, .pSt = &amp;wang, .fpAdd = add, &#125;, &#125;; if(argc != 3) &#123; usage(argv[0]); return -1; &#125; a = strtoul(argv[1],NULL,0); b = strtoul(argv[2],NULL,0); printf(&quot;a=%d\tb=%d\n&quot;,a,b); printf(&quot;boss[0].id=%d\tboss[1].id=%d\n&quot;,boss[0].id,boss[1].id); printf(&quot;boss[0].name=%s\tboss[1].id=%s\n&quot;,boss[0].name,boss[1].name); printf(&quot;boss[0].age=%d\tboss[1].age=%d\n&quot;,*(boss[0].age),*(boss[1].age)); printf(&quot;boss[0].st.num=%d\n&quot;,boss[0].st.num); printf(&quot;boss[0].st.tel=%s\n&quot;,boss[0].st.tel); printf(&quot;boss[0].st.score=%d\n&quot;,*(boss[0].st.score)); printf(&quot;boss[0].pSt-&gt;num=%d\n&quot;,boss[0].pSt-&gt;num); printf(&quot;boss[0].pSt-&gt;tel=%s\n&quot;,boss[0].pSt-&gt;tel); printf(&quot;boss[0].pSt-&gt;score=%d\n&quot;,*(boss[0].pSt-&gt;score)); printf(&quot;a-b=%d\n&quot;,boss[0].fpSub(a,b)); printf(&quot;a*b=%d\n&quot;,boss[0].fpMult(a,b)); printf(&quot;a+b=%d\n&quot;,boss[1].fpAdd(a,b)); return 0;&#125;运行结果：a=10 b=5boss[0].id=411302199 boss[1].id=411302199boss[0].name=小张 boss[1].id=小王boss[0].age=5 boss[1].age=10boss[0].st.num=111boss[0].st.tel=110boss[0].st.score=3552822boss[0].pSt-&gt;num=2017boss[0].pSt-&gt;tel=110boss[0].pSt-&gt;score=2018a-b=5a*b=50a+b=15总结：第一，结构体变量定义时使用&quot;;&quot;而结构体变量初始化时使用的是&quot;,&quot;第二，结构体成员中有结构体变量、结构体变量指针时，对结构体成员的引用第三，里面涉及了字符串处理函数strtoul()函数，而strtoul()函数的理解，又涉及到二重指针的充分理解，所以接下里会对2着依次做探究。 35. strtoul函数——string to unsigned long 函数原型：unsigned long int strtoul(const char *str, char **endstr, int base); 函数作用：str要转化的字符串；endstr第一个不能转换的字符的指针；base为str采用的进制。将str按照base进制方式，将字符串str转化为long int型。 使用说明：strtol函数当检测到第一个非法字符时立即停止检测，其后的所有字符都会被当做是非法字符来处理。合法的字符串会被转化成为long int，作为函数的返回值。非法字符串，即第一个非法字符的地址被赋给*endstr(隐含意思：对指针endstr进行了更改操作)，故采用了二重指针传参的手法。 多数情况下，endstr设置为NULL，即不返回非法字符串的地址。文字讲的比较抽象，具体看代码实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//demo 1 strtol函数简单使用char buffer[20]=&quot;10379cend$3&quot;;char *stop;printf(&quot;%d\n&quot;,strtol(buffer, &amp;stop, 2));//2-&gt;8-&gt;10-&gt;16运行结果如下printf(&quot;%s\n&quot;, stop);运行结果： 2 8 10 16(0-f为合法) 2 543 10379 17005006(字符串中的数字以不同进制的解析，得到十进制数) 379cend$3 9cend$3 cend$3 nd$3注意：当base=0，&lt;1&gt;默认以10进制进行转化；&lt;2&gt;字符串是以0x开头,按16进制&lt;3&gt;以0开头按8进制//demo 2 strtol函数简单实现#define TOLOWER(x) (x|(0x20))unsigned int _base(const char *pStr)&#123; if(pStr[0]==&apos;0&apos;) &#123; if(TOLOWER(pStr[1])==&apos;x&apos;&amp;&amp;isxdigit(pStr[2])) return 16; else return 8; &#125; else return 10;&#125;unsigned long _strtoul(const char *str,char **endStr,int base)&#123; unsigned int result = 0; if(!base) base = _base(str); if(base==16 &amp;&amp; str[0]==&apos;0&apos; &amp;&amp; TOLOWER(str[1])==&apos;x&apos;) str+=2; while(isxdigit(*str)) &#123; unsigned int value = 0; value = isdigit(*str)?*str-&apos;0&apos;:TOLOWER(*str)-&apos;a&apos;+10; result = result*base + value; if(value&gt;=base) break; str++; &#125; if(endStr) *endStr=(char *)str; return result;&#125;main:unsigned int value = 0;char *p = &quot;0xf&quot;;value = _strtoul(p,NULL,0);printf(&quot;value=%d\n&quot;,value);运行结果：value=15总结：&lt;1&gt;x=x|0x20,这是一种常见的手法，通过加32(0x20)，让大写字母变成为小写字母。&lt;2&gt;&quot;isdigit(*str)?*str-&apos;0&apos;:TOLOWER(*str)-&apos;a&apos;+10&quot;，0-9则，执行前半部分；a-f则，执行后半部分。&lt;3&gt;&quot;result=result*base+value&quot;是一种常见的按权相加计算的方法。&lt;4&gt;if(endStr) *endStr=(char *)str;这种手法的简介。&lt;5&gt;isdigit()与isxdigit()函数使用介绍。 36. 关于strtoul函数而延伸出的需要注意的点 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//demo 1 isxdigit()函数简介char *p = &quot;abcde&quot;;if(isxdigit(p[0])) printf(&quot;this is a amount of 0x\n&quot;);else printf(&quot;this is not a amount of 0x\n&quot;);运行结果：若&quot;abcde&quot;，则打印：&quot;this is a amount of 0x&quot;;若&quot;zbcde&quot;，则打印:&quot;this is not a amount 0f 0x&quot;作用：检查字符串中的某个字符是否是16进制，若是返回TRUE。否则返回FAULSE。//demo 2 if(二重指针)&#123;对一重指针赋值操作&#125;这种手法char *p = &quot;abcdefg&quot;;p = 0;*(p+0) = &apos;A&apos;;printf(&quot;%c\n&quot;,*(p+0));运行结果：Segmentation fault (core dumped)char a = &apos;A&apos;;char *p = &quot;abcdefg&quot;;p = &amp;a;*(p+0) = &apos;A&apos;;printf(&quot;%c\n&quot;,*(p+0);运行结果：A总结以上两组代码：第一组代码指针p=0时，p所指向的内容是不可以更改的；而p!=0时，p所指向的内容是可以更改的。//demo 3 对二重指针进一步加深理解&lt;1&gt;一级指针void func(int *p)&#123; int a=5; *p=5;&#125;main:int a = 1;printf(&quot;before:a = %d\n&quot;,a);func(&amp;a);printf(&quot;after:a = %d\n&quot;,a);运行结果：before:a = 1after:a = 5总结：传参数是一级指针，可以更改p所指向的内存单元中的内容。&lt;2&gt;二级指针void func(int **p)&#123; int a = 15; *p = &amp;a;&#125;main:int a = 5;int *pa = &amp;a;printf(&quot;before:*pa = %d\n&quot;,*pa);func(&amp;pa);printf(&quot;after:*pa = %d\n&quot;,*pa);运行结果：before:*pa = 5after:*pa = 15总结：传参数二级指针，可以更改指针的指向(p之前指向&quot;a=5&quot;,而后指向&quot;a=15&quot;)，也就是更改了p本身的值。&lt;3&gt;实现一个函数，在数组arr中查找c，若找到则使用pa返回arr中第一个找到c的地址,否则返回NULL。void func1(char arr[],char c,char **pa)&#123; int i = 0; for(i=0;arr[i]!=&apos;\0&apos;;i++) &#123; if(arr[i]==c) &#123; *pa=&amp;arr[i]; printf(&quot;&amp;arr[%d]=%p\n&quot;,i,&amp;arr[i]); break; &#125; else if(arr[i]==&apos;\0&apos;) &#123; *pa=NULL; break; &#125; &#125;&#125;main:char arr[]=&quot;abcdefg&quot;;char a = &apos;d&apos;;char *p = NULL;func1(arr,a,&amp;p);if(p!=NULL)&#123; printf(&quot;查找到了，%c\n&quot;,*p); printf(&quot;p=%p\n&quot;,p);&#125;else printf(&quot;没有查找到！\n&quot;);运行结果：&amp;arr[3]=0xbff91c37查找到了，dp=0xbff91c37 37. 关于typedef结合const之后的使用情况 12345678910111213//demo 1typedef char * pChar;main:const pChar p = &quot;abcdefg&quot;;p = p+1;运行结果：error: assignment of read-only variable ‘p’p = p+1;总结：而把&quot;typedef char* pChar&quot;换成为&quot;#define pChar char *&quot;，则是正确的。解析：现象一：const int a,此时a是不可以改变的；现象二：const int *p,此时不可改变的是&quot;把类型去掉以后的那一坨东西&quot;，这里指的是&quot;*p&quot;，即p所指向的内容是不可以改变的。以此类推，const pChar p,pChar是一个类型，因此是可以把pChar去掉的，即const p，即p是不可以改变的，故，p=p+1时，就会报错。 38. atoi函数 函数原型：int atoi(const char *nptr); 函数作用：将字符串转化成整数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//demo 1 atoi函数简单使用int a = 0;char *p = &quot;1234&quot;;a = atoi(p);printf(&quot;a = %d\n&quot;,a);运行结果：a = 1234//demo 2 atoi函数简单实现int _atoi(const char *str)&#123; int result=0; int flags=0; if(*str == &apos; &apos;) str++; if(*str==&apos;+&apos;||*str==&apos;-&apos;) &#123; if(*str==&apos;-&apos;) flags = 1; str++; &#125; while(*str&gt;&apos;0&apos;&amp;&amp;*str&lt;&apos;9&apos;) &#123; result = result*10+*str-&apos;0&apos;; if(result&lt;0) &#123; printf(&quot;this amount is too large\n&quot;); return -1; &#125; str++; &#125; return result*(flags?-1:1);&#125;运行结果：a = 1234,同上。分析：为什么&quot;if(result&lt;0)&quot;这一条件会写在程序中呢？我本能的以为，这种情况是不可能发生的。但是，经过一番研究以后，发现当result值大到一定程度时，是会成立的。&lt;1&gt;char型正数范围(0-127)范围之内：char a = (127-1);printf(&quot;a = %d\n&quot;,a);printf(&quot;a = %u\n&quot;,a);运行结果：a = 126a = 126超过范围：char a = (127+1);//7f=127=0111 1111printf(&quot;a = %d\n&quot;,a);//a = -128 = 1000 0000printf(&quot;a = %u\n&quot;,a);运行结果：a = -128 a = 4294967168分析：a=4294967168=FFFFFF80=80加上前面补FFFFFF，充分说明&quot;%u&quot;打印是是按照32bit来进行的。&lt;2&gt;int型正数范围(0-2147483647)范围之内：int a = (2147483647-1);//4字节——可以表示正数范围7FFF FFFF(0-2147483647)printf(&quot;a = %d\n&quot;,a);printf(&quot;a = %u\n&quot;,a);运行结果：a=2147483646a=2147483646超过范围：int a = (2147483647+1);//4字节——可以表示正数范围7FFF FFFF(0-2147483647)printf(&quot;a = %d\n&quot;,a);printf(&quot;a = %u\n&quot;,a);运行结果：a = -2147483648a = 2147483648总结：定义某一个类型的数(int、char..)，当这个数的值在该类型的正数范围之内时，打印出的有符号数和无符号数的结果是一模一样的；当这个数的值超出了该类型所可以表示的正数的范围时，因为，它已经超出了该类型所可以表达的最大的正数了，所以它只好以负数的解析方式去对它进行解析。总之一句话，内存里面放的这一堆二进制数字，在默认的情况下是以无符号数来进行解析的。但是当以无符号数的解析方式盛不下该数字时，此时那就只好按照有符号数的解析方式进行解析。给我们造成的一种视觉上的现象是：明明我刚开始时，是以一个整数作为基础，在整数的基础之上不断地给它累加、累加，累加到一定程度时它的值竟然变成了负数了。 39. 存储类、作用域、生命周期、链接属性 存储类，指的是存储类型的意思，描述的是C语言的变量存储的什么地方。 存储类一般包括数据段、代码段、bss段、堆、栈，一共5个部分。那么这5个段又是怎么引出来的呢？ a. 一个可执行程序在存储时，包含3部分：代码段、数据段、bss段。即可执行程序(存储时) = 代码段+数据段+bss段。 b. 当可执行程序被加载到内存单元时，则需要另外的2个段，堆、栈。即可执行程序(正在运行) = 代码段+数据段+bss段+堆+栈。 总结：进程(正在运行的可执行程序)会占用一定的内存空间，每一个进程对应到内存空间中大致上可以分为5个段。 以上的5个段又是可以分为2类，静态存储区、动态存储区。 静态存储区：包括常量、全局变量、静态变量(静态全局变量、静态局部变量) 动态存储区：堆和栈。堆内存一般使用malloc申请完以后，使用free手工释放掉。栈，存放函数的返回地址，函数形参、以及局部变量。 有了这2种类型的分区以后，自然地衍生出2种存储方式，静态存储方式与动态存储方式。 静态存储方式，指的是这一些变量在程序的编译阶段就已经分配好了内存空间的，生命周期一直延续到整个程序的结束为止。 动态存储方式，指的是这一些变量在程序的运行阶段，根据需要进行动态的分配内存空间的，使用完该内存空间以后立即释放掉。 那么思考一下全局变量存放在什么位置？而局部变量又存放在什么位置呢？ 答：全局变量分为2种，一种初始化为非0的全局变量分配在数据段上；另一种显式初始化为0的全局变量或者未初始化的全局变量分配在栈上。一般情况下，也就是没有加任何的修饰符的局部变量是存放在栈上的；而加了static修饰的局部变量存放在数据段或者bss段，当初始化为非0的static局部变量时，存放在数据段中。而未初始化的static局部变量和初始化为0的static局部变量存放在bss段中。 作用域 作用域指的是某一个变量起作用的范围。C语言变量的作用域规则是代码块作用域，代码块也就是一对{}括起来所囊括的范围。 局部变量的作用域： 局部变量的作用域为代码块作用域。 函数名和全局变量的作用域为文件作用域： 即，在整个.c文件中都是可以对全局变量和函数名进行访问的。 关于同名变量的掩蔽规则。 1234567891011//demo 1main:int a;int a;运行结果：error: redeclaration of ‘a’ with no linkage//demo 2int a = 5;main:int a = 10;运行结果：此时没有警告、没有错误。全局变量a和局部变量a尽管说变量名是相同的，但是由于作用域是不相同的，所以不会报错。此时，起作用的变量类似于&quot;县官不如现管&quot;的味道。 生命周期 指的是这个变量从什么时间诞生的、什么时间消亡，这个从诞生到消亡的这一个时间段。 诞生的意思是说，从给该变量分配内存空间开始；消亡的意思是，回收该变量的内存空间，也是说这个内存空间与该变量已经没有任何的关系了。 研究变量存储在不同的存储类时，所对应的生命周期。 代码段： 代码段里面放的，其实就是程序执行的代码，即一个个的函数。它的生命周期是永久的，一般来说代码段的生命周期是不需要我们来关注的。 数据段、bss段： 存放在该段的全局变量的生命周期是永久的，即在程序中执行时诞生，在程序终止时消亡。所以，当一个程序中有大量的全局变量时，就会导致这个程序一直占用大量的内存。 栈： 里面的变量，生命周期是临时的。譬如，在一个函数中所定义的局部变量，函数在每一次调用时，该局部变量都会被创建一次，然后使用，当函数返回时消亡。 堆： 堆内存里面的变量的生命周期是有程序员手动的支配的。从malloc申请时开始诞生，然后使用，直到free时消亡。但我们需要一大块临时的内存时，最好使用malloc申请一段堆内存空间。 链接属性 大家都知道源程序(.c)到最终的可执行程序(.elf)，经历了编译、链接过程。 编译阶段就是把源程序(.c)变成目标文件(.o),目标文件中包含了很多符号、代码段、数据段、bss段等。符号就是程序中的变量名、函数名。那么目标文件中的这一些符号起什么作用？ 答：程序在运行时，变量名和函数名能够和对应的段联系起来，就是依靠的这一些符号。 链接，指的是把目标文件(.obj)和库文件(也就是一堆的.obj文件)，组合到一块的过程。 首先要声明的一点是我们平时所说的链接属性指的是符号的链接属性。 1. 链接属性分为3类： a. 外链接(external) b. 内部链接(internal) c. 无链接(none) 2. 3种链接方式的定义、以及各自的影响。 外链接，指多个源文件中相同的标识符指向同一个实体。导致结果，拥有external链接属性的符号是可以被其他的所有的文件所访问的，但前提是使用extern关键字进行声明。 内链接，指同一个源文件中相同的标识符指向同一个实体。结果导致，拥有internal链接属性的符号，只可以在其定义的文件中才可以被访问，也就是变成了当前源文件的私有符号。 无链接，该标识符当做单独的实体，只有在代码块内部出现，每一次出现都是不同的独立的实体。导致的结果，拥有无链接属性的符号它的可访问区间为：从其定义出开始到该代码块作用域结束为止。 3. 那么怎么样让一个符号具有外部链接、内部链接、无链接的这一些属性呢？ 第一，默认情况下全局变量和函数的声明都是具有外部链接属性的。extern关键字可以把一个符号的链接属性设置为外部链接。 第二，static关键字可以把一个符号的链接属性设为内部链接。 第三，函数内部的代码块以及函数的形参都默认是none属性的。 总结、注意： 第一点，static关键字修饰的对象，该对象原本的属性类型原本应该是external类型的变量(也可以认为是全局变量)，而对于链接属性为内链接型的变量是不起作用的。 第二点，extern关键字修饰的对象，前提是该对象之前是没有被其他的关键字所修饰过的，此时extern关键字才起作用的。假如说，该变量之前已经被static关键字修饰过了，当使用extern再一次修饰该变量时，是不起任何作用的，仍旧保持原来的属性不变的。 和链接属性相关的延伸： 宏定义和inline的链接属性都是无链接的。 inline函数与宏定义是非常类似的。 a. inline 函数代码是存放在符号表中的，在编译阶段展开；而宏定义是在预处理阶段展开。 b. 内联函数是有做类型检查、语法判断的；而宏定义没有这些。 40. C语言程序的内存映像 组成部分：内核虚拟存储器、代码段、数据段、bss段、栈、堆……. 内核虚拟存储器——将操作系统的内核程序映射到这个区域。 对于Linux中的每一个进程而言，它都以为整个操作系统中只有自己和内核，认为其他的进程是不存在的。 关于虚拟地址的一些概念，迷糊但是还是先记录下来。2018-6-4 a. 每一个进程都有自己独立的进程空间(0G-3G)，对进程的访问是虚拟地址，而并非物理地址 b. 虚拟地址可以通过每一个进程的页表与物理地址进行映射，从而获取真正的物理地址。 c. 虚拟地址实际上是操作系统对内存管理的一种方式。可能进程A的虚拟地址对应了物理地址0x10，而进程B的虚拟地址对应了物理地址0x20，虚拟地址提供了一种有效的进程间隔离的方式，这就导致了任何一个进程它不管在做一些什么，都是在自己的地址空间做的，是不会影响到其他的进程的。 d. CPU采用虚拟地址到物理地址的映射技术的目的？答：对于每一进程而言，它们每一个进程都以为自己独占了4G的内存空间(3G用户进程使用的，对应代码段、数据段、bss段….)；1G内核(Kernel)所有的进程是可以共享使用的)。操作系统会自动的为不同的进程分配合适的、不同的物理内存空间。 Linux内核的5大组成部分： 内存管理、进程管理、进程间通信、虚拟文件系统、网路接口。 41. 和存储类相关的关键字介绍。 auto auto关键字在C语言中只有一哥作用：修饰局部变量。我们平时所写的局部变量，其实都是auto类型的，只不过平时我们把auto这个关键字给省略掉了。 static C语言中static关键字有2种截然不同的用法。 用法1： 用来修饰局部变量。那么局部变量就自然地分为2类，一类是没有static修饰的局部变量；另一类就是有static修饰的局部变量。 无static修饰的局部变量，它的存储类属于栈。而static修饰的局部变量的存储类为数据段或bss段。当初始化为非0时，分配到数据段；当初始化为0时，分配到bss段。 总结：static修饰局部变量时，改变的是变量的存储类。 用法2： 用来修饰全局变量。那么全局变量也就和自然的可以分为带static修饰的全局变量、和不带static修饰的全局变量。这2中不同的全局变量的主要区别在于，它们的链接属性发生了改变。没有static修饰的函数和全局变量，默认的链接属性为外链接的；使用static修饰的函数和全局变量的链接属性变成了内链接。 总结：static修饰的函数和全局变量，改变的是它们的链接属性。 register 作用：使用register关键字来修饰的变量，编译器会尽量的保证把该类型的变量分配到寄存器中。而我们平时定义的那一些变量都是分配在内存中的。 我们都知道计算机CPU对数据的处理速度，寄存器&gt;内存。使用register关键字，那么数据直接分配到寄存器中，那么相应的读写速度、效率就会提高很多的。 注意：我们这里使用register定义的变量，编译器只是尽量的保证将register修饰的变量存放于寄存器中，主要的原因是，寄存器的数量是非常的有限的。 extern 作用：声明全局变量。声明的主要目的是，假设一个全局变量g_a在a.c中定义了，可b.c中是没有定义g_a这个变量的，可是b.c中又很想的使用该变量，此时就可以在b.c中使用extern关键字对g_a该变量进行声明，然后在b.c中就可以使用g_a了。 注意：使用extern声明全局变量时，是不可以进行初始化操作的，否则就会报错。 volatile 字面意思：直接从原始内存地址中读取。即告诉编译器不要做任何的优化操作，从而可以保证程序原来的本意。 123456789//demo 1int a,b,c;a = 3;b = a;c = a;总结，当编译器没有做优化时，对于2,3,4这3个语句，要对内存进行读取3次，写入3次；而有编译器优化时，对内存只需要读取一次，写入3次(即c = b = a)。这3条语句中并没有出现对a的值进行改变的语句，所以编译器在编译过程中会将a的值备份到一个寄存器中，之后的&quot;b=a&quot;,&quot;c=a&quot;语句在执行时，就不会再跑到内存中去读取数据了，而是直接的从寄存器中读取那一份备份得到的a的值。正常情况下，编译器这样做的话，会提升CPU对数据得访问效率，是很好的操作。但是，假如在执行完&quot;a=3&quot;这一条语句时，外部突然来了一个中断，在这个中断程序中对a的值进行了更改，那么，此时再按照编译器优化以后的&quot;c=b=a&quot;这样的操作的话，就会出问题了。我们程序原本的初衷是实现&quot;c=b=a&quot;这样的效果的，但是来了这么一个中断以后，b的值将不等于a，c的值也将不等于a了。而，我们还一直的以为&quot;c=b=a&quot;是正确的。 再次探讨关于volatile a. 在本次线程内，当读取一个变量时为了提高存取的速度，编译器会做一些优化——把变量读取到一个寄存器中，以后取变量时，直接去寄存器中取就OK了，不需要跑到内存中了。当变量的值在本线程被改变时，会同时把变量的新值copy到该寄存器中，以便保持一致。 当变量的值由于别的线程(外部的一个中断)而更改时，该寄存器中的值是不会发生改变的，从而造成了读取到的值和实际的值不一致的情况。 b. 使用volatile定义的变量，有可能在该程序之外被修改的，此时每一次读取变量时都必须要从该变量的内存地址处进行读取，而不可以反复的使用之前备份在cache或者寄存器中的那一份值。 volatile可能使用的场景： a. 并行设备的硬件寄存器(状态寄存器) b. 一个中断服务子程序会访问到的非自动变量 c. 多线程应用中被几个任务共享的变量 restrict 该关键字与volatile是有点意思的，volatile强调的是告诉编译器不要给我进行优化操作；而restrict关键字是为了使编译器可以更好的优化代码。 restrict关键字用来修饰指针，用来告诉编译器所有的试图修改该指针变量所指向的内存单元中的内容的操作，都必须是通过该指针进行操作的。 譬如说，int *restrict p;该指针p所指向的内存单元，该内存单元中的内容是只可以通过p来进行访问的，p是访问这一块内存空间的惟一的途径。 理论终究是理论知识，理论终究知识理论知识点，但我在编译器中试图使用另一个指针q访问p所指向的那一块内存空间时，实践表明是可以进行访问的。呵呵。 但是，注意一点，使用restrict关键字时，编译时使用”gcc a.c -std=c99”类似于这种，要在编译时添加-std=c99后缀，否则编译编译是通不过的。 42. 操作系统的概念： 引言，人类社会在最开始的时候，每个人都是需要干活的，是没有专职的管理者的(不干活、只是指挥其他人干活的)。而随着社会的进步，人口越来越多了，此时假如还是每个人都在忙头的干活的话，此时尽管说干活的人数非常的多，但是实际上他们相当于忙头苍蝇一般，效率是非常的低下的，此时假如找几个人，这几个人是专门来负责安排其他人如何如何的干活的，此时尽管说干活的人的确少了一些，但是从宏观上来看，整体的效率、以及工作量是非常的可观的。 a. 操作系统就非常的类似于这一种概念。操作系统这一部分代码本身并不是直接的产生价值的，而是为那一些直接劳动的(各种的应用程序)提供服务的。 b. 操作系统可以被认为是计算机所有的资源(cpu、内存…)的管理者。操作系统的这一部分代码是并不参与生产价值的，它主要是为那一些直接、真正产生价值、真正劳动的各种应用程序提供服务的。所以说，操作系统既是管理者、又是服务者。 c. 操作系统是为用户(使用计算机的人)提供服务的，使用户可以在计算机上使用各种各样的应用程序(QQ、浏览器)来操控计算机资源(QQ的显示需要显示器资源、浏览器下载资料时，同时需要硬盘、同时这一些应用程序都在共同使用着CPU资源)。 d. 操作系统是处于应用程序和计算机硬件资源(CPU、内存、IO设备)的中间层。 那么操作系统和内核之间有什么瓜葛呢？一两句话，是说不清楚的，先浅浅的了解一些。 a. 内核是操作系统的一个子集。 b. 内核是最直接的控制底层的硬件的(譬如，内核程序操作声卡发出声音)，API就是应用程序与内核之间的一个接口、应用程序通过调用API，来间接的控制计算机硬件资源。 43. C库函数与API的关系 a. 应用程序是通过API函数来调用操作系统的。 b. 当应用程序需要使用计算机系统的硬件资源(CPU、内存、IO..)，应用程序会通过API向操作系统提出申请，然后操作系统响应申请，来帮助应用程序执行对应的功能。 c. API函数是别人写好的可以实现特定功能的函数，而我们只需要根据它所提供的接口，也就是调用它的方法(传入特定的参数)，那么这个函数就会帮助我们实现特定的功能。 d. 而C库函数可以理解为是对API函数进行了2次封装，做了进一步的改善。使用Windows API编写的程序放到其他的操作系统(linux)上就不工作了；假如是C语言库函数编写的程序，放到其他的操作系统上(linux)上，仍然是可以工作的。 44. 关于main函数 函数本质：是一段代码、是一个数据处理器，我们把数据输入进去，然后经过函数的加工，以得到我们所需要的数据。 main函数，它是比较特殊的，它是整个程序的入口。其他的函数只有被main函数直接或者间接的调用，该函数才可以被执行。 那么main函数是被谁调用的呢？ 答：main函数从某一种角度，就代表了当前的这个程序。谁执行了这个程序，那么谁调用main函数。譬如说，”./a.out”这一个命令行，就代表了它——这个命令行调用了这个main函数。 那么程序有哪几种被调用执行的方法呢？ 答：大概3种。 a. 常见的，在Linux命令行下面直接”./a.out”来执行一个程序 b. 通过shell脚本来调用执行一个程序 c. 在程序中去调用执行一个程序。具体方法，使用fork创建一个子进程，然后使用exec函数族去执行它。(这个暂且了解，到网络编程、应用编程时，会详细讲) 总结：Linux中执行一个程序的本质就是，创建一个新的进程，然后把这个程序丢到这个进程当中，去执行直到结束。也可以认为，父进程fork出来一个子进程,然后子进程和一个程序绑定起来去执行(exec函数族)，我们在exec的时候，就可以给main函数同时传参。 进程究竟是由谁开启的呢？ 答：Linux中的进程都是被它的父进程fork出来的。命令行本身就是一个进程，在命令行底下”./a.out”去执行一个程序，其实相当于这个新程序是作为命令行进程的一个子进程去执行的。 总结： 一个程序(包括main函数)是被它的父进程所调用的。main函数通过返回值，返回给调用main函数的父进程。那么，父进程就得到了一个由main函数产生的返回值。父进程通过这个返回值，依此来判断子进程(main函数)是执行成功了？还是失败了？一般来说，return 0表示成功；而return -1即表示失败。 实践获取main函数的返回值 步骤：使用shell脚本执行程序可以获取程序的返回值，并且打印出来。 1234567891011121314//demo 1a.c中main:return 210;//实践验证2018超范围了，随便给一个&lt;200的数字都可正常打印与a.c同目录下，使用vi新建一个return.sh脚本文件return.sh中#!/bin/sh shell脚本的文件格式./a.out 表示执行这个文件echo $? echo表示打印，与C语言中的printf一样，将程序执行的返回值存放 在$?中最后，gcc a.csource return.sh运行结果：210总结：从运行结果可以看到，&quot;source return.sh&quot;是可以替代我们平时的&quot;./a.out&quot;的。从而，证明了利用shell脚本也是可以执行程序的。 main函数的参数是由谁提供的呢？ 答：调用main函数所在程序的，该程序的父进程给提供的参数，并且该父进程接收main函数的返回值。 为什么要给main函数传递参数呢？ 答：父进程调用子程序时，并不一定要给子程序传递参数。譬如，我们平时书写的”int main(){}”里面就是属于没有传参的这种。传参的目的在于我们希望可以达到一种效果：不需要重新编译就可以更改程序运行的结果。 123456789101112131415161718192021222324//演示通过给main函数传递不同的参数，以达到不需要重新编译就可以更改程序运行结果。//程序功能：写一个简易的计算器，实现&quot;./a.out 12 &quot;+&quot; 12&quot;此时，打印出&quot;12+12=24&quot;int main(int argc,char **argv)&#123; if(argc!=4) &#123; printf(&quot;Please input the para at least 4 !\n&quot;); &#125; if(!strcmp(argv[2],&quot;+&quot;)) printf(&quot;%s+%s=%d\n&quot;,argv[1],argv[3],atoi(argv[1])+atoi(argv[3])); else if(!strcmp(argv[2],&quot;-&quot;)) printf(&quot;%s-%s=%d\n&quot;,argv[1],argv[3],atoi(argv[1])-atoi(argv[3])); else if(!strcmp(argv[2],&quot;*&quot;)) printf(&quot;%s×%s=%d\n&quot;,argv[1],argv[3],atoi(argv[1])*atoi(argv[3])); else if(!strcmp(argv[2],&quot;/&quot;)) printf(&quot;%s/%s=%d\n&quot;,argv[1],argv[3],atoi(argv[1])/atoi(argv[3]));&#125;运行结果：只需要一次gcc a.c编译一次,a,b,c代表了不同的传参从而导致运行结果的不一致a. &quot;./a.out&quot;时，打印&quot;Please input the para at least 4 !&quot;b. &quot;./a.out 12 &quot;+&quot; 12&quot;,打印，&quot;12+12=24&quot;c. &quot;./a.out 12 &quot;-&quot; 12&quot;,打印，&quot;12-12=0&quot;d. &quot;./a.out 12 &quot;*&quot; 12&quot;,打印，&quot;12×12=144&quot;本程序使用了atoi——字符串转整数的一个小技巧。 45. void类型的本质 引言： 强类型语言：是一种强制类型定义的语言。某一个变量一旦被定义了类型，假如没有强制类型转化的话，该变量的类型是不会发生变化的。 弱类型语言：是一种弱类型定义的语言。某一个变量被定义了类型，该变量的类型是可以根据环境的变化，它的类型也是会跟着变化的，是不需要经过强制类型转化的。 而，C语言属于一种强类型语言。 数据类型的本质 该数据类型的变量所占用内存大小的别名。 a. C语言中是不存在没有类型(void)的变量的。因为，C语言并没有规定void类型的变量占多大的内存空间的。 b. C语言是可以有没有类型(void)的指针的。内存在没有和具体类型的变量绑定之前，是没有类型可言的。 123456789//demo 1 演示不同数据类型的指针，对访问数据产生的影响int a = 0x12345678;int *p = (int *)&amp;a;printf(&quot;%x\n&quot;,*p);char *q = (char *)&amp;a;printf(&quot;%x\n&quot;,*q);运行结果：1234567878 void类型的本质 不知道的类型、不确定的类型 46. 关于NULL NULL在C语言中并不是一个关键字，本质上是一个宏定义。 12//demo 1#define NULL (void *)0 NULL的本质就是数字0，这个0并不是当做一个数字来处理的，而是当做一个内存地址来解析的。其实，是一个0x0000 0000，代表内存的0地址。 我们平时为什么定义一个指针时，顺手”int *p = NULL”呢？ 在大部分的CPU，内存的0地址都是由操作系统严密掌控的，程序员是不可以随便的访问的。当我们”int *p = NULL”时，此时指针p指向的内存单元是不可以访问的，除非我们手动的给p置一个适当、合适的值，此时p指向的内存单元就是合法的。假如我们，没有手动的给p一个适当的、合适的值，那么访问p时，就会编译器会提示段错误。从而，我们可以通过编译器的提示来得知p所指向的内存单元是不合法的。 ‘\0’与’0’与NULL ‘\0’是C语言字符串的结尾标志，一般用于比较字符串，以判断字符串有没有结束。 ‘0’对应着0这个字符的ASCII编码，一般用于获取0的ASCII码值 NULL，一般作为判断是否是野指针的条件 47. 关于程序调试的DEBUG宏 调试版本(DEBUG版本)和发行版本(RELEASE版本) 调试版本：包含了调试信息输出的版本，这种版本可以辅助测试人员通过程序运行时打印出的打印信息/log文件，以此判断程序问题的所在。 发行版本：相比调试版本而言代码的功能是一模一样的，只不过去掉了一些调试信息。 2者比较： 由于调试版本在输出调试信息时，占用了系统的资源，拖慢了系统的运行速度。因此，调试版本本身的性能是低于发行版本的。 程序是如何控制是生成调试版本呢？还是发行版本呢？ 答：宏。 48. C语言可变参数的引入 关于可变参数，我们引入了4个陌生的东东。va_list,va_start,va_arg,va_end，下面一一介绍 va_list: 是一种数据类型，用于定义一个字符指针类型的变量 ​va_list vl;定义一个字符指针vl va_start: 是一个宏，初始化可变参数列表 ​va_list(vl,变量名)，vl指向参数表的起始地址 va_arg:是一个宏，获取下一个参数 ​val=va_list(vl,变量类型)，本质从内存单元获取”变量类型”,赋值给val,然后再自动移动sizeof(变量类型)字节。 va_end:是一个宏，停止使用可变参数列表 ​va_end(vl);使vl指向NULL 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//demo 1 功能：利用可变参数，打印出n个浮点小数void f_print(int amount,...)&#123; int i=0; double d=0; va_list vl; va_start(vl,d); printf(&quot;您输入的小数个数为：%d,分别为：\n&quot;,amount); for(i=0;i&lt;amount;i++) &#123; d = va_arg(vl,double); printf(&quot;%lf\n&quot;,d); &#125; va_end(vl);&#125;main:f_print(3,1.23,1.23,1.23);运行结果：您输入的小数个数为：3,分别为：1.2300001.2300001.230000//demo 2 功能：利用可变参数，打印出n个整数中最大的整数int f_max(int amount,...)&#123; int greater=0,val=0; va_list vl; va_start(vl,greater); greater = va_arg(vl,int); for(i=1;i&lt;amount;i++) &#123; val = va_arg(vl,int); greater=(greater&gt;val?greater:val); &#125; va_end(vl); return greater;&#125;main:int a=0;a = f_max(3,10,20,30);printf(&quot;a = %d\n&quot;,a);运行结果：a = 30//demo 3 功能：利用可变参数，打印出n个字符串void s_print(char *first,...)&#123; char *tmp=first; va_list vl; va_start(vl,tmp); while(tmp != NULL) &#123; printf(&quot;%s\n&quot;,tmp); tmp = va_arg(vl,char *); &#125; va_end(vl);&#125;main:s_print(&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;,NULL);运行结果：OneTwoThree 49. 关于’\n’和’\r’的简单介绍，掺杂的有getchar()和putchar()的介绍 12345678910111213141516171819202122232425262728293031323334353637383940414243//demo 1 功能：实现从键盘中输入任意内容、然后把该内容给输出到屏幕上char a;a = getchar();while(a!=EOF)&#123; putchar(a); a = getchar();&#125;运行结果：abcdabcd...总结：getchar()函数，从文本流读入一个输入字符，并将其作为结果返回回去。通俗来讲，从键盘上输入一个字符，getchar()函数的值就是从键盘中输入而得到的值。//demo 2 功能：&apos;\r&apos;与&apos;\n&apos;混合使用的效果putchar(&apos;5&apos;);putchar(&apos;5&apos;);putchar(&apos;5&apos;);putchar(&apos;\r&apos;);putchar(&apos;6&apos;);putchar(&apos;6&apos;);putchar(&apos;6&apos;);运行结果：666总结：putchar()的作用，向终端(显示屏)输出一个字符。&apos;\r&apos;的效果是返回到本行行首，它就会把这一行之前的输出给覆盖掉。//demo 3 printf(&quot;One:\r&quot;);printf(&quot;\n&quot;);运行结果：One:总结：本来应该打印出&quot;One:&quot;字样的，使用了&apos;\r&apos;以后，紧跟着后面有一个&apos;\n&apos;。导致的效果：原本应该打印输出&quot;One:&quot;字样的，使用了&apos;\r&apos;以后，光标就会移动到该行最开始的地方。相当于是把原本要打印输出的内容&quot;One:&quot;给抹掉了。但是，紧接着一个&apos;\n&apos;的效果，就是把原来擦除掉的东西给还原回来。//demo 4printf(&quot;One:\n&quot;);printf(&quot;012 3456 %d\r789&quot;,6666);printf(&quot;ABCD:&quot;);printf(&quot;\n&quot;);printf(&quot;012 3456 %d\r789&quot;,6666);运行结果One:789ABCD: 6666789root@ubuntu:/mnt/hgfs/code#总结：这个demo很好的展示了demo 3所想要展示的原理。此外，可以看出printf函数是属于行缓冲的，当它没遇到&apos;\n&apos;时，该行的内容是不会被打印出来的。 50. 关于47-&gt;debug宏的接续 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155//demo 1 再一次的理解一下递归的含义是什么？递归的实现void func(int cnt)&#123; if(cnt == 0) return; func(cnt/10); printf(&quot;cnt=%d\n&quot;,cnt);&#125;main:func(1234);运行结果：cnt=1cnt=12cnt=123cnt=1234分析：func(1234)-&gt;func(123)-&gt;func(12)-&gt;func(1)-&gt;func(0)，到func(0)时，程序开始推出。递归，有一种&quot;咬到底&quot;的味道，&quot;咬到底&quot;指的是，当满足此时的条件已经开始不满足递归条件时，开始弹栈操作。之前的递归条件满足时，是一直的在压栈的。因而，结果如上。//demo 2 &quot;do&#123;&#125;while(0);&quot;的演示使用(一)(一)#define AB printf(&quot;abcd\n&quot;);printf(&quot;ABCD\n&quot;);main:if(0) AB运行结果：ABCD分析：我明明是if(0)条件不成立呀，但是AB的这个宏也是执行了一部分的。我在第一次书写时，写成了if(0)&#123;AB&#125;，那么别小看了这个&#123;&#125;，加上了它之后打印的结果肯定是2行都全部输出打印的。总结，宏定义的实现，原封不动的全部替换。(二)#define AB do&#123;printf(&quot;abcd\n&quot;);printf(&quot;ABCD\n&quot;);&#125;while(0);main:if(0) AB运行结果：什么也没有输出。分析：使用了&quot;do&#123;&#125;while(0);&quot;之后呢，我们使用if(0)，那么显然是条件不满足的情况，故什么也没打印出来。正好符合我们心中所想的。//demo 3 &quot;do&#123;&#125;while(0);&quot;的演示使用(二)(一)#define AB printf(&quot;abcd\n&quot;);printf(&quot;ABCD\n&quot;);main:if(1) AB 运行结果：abcdABCD(二)#define AB do&#123;printf(&quot;abcd\n&quot;);printf(&quot;ABCD\n&quot;);&#125;while(0);main:if(1) AB运行结果：abcdABCD总结，当if(1)时，无论使用do&#123;&#125;while(0);还是不使用，它们的结果是一样的。//demo 4 关于stdout与stderrprintf(&quot;Hello world\n&quot;);fprintf(stdout,&quot;abcdefg&quot;);fprintf(stderr,&quot;ABCDEFG&quot;);运行结果：Hello worldABCDEFGabcdefgroot@ubuntu:/mnt/hgfs/code# 分析，stdout属于行缓冲的——&lt;1&gt;遇到&apos;\n&apos;或者&apos;\r&apos;时 &lt;2&gt;遇到return 0；时。stderr属于没有行缓冲的形式，即会立即打印字符。//demo 5#define DEBUG(args) (printf(&quot;DEBUG():&quot;),printf args)main:int a=5;if(a!=0)&#123; DEBUG((&quot;a is %d\n&quot;,a));&#125;运行结果：DEBUG():a is 5分析，这属于有一个参数的，带参宏。定义时，是要使用逗号来分离的。而，需要注意的是，在使用时，是需要加上2个括号的。否则是会报错的。//demo 6#define DEBUG(...) fprintf(stderr,__VA_ARGS__)main:int a=5;if(a!=0)&#123; DEBUG(&quot;a is %d\n&quot;,a);&#125;运行结果：a is 5分析，debug宏的可变参数，此时DEBUG是没有使用双括号的哦！//demo 7 版本(一) &quot;##&quot;的引入#define debug(format,args...) fprintf(stderr,format,args)main:char arr[20]=&quot;Hello world\n&quot;;int i=10;debug(&quot;i=%d,%s&quot;,i,arr);运行结果：i=10,Hello world//demo 8 版本(二)#define debug(format,args...) fprintf(stderr,format,args)main:debug(&quot;Hello world\n&quot;);运行结果：error: expected expression before ‘)’ token#define debug(format,args...) fprintf(stderr,format,args)分析，在debug宏定义时，显示的是至少有2个参数的。可是，我们在使用时只提供了一个参数。导致了，定义时与使用时的规格不一致。编译器，因此报了错误。//demo 9 版本(三)&lt;1&gt;#define debug(format,args...) fprintf(stderr,format,##args)main:debug(&quot;Hello world\n&quot;);运行结果：Hello world通过使用&quot;##&quot;可以完美的解决了，定义宏时与使用宏时，由于规格不一致而引发的问题。&lt;2&gt;上题中&quot;args...&quot;与&quot;##args&quot;是配对的；而在C99的标准中，&quot;...&quot;与&quot;##__VA_ARGS__&quot;是配对的。#define debug(format,...) fprintf(stderr,format,##__VA_ARGS__)main：debug(&quot;Hello world\n&quot;);运行结果：Hello world//demo 10 综合(一)#define DEBUG#ifdef DEBUG#define DEG(...) fprintf(stderr,&quot;DEG(%s,%s(),%d:)&quot;,__FILE__,__FUNCTION__,\__LINE__);fprintf(stderr,__VA_ARGS__)#else#define DEG(...)#endifmain:DEG(&quot;hello world\n&quot;);运行结果：DEG(a.c,main(),41:)hello world分析，这个结果可是折腾了好久才成功运行了的。比如&quot;__FILE__&quot;这个东西必须是双下划线的；换行时，是要用&quot;\&quot;的；里面的一个一个&quot;,&quot;都是一个都不可以少的。__FILE__表示文件名__FUNCTION__表示函数名__LINE__表示调用&quot;DEG&quot;的行数。//demo 11 综合(二)#define _DEBUG do&#123;&#125;while(0)#ifdef _DEBUG#define DEBUG(...)\ do&#123;\ fprintf(stderr,&quot;-----DEBUG-----\n&quot;);\ fprintf(stderr,&quot;%s %s\n&quot;,__TIME__,__DATE__);\ fprintf(stderr,&quot;%s:%d:%s():&quot;,__FILE__,__LINE__,__FUNCTION__);\ fprintf(stderr,__VA_ARGS__);\ &#125;while(0)#endifmain:DEBUG(&quot;Hello world\n&quot;)运行结果：-----DEBUG-----15:06:41 Jun 11 2018a.c:25:main():Hello world分析，__TIME__编译的时间__DATE__编译的日期__FILE__文件名字__LINE__调用DEBUG的行数__FUNCTION__函数名总结：像着一些东西，稍微的稍微的，差了一个标点符号、大小写什么的都可能导致编译出现稀奇古怪的问题。所以，解决的方法，看懂它；然后学会使用就好，自己一个一个码字打上去，后果你可以尝试尝试，很痛苦的。]]></content>
  </entry>
  <entry>
    <title><![CDATA[C语言杂记(一)]]></title>
    <url>%2F2018%2F05%2F16%2FC%E8%AF%AD%E8%A8%80%E6%9D%82%E8%AE%B0(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[笔记： 刚才，或许是自己打开的应用程序过多的缘故，还是这个xMind工具的缘故，电脑一下子黑屏了并且伴随着电脑的散热量也是轰轰之响。害得我重启电脑，前面写的一堆东西，现在回过头重新的写一遍。2018-5-7 1. URL：统一资源定位器(uniform resource location) 是用来定义标准的网络地址的书写形式的。譬如http://www.xxx......... 2. TFTP服务器：简单的文件传输协议，用于在远程服务器和本地的主机之间进行文件的传输。 DNS服务器：domain name(域名)。指的是保存有该网络中所有主机的域名和对应的IP地址，并且具有将域名转化成为IP地址的功能。 3. 计算机网络大致分为哪几类？ 局域网、城域网、广域网、互联网(Internet，也就是我们常说的www.xxx......) 4. 在Ubuntu中的vi编辑模式下 创建软连接：ln -s exit_file new_file。注意：在共享文件目录下面创建软连接是创建不成功的哦！换为非共享目录即可实现。 设置永久行号：a. 使用vi命令打开~/.vimrcb.在其输入set nu即可。 在命令模式下面：在光标闪烁的位置，输入dd删除掉该行；输入yy可以复制该行，p即可粘贴该行。 du -h命令可以很方便、直观的显示出文件的大小(KB、MB) 5. 关于void 类型的理解：void 类型，该指针的类型是不确定的。可能是int、float、double等等类型的。 1234567int a=5;void *p = &amp;a;printf(&quot;*p = %d\n&quot;,*((int *)p));printf(&quot;*p = %f\n&quot;,*((float *)p));运行结果：*p = 5*p = 0.000000 6. C语言中的数据类型转化 隐式类型转化：默认的朝着精度更高、范围更大的方向转化。 强制类型转化： 7. 数据类型的本质： 该数据在内存中是以何种方式储存的 、以及是以何种方式取出来的、以何种方式转化为二进制数的问题。一定要记住，内存只管存储这一些101010的数字而已，它只管存储的，至于拿到了这一串101010的数字之后怎么样去进行解析，这就是由数据类型来操控的。 8. 变量和常量 变量：局部变量(函数内部)和全局变量(函数外部)。 ​ 局部变量又分为普通局部变量、静态局部变量和register类型的局部变量。 我们平时见到的大部分都是普通局部变量，它的关键字是auto，只不过说我们平时给省略掉了。 静态局部变量，用关键字static修饰的变量，只有在第一次才经历变量的定义和初始化，以后该变量维持了上一次执行以后，该变量的值。也就是说，它的值是会”累加的”。静态局部变量和全局变量十分的相似，相同点在于生命周期都是很长的，区别在于它们的作用域是不同的。 register修饰的局部变量，在行为表现上和auto是一样的，它基本上没什么用。C语言的运行时环境承诺，会尽量的将该类型的变量存放在寄存器中(普通的变量一般都在内存中)，所以说register类型的变量的访问速度很快的，但是由于寄存器的数目也是非常的有限的，也就造成了register类型的变量有很多的限制。 全局变量：普通全局变量和静态全局变量 普通的全局变量，可以在多个文件中共同使用。所以，要确保该全局变量不重名。 静态全局变量，是用来解决重名的问题的。所以，静态的全局变量并不是给别的文件使用的，是给自己本文件所使用的。 跨文件引用全局变量：extern。在有多个.c文件的时候，可以在一个.c文件中定义全局变量g_a,然后在另一个.c文件中引用该变量(引用之前一定要用extern声明)。在这里要强调的是：使用extern定义变量的时候，是不可以进行赋值操作的。 局部变量和全局变量总结： 定义时没初始化，则局部变量的值是随机的，而全局变量的值是默认的 使用范围上：全局变量具有文件作用域，而局部变量只有代码块作用域 生命周期上：全局变量在开始运行之前的初始化阶段就已经诞生了，到了整个程序结束退出的时候才消亡的；而局部变量在进入局部变量所在的代码块时诞生，在该代码块退出的时候才消亡的。 变量分配位置：全局变量分配在数据段上，而局部变量分配在栈上面。 思考题1： 局部变量是否可以跨文件使用？答：否，因为局部变量属于代码块作用域，它的作用域仅仅在它定义的那个函数的内部。 思考题2： 静态局部变量是否可以跨文件使用呢？答：否，它本质上任然是一个局部变量。 9. 一些基本概念： 代码块：一个{}括起来的一段代码 数据段：存储的是数据、譬如说全局变量 代码段：存放程序代码，一般是只读的 10. C语言对内存的管理方式：大致分为5各部分。 代码段(code或text)，代码段是由各个函数产生，函数的每一个语句将最终经过编译、汇编生成二进制的机器码(具体生成哪一种体系的机器码由编译器所决定的) 数据段，分为只读数据段(RO Data)和可读可写数据段(RW Data)。其中RO Data程序中使用到的常量，会在编译的时候被放入到RO Data；而RW Data，又称为已经初始化的数据段，通常把已经初始化的全局变量和已经初始化的静态局部变量，在编译时放在了RW Data中。 BSS(未初始化的数据段)，该段中的数据是没有经过初始化的，不是目标文件(.obj)中的一部分。未初始化的数据段只有在运行的初始化阶段才会产生。因此说，BSS段的大小是不会影响目标文件的大小的。 堆，堆内存只有在程序运行的时候才出现，一般由程序员分配和释放(malloc,free)。注意分配好内存以后，要记得手工的将该内存给释放掉，以免发生内存泄漏。 栈，栈内存只在程序运行的时候出现。在函数内部使用的变量、函数的参数以及返回值将使用栈空间，栈空间是由编译器自动分配和释放的。 举个例子： 12char *p = &quot;abcdefg&quot;;其中的“abcdefg\0”这一坨存放在RO Data,也可以说在数据段；而变量p存放在栈上。 总结 ： 代码段、数据段(RO Data、RW Data)、BSS段，这3个段都属于程序中的静态区域，而 堆和栈都属于程序的动态区域。 C语言程序经过编译、链接生成的二进制可执行代码，只包含代码段、RO Data、RW Data。堆和栈是在程序运行以后才包含进去的，而BSS中的数据将会在程序运行之前置0。 使用const定义的变量将存放于程序的只读数据区(RO Data) 函数体中定义的变量通常是在栈上面的，是不需要在程序中进行管理的，由编译器来处理。 11. 常量：#define定义的常量、const关键字定义的常量、枚举常量(C++中实现了真正意义的枚举常量) 记着一个例子： 12char *strcpy(char *dst,const char *scr);把src这个字符串拷贝到dst里面去，src所指向的是复制源，使用const修饰表示我们是不会更改src所指向的内容的。 12. 1234#ifndef _A_H_#define _A_H_...#endif 作用：防止重复包含头文件。 写程序的时候最好不要在头文件中定义变量，最好在源文件中定义变量。 原因：很有可能该头文件被多个源文件所包含，这样就会导致重复定义问题。全局变量的定义因该在某一个源文件中，然后，其他的源文件想要使用该变量的时候，只需要在使用之前使用extern进行声明即可使用。 13. 程序运行的目的是什么？ 答：程序的目的是为了运行，而运行的目的是为了得到一定的结果。计算机程序是由代码+数据组成的。”代码”是一个动作，是一个加工数据的动作；而数据是被代码加工的原材料。所以说，程序运行的目的要么是结果、要么是过程。在C语言中，一些返回值为void类型的函数，该程序在乎的就是程序运行的过程；而一些返回值非void的函数，程序的运行有可能是在乎结果的，也有可能是过程和结果都是在乎的。 14. 计算机程序运行的过程？ 答：计算机程序运行的过程，其实就是很多个函数相互运行的过程。程序是由很多个函数组成的，程序的本质就是函数，而函数的本质就是加工数据的动作。 15. 冯诺依曼结构和哈弗结构： 冯诺依曼结构：数据和代码放在一起的(Cortex-A8中)；哈弗结构：数据和代码是分开存放的(C51中)。 代码：一个一个的函数 数据：全局变量、局部变量 16. 内存位宽： 硬件内存的实现本身是有宽度的，有一些内存条是8位的，一些内存条的宽度是16位的。需要注意的是，内存芯片之间是可以相互关联的，一个32位的内存芯片可以由4个8位的内存芯片并联实现。 内存编址的方法： 从逻辑角度而言，内存是由无限多个内存单元格组成的，每一个内存单元格都有一个固定的地址，叫做内存地址。这个内存地址和这个单元格是一一对应的关系，并且永久绑定的。 内存的编址是以字节为单位的，譬如说表格中的每一个数字标号，占1字节，即8个bit位。 内存编址的单元是以字节为单位的。 在内存中，一个字节代表一个编号……………….. 7 6 5 4 3 2 1 0 编号3 编号2 编号1 编号0 内存与数据类型的关系： C语言中基本的数据类型int、float、double，这一些数据类型与该类型的变量所占的内存长度(多少字节)有关系。 内存对齐： 对齐访问与硬件本身的结构是搭配的，所以执行的效率就会很高。 第一种：0 1 2 3 对齐访问 第二种：1 2 3 4或2 3 4 5或3 4 5 6 非对齐访问 指针变量(读上10遍不为过)： 指针变量也是一个变量，只不过它里面存放的是内存的地址，确切的来讲是内存的首地址。当我们用一个指针指向这个变量的时候，此时指针的值就是这个连续内存的首地址。使用指针取值操作读取变量值的时候，就是根据指针里面存放的地址，找到对应的内存，然后再根据规则(不同的数据类型)读取相应长度的内存中的数据。指针本身的存放也是需要使用内存的，只不过它是存放在另一个内存空间里面的，那个内存空间就是指针变量的存放空间。指针变量的大小是固定的，32位系统下面指针变量占4字节、64位系统下面是8字节。 指针变量占几个字节大小取决于：CPU寻址的最大寻址内存空间。 指针的大小为4字节：表示该指针可以记录的地址范围为0x0000 0000-0xFFFF FFFF,在这个范围的数字才属于指针变量的值。而比方说一个char类型的变量，既可以存放在0x0地址处，也可以存放在0xFFFF FFFF地址处，存放那一个地址处与char类型的变量本身占多大的字节是没有关系的。与你的系统是32位还是64位有关系的。 17. C语言中操作的变量，其实就是一个内存单元。C语言中变量名的实质就是内存地址(拓展开来，函数名的本质也是内存地址)；而数据类型的本质表示内存单元的长度以及解析的方法。 18. int a[10]; 编译器分配了4字节长度给a，并且把首元素首地址与符号a绑定起来。数组中第一个元素a[0]称之为首元素，数组中每一个元素都是int类型的，都占4个字节，其中第一个字节的地址就称之为首地址。首元素a[0]的地址，就称为首元素首地址。 19. 使用位运算对寄存器操作的要求： 在嵌入式领域当地中，涉及到的移位操作都是无符号数。在设定特定位的同时，是不可以影响其他位的。具体做法，我要往一个寄存器里面写数据去操控一个外设，不是直接的往里面写，而是先把先把原来寄存器整体的值读取出来，然后对其局部的改造，最后再把它写进去寄存器中。所谓的，”读改写“三部曲。 20. 利用移位操作设置特定位为1 第一题：设定bit3-bit7为1，0x1F&lt;&lt;3即可。 解题方法：bit3-bit7为1，即5个1(这里的5个1指的是，bit0-bit4)，即0x1F,将0x1F左移3位，即bit3-bit7全为1，从而达到目的。 第二题：设置bit3-bit7为1，同时bit23-bit25为1。 解题方法：bit3-bit7为1，即5个1(这里的5个1指的是，bit0-bit4),即0x1F,将0x1F，左移3位，即bit3-bit7全为1，从而实现目的一；bit23-bit25为1，即3个1(这里的3个1指的是，bit0-bit2)，即0x07,将0x07左移23位，即可实现。 综上：(0x1F&lt;&lt;3)|(0x07&lt;&lt;23) 利用移位结合取反，获得特定位为0 例子：设定bit3-bit7为0。 答案：~(0x1F&lt;&lt;3) 21. 位运算实战 实战1：给定一个整数a,设置a的bit3,保证其他位不变。 a = a|(1&lt;&lt;3) 实战2：给定一个整数a,设置a的bit3-bit7，保证其他位不变。 a = a|(0x1F&lt;&lt;3) 实战3：给定一个整数a,清除a的bit15，其他位不变。 a &amp;= ~(1&lt;&lt;15) 实战4：给定一个整数a,清除a的bit15-bit23,其他位保持不变。 a &amp;= ~(0x1FFF&lt;&lt;15) 实战5：给定一个整数a,取出a的bit3-bit8 思路：第一步，先将bit3-bit8不变，其余位全部清零。 a &amp;= (0x3F&lt;&lt;3) ​ 第二步，再将其右移3位，即可取出bit3-bit8. a = a&gt;&gt;3 实战6：给一个寄存器的bit7-bit17赋值为937,其余位不受影响。 思路：第一步，将bit7-bit17全部清零 a &amp;= ~(0x7FFF&lt;&lt;7) ​ 第二步，再将937写入到bit7-bit17中 a |= (937&lt;&lt;7) 22. 关于字体设置，在QT中配色方案选择Default，然后字型选择Consolas，注释看着很舒服！ 23. 为什么要引入指针的概念？ 答：指针的出现是为了实现间接寻址。直接寻址，CPU直接与内存打交道；而间接寻址CPU与内存之间通过一个寄存器这么一个桥梁，搭连在一块的。反映在C语言中，直接寻址就是通过定义变量来获取变量的数值。间接寻址通过指针的解引用的方式访问数据。 24. 左值、右值的概念： 放在赋值运算符左边的叫做左值，右边的叫做右值，所以，赋值操作其实就是：左值=右值。 当一个变量做左值时，编译器把这个变量符号的真实含义当做这个变量对应的那段内存空间；当一个变量做右值时，编译器把这个变量符号当做这个变量所对应的内存空间中存储的那一个值。 例如int a; 当a作为左值时，它代表那个内存格子所对应的空间，是一个框子。当a作为右值时，它就代表那个格子里面存放的那个值。 举例子，我们平时所说的，”我到家了”，这里的家指的是房子，类似于左值的概念；而我们说”家比事业更重要”，这里的家，更侧重于房子里面的人，类似于右值的概念。 25. 野指针问题： 定义：指针所指向的位置是不可知的、随机的、不正确的、没有明确限制的。 坏处：野指针很有可能触发运行时的段错误 避免方法：在指针的解引用之前一定要保证指针指向了一个绝对可用的内存空间。 26. NULL到底是什么？ 在C++中，NULL就是数字0；而在C语言中NULL是经过void *强制类型转换过的0 我们平时为什么if (NULL != p)来作为判断是否是野指针的条件呢？第一，0地址是一个特殊的地址，当指针指向这里的时候，我们就可以认为该指针没有被初始化，它就是野指针。第二，这个0地址，在一般的操作系统中是不可以访问的，假如程序员非要访问此地址，编译器会产生一个段错误，作为提示信息。 27. const修饰的变量真的就不可以更改嘛？ 1234567891011121314const int a = 5;int *p = (int *)&amp;a;int *q = (int *)&amp;a;printf(&quot;&amp;a = %p,p = %p,q = %p\n&quot;,&amp;a,p,q);printf(&quot;a = %d,*p = %d,*q = %d\n&quot;,a,*p,*q);*p = 6;*q = 66;printf(&quot;&amp;a = %p,p = %p,q = %p\n&quot;,&amp;a,p,q);printf(&quot;a = %d,*p = %d,*q = %d\n&quot;,a,*p,*q);运行结果：&amp;a = 0028feb4, p = 0028feb4, q = 0028feb4a = 5, *p = 5, *q = 5&amp;a = 0028feb4, p = 0028feb4, q = 0028feb4a = 5, *p = 66, *q = 66 自我的推测：从”a=5,p=66,q=66”结果来看，地址0028feb4这个位置，仿佛有一个”真身、假身”的味道在里面。 总结：使用const时，更多的是在传递一种信息，告诉编译器、告诉阅读程序的人，这个变量是不应该被修改的。 28. 数组 从内存角度来讲，数组变量就是一次分配多个变量，这多个变量的存储单元是依次相连的，但是这多个变量的访问却都是独立的访问的。 变量、变量名、变量类型的理解： 变量其实就是内存中的一块区域，变量名(做右值)就是这块区域的名字。当我们想要访问这个变量时，有两种方法：第一种，直接通过变量名进行访问(像局部变量这种) 第二种，通过它的地址，然后使用解引用的方式找到它(指针)。变量的类型，以某一个起始地址开头，对一定字节长度的数字的解析方式(譬如，char 1字节长度，int 4字节长度…)。 数组中a a[0] &amp;a &amp;a[0]理解(int a[10]): a 数组名(变量名)，当a作为左值时，代表整个数组的所有的空间(10*4=40Byte),但是C语言规定数组在操作时必须是单个操作的，不能够整体操作数组，所以a不可做左值。当a做右值时，代表：数组的首地址。即，数组的第一个元素，也就是a[0]的首地址。即，数组首元素的首地址(4字节中最开始的第一个字节的地址)。等价于&amp;a[0]。 a[0] a[0]做左值时，代表第0个元素所对应的内存空间(连续4字节)。a做右值时，表示第0个元素的值(第0个元素对应的内存空间中存储的那个数字)。 &amp;a 对数组名取地址，字面意思来看就是数组的地址。&amp;a不可以做左值(常量不可以在=左边的)。&amp;a做右值时，表示整个数组的首地址。 &amp;a[0] 对数组第0个元素取地址，也就是第0个元素的地址。做左值时，表示数组首元素所对应的内存空间。右值时，表示数组首元素首地址(首元素对应的内存空闲中存储的那个值) 12345678910111213int a[5] = &#123;1,2,3,4,5&#125;;int *p;printf(&quot;a = %p\n&quot;,a);printf(&quot;&amp;a[0] = %p\n&quot;,&amp;a[0]);printf(&quot;&amp;a = %p\n&quot;,&amp;a);printf(&quot;sizeof(a) = %d\n&quot;,sizeof(a));printf(&quot;sizeof(&amp;a) = %d\n&quot;,sizeof(&amp;a));运行结果：a = 0028feac&amp;a[0] = 0028feac&amp;a = 0028feacsizeof(a) = 20sizeof(&amp;a) = 4 总结： &amp;a和a和&amp;a[0]做右值时，&amp;a是整个数组的首地址，而a和&amp;a[0]是数组首元素的首地址。 1234int *p;int a[5];p = a;//p = &amp;a;//左边右边类型不匹配，一个是int *型，另一个是int (*)[5]即，数组指针类型。 29. 为什么指针变量加1之后实际上加的不是1，而是1*sizeof(指针类型)？？ 答：编译器希望，加1之后，指针刚好指向的是下一个元素，而并不是加1之后仅仅错位了1个字节而已。 30. 数组作为函数形参： 数组作为函数形参时，传递的并不是整个数组，而是数组的首元素的首地址，根本没有数组长度的这个信息。这也正验证了”数组作为函数形参时，[]中的数字是可有可无的。”这句话。 31. 关于传值调用和传址调用。 这个世界上压根就没有什么传址与传值调用之说。C语言本身函数调用时，一直都是传值的，只不过说，传递的值既可以是变量名，也可以是这个变量的指针。 32. 输入型参数与输出型与返回值问题。 对于一个函数，我们都知道函数名本质就是整个代码段的首地址，而形参时函数的输入部分，返回值是函数的输出部分。对函数的进一步理解：把函数当做是一个数据加工的机器，通过输入型参数放入加工原材料，通过返回值输出成品。 那么，假如一个函数既没有返回值，也没有形参列表，那么它的作用和全局变量的效果就一样了。使用全局变量可以省略传参的开销，相对效率要高一点；而在实战当中使用最多的还是传参的这种形式，这里假如参数很多传参的开销很大的话，通常的做法把很多参数打包成一个结构体，然后传结构体变量指针进去即可。 33. 函数需要向外部返回多个返回值时应该怎么办？ 现实编程中，一个函数需要多个返回值时非常普遍的,因此说仅仅依赖平时的那一种只有一个返回值的情况是无法实现的。所以，通常使用的方法是使用参数来实现多个返回值问题。 比较普遍的做法：编程中函数的输入和输出都是靠函数参数来实现的，返回值只是用来表示函数执行的是成功还是失败。如果这个参数是用来做输入的，就叫做输入型参数；如果是想把函数内部数据输出到函数外部的，这一种就叫做输出型参数。作为输入型参数的，一般是加了const的。 34. 1234567891011#define和typedef#define dpChar char *typedef char * tpChar;dpChar p1,p2;tpChar p3,p4;printf(&quot;sizeof(p1) = %d, sizeof(p2) = %d\n&quot;,sizeof(p1),sizeof(p2));printf(&quot;sizeof(p3) = %d, sizeof(p4) = %d\n&quot;,sizeof(p3),sizeof(p4));运行结果：sizeof(p1) = 4, sizeof(p2) = 1sizeof(p3) = 4, sizeof(p4) = 4说明：使用#define宏定义来定义变量的时候，是不可以连着定义变量的。 35. 指针数组与数组指针： 1234567891011121314151617181920212223242526//指针数组int i = 0;char *pChar[] = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;&#125;;for(i=0;i&lt;sizeof(pChar)/sizeof(pChar[0]);i++)&#123; printf(&quot;pChar[%d]=%s\n&quot;,i,pChar[i]);&#125;运行结果：pChar[0]=onepChar[1]=twopChar[2]=three//数组指针(等效为二维数组)int i = 0,j = 0;int a[2][4] = &#123;&#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;&#125;;int (*pa)[4] = a;for(i=0;i&lt;sizeof(a)/sizeof(a[0]);i++)&#123; for(j=0;j&lt;4;j++) &#123; printf(&quot;a[%d][%d]=%d\n&quot;,i,j,*(*(pa+i)+j)); &#125;&#125;运行结果：a[0][0]=1a[0][1]=2... 判断到底是数组指针、指针数组、函数指针、指针函数这一类的方法？ 第一步，找核心(函数名) 第二步，找与核心最接近的那个符号(即为本质) 第三步，逐层的向外扩展即可 36. 函数指针与指针函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465函数指针：第一种：这叫做函数指针没错，但是是最最基本的概念void func()&#123; printf(&quot;function pointer\n&quot;);&#125;main:void (*pFunc)() = func;void (*pFunc2)() = &amp;func; //(1)(2)的效果是等效的(*pFunc)();pFunc2(); // 下面的两行也是等效的第二种：函数指针通常用在函数传参中int compare_int(void *a,void *b)//比较两个整数&#123; if(*(int *a) == *(int *)b) return 0; else return 1;&#125;int compare_char(void *b,void *b)//比较两个字符&#123; if(*(char *)a == *(char *)b) return 0; else return 1;&#125;int Compare(void *a,void *b,int (*compare)(void *,void *))&#123; if(compare(a,b) == 0) printf(&quot;They are equal\n&quot;); else printf(&quot;They are not equal\n&quot;);&#125;main:int a=1,b=1;char c1=&apos;a&apos;,c2=&apos;b&apos;;Compare(&amp;a,&amp;b,compare_int);Compare(&amp;c1,&amp;c2,compare_char);运行结果：They are equalThey are not equal指针函数：该举例的功能是：利用指针函数，打印出二维数组(a[3][4])的某一行的内容float *pFind(float (*p)[4],int n)&#123; float *pf; pf = *(p+n); return pf;&#125;main:int i,n;float *p;float Array[3][4] = &#123;&#123;11,11,11,11&#125;,&#123;22,22,22,22&#125;,&#123;33,33,33,33&#125;&#125;;printf(&quot;请您输入要打印的行号:&quot;);scanf(&quot;%d&quot;,&amp;n);printf(&quot;第%d行的内容是:\n&quot;,n);p = pFind(Array,n-1);for(i=0;i&lt;4;i++) //目的：从起始位置(行)连续输出4个元素&#123; printf(&quot;%3.2f\t&quot;,*(p+i)) ;&#125;运行结果：请您输入要打印的行号: 1第1行的内容是：11.00 11.00 11.00 11.00 37. Linux中的命令默认是行缓冲的，行缓冲指的是程序printf输出时，Linux是不会一个字、一个字的输出我们输入的内容的，而是将其缓冲起来，放在一个缓冲区中，等这一行准备完了(遇到’\n’时)，然后再一次性的把整行的内容都给输出出来。 38. 二维数组 12345678910111213141516int Array[3][4] = &#123;&#123;0,1,2,3&#125;,&#123;4,5,6,7&#125;,&#123;8,9,10,11&#125;&#125;;printf(&quot;Array的地址:%p\n&quot;,Array);printf(&quot;Array+1的地址:%p\n&quot;,Array+1);//差16字节printf(&quot;Array[0]的地址:%p\n&quot;,Array[0]);printf(&quot;Array[0]+1的地址:%p\n&quot;,Array[0]+1);//差4字节printf(&quot;%d\n&quot;,sizeof(Array));printf(&quot;%d\n&quot;,sizeof(Array[0]));运行结果：Array的地址:0028fe90Array+1的地址:0028fea0Array[0]的地址:0028fe90Array[0]+1的地址:0028fe944816另外一点：二维数组名a等价于&amp;a[0],a[0]等价于&amp;a[0][0],类比于一维数组名a等价于&amp;a[0]的味道。 Array 0 Array[0] 1 Array[0]+1 2 Array[0]+2 3 Array[0]+3 Array+1 4 Array[1] 5 Array[1]+1 6 Array[1]+2 7 Array[1]+3 Array+2 8 Array[2] 9 Array[2]+1 10 Array[2]+2 11 Array[2]+3 39. 程序中的内存是从哪里来的？ 对于程序来讲，内存是程序的立足之地，也就是说程序是放在内存当中运行的。程序在运行的时候，需要内存来存储一些临时变量。内存管理的实现是由操作系统所完成的。三种内存来源：栈(statck)、堆(heap)、数据区(data) 栈(statck):程序运行时自动分配、自动回收；反复的使用(脏内存)；函数是不可以返回栈变量的指针的；栈是会溢出的。 解释为什么函数是不可以返回栈变量的指针的？但是注意返回堆内存的指针是可以的。 答：局部变量的作用域，只在函数的内部(即{}内)，函数返回值后局部变量的内存就已经释放了。这样指针指向的内容就是不可预料的内容，调用就会出错的。 程序运行时使用malloc申请任意字节的内存，程序员自己负责何时free掉这些内存。动态内存的生存期是程序员自己来掌控的，所以，使用起来就特别的灵活。 什么是内存释放？所谓的释放，就是操作系统收回了你对这段内存的使用权限。 12345678910111213141516171819202122232425262728293031323334353637383940//返回存放在只读数据段(ORData)上面的变量的指针char *returnData()&#123; char *p = &quot;Good Morning\n&quot; ; return p;&#125;main:char *p;p = returnData();printf(&quot;%s\n&quot;,p);运行结果：hello world总结：&quot;Good Morning&quot;是一个字符串常量，存放在只读数据段ORData上面。把该字符串常量存放在只读数据段(ORData)的首地址赋值给了指针，所以returnData函数退出时，该字符常量的内存是不会被回收的。//返回指向堆内存的指针是可以的char *returnHeap(int num)&#123; char *p = (char *)malloc(sizeof(char *)*num) ; return p;&#125;main:char *p = NULL;p = returnHeap(100);strcpy(p,&quot;Good Morning&quot;);printf(&quot;%s\n&quot;,p);free(p);运行结果：Good Morning总结：见上。//返回栈变量的指针(是不正确的)char *returnStatck()&#123; char a[] = &quot;Good Morning&quot; ; return a;&#125;main:char *p = NULL;p = returnStatck();printf(&quot;%s\n&quot;,p);运行结果：输出的是乱码总结：returnStatck函数退出时，栈要清空，函数对内存的使用权限已经终止。这时，函数返回的是一个已经被释放掉了的内存地址，所以打印出来很可能是乱码。解决方法：非要返回一个局部变量的地址，加上static修饰，改变它的生存期，即可。 堆内存 栈内存的管理方式类似于统一的平均分配(小块内存)。所以，栈内存一般是不会很大的，它考虑的是每一个进程普遍的使用内存块的大小，来设置一个合适的、尽量可以满足大众所使用的内存块。而堆内存的管理方式是”按需分配”的。需要的多的话，那就多分配一点、需要少的话那就少分配一点。各个进程可以按照需求手动申请使用，使用完以后手动的将内存释放掉即可。 malloc实际返回的是本次申请的那一段内存空间的首地址。 malloc申请得到的内存在使用完以后要free掉的，把该内存给释放掉。 在调用free释放内存之前，指向这段内存的指针是不可以丢失的(p不可以再赋给其他值)，一旦p丢了，那就会造成内存泄漏。 在gcc编译环境下，当我malloc(1),malloc(2),malloc(3)……是编译器到底分配多少字节空间？ 答：在gcc环境下，malloc分配内存空间默认最小是16Byte。当我们需要多少字节的内存空间的话，只需要malloc(n),此时编译器给你分配的内存空间并不一定刚刚好恰好就是n，但是是不可以确保你够用的(设置一个无穷大的数除外)。 代码段：是由一个一个的函数堆垒而组成的 数据段：可以理解为C语言中的全局变量 BSS段：本质是初始化为0的 数据段 40. 小知识点：第一点：字符0的ASCII码为48 第二点：字符’\0’的ASCII码是0 123456char c1 = &apos;0&apos;;char c2 = &apos;\0&apos;;printf(&quot;c1 = %d\nc2 = %d\n&quot;,c1,c2);运行结果：c1 = 48c2 = 0 41. 字符常量与字符串常量 1234567891011121314char c1 = &apos;a&apos;;char *p = &quot;good&quot;;printf(&quot;c1 = %d\n&quot;,c1);printf(&quot;字符串的地址:0x%p\n&quot;,&quot;good&quot;);printf(&quot;p = 0x%p\n&quot;,p);printf(&quot;sizeof(c1) = %d\n&quot;,sizeof(c1));printf(&quot;sizeof(good) = %d\n&quot;,sizeof(&quot;good&quot;));运行结果：c1 = 97字符串的地址：0x00409077p = 0x00409077sizeof(c1) = 1sizeof(good) = 5总结：字符常量是用单引号括起来的一个字符，相当于一个整形值，可以参与表达式的运算；字符串常量是用双引号括起来的若干个字符，代表的是一个地址值，即该字符串在内存中存放的位置。字符常量只占用1字节，而字符串常量占若干字节，至少占用一个字节(&apos;\0&apos;结束标志)。 42. 字符数组和字符串的本质差别(内存分配角度) 字符数组char a[] = “linux”,定义了一个数组a,数组a占6个字节，等号右边的”linux”本身仅存在于编译器中，编译器将它用来初始化字符数组a之后就丢弃掉了(内存中是没有字符串”linux”的)，相当于是:char a[] = {‘l’,’i’,’n’,’u’,’x’,’\0’};共占6字节。 字符串char *p = “linux”;定义一个字符指针p,p占4字节，分配到栈上面；与此同时定义了字符串”linux”分配在代码段上，然后将代码段中的字符串的首地址赋值给指针p。共占10字节。 43. 结构体成员的访问方式：常见的(“.成员名”或者”-&gt;成员名”);底层实现的方式，这里重点讲底层实现原理。 12345678910111213141516171819202122232425262728293031323334struct A&#123; char a; int b; double c;&#125;;main: struct A a; a.a = &apos;A&apos;; a.b = 5; a.c = 12.34; printf(&quot;sizeof(a) = %d\n&quot;,sizeof(a)); char *pc = (char *)&amp;a; printf(&quot;%c\n&quot;,*pc); printf(&quot;***************************\n&quot;); int *pi = (int *)((int)&amp;a+4); printf(&quot;%d\n&quot;,*pi); int *pi2 = (int *)(int(&amp;a+4)-60);//加4相当于加4*sizeof(a)=64 printf(&quot;%d\n&quot;,*pi2); printf(&quot;***************************\n&quot;); double *pd = (double *)((int)&amp;a+8); printf(&quot;%.2lf\n&quot;,*pd); double *pd2 = (double*)(int(&amp;a+8)-120);//加8相当于加8*sizeof(a)=128 printf(&quot;%.2lf\n&quot;,*pd2);运行结果：sizeof(a) = 16A***************************55***************************12.3412.34总结：我们平时使用的&quot;.成员名&quot;或者&quot;-&gt;成员名&quot;的方式访问成员，其实是编译器对其做了封装的，底层的实现原理其实是这样子的(是比较麻烦的)。 44. 关于结构体成员对齐问题：(这是一个很大的坑，最好点到为止) 一般类型： 12345678910111213141516171819202122#pragma pack(4) //设置4字节对齐 //#pragma pack(2) 设置2字节对齐struct A&#123; char a; //1-&gt;2 //1-&gt;2 short b; //2-&gt;2 //2-&gt;2 int c; //4-&gt;4 //4-&gt;4 double d; //8-&gt;8 共计16 //8-&gt;8 共计16&#125;;struct A2&#123; char a; //1-&gt;4 //1-&gt;2 int b; //4-&gt;4 //4-&gt;4 short c; //2-&gt;4 //2-&gt;2 double d; //8-&gt;8 共计20 //8-&gt;8 共计16&#125;;struct A3&#123; char a; //1-&gt;4 //1-&gt;2 double b; //8-&gt;8 //8-&gt;8 short c; //2-&gt;4 //2-&gt;2 int d; //4-&gt;4 共计20 //4-&gt;4 共计16&#125;; 总结：现象一：char有时候是”1-&gt;2”，而有一些时候是”1-&gt;4”什么原因导致的呢？short有时候是”2-&gt;2”，而有一些时候是”2-&gt;4”，这又是什么原因导致的呢？答：这是一个非常考验语言总结能力的一次组织语言，写出来我都不一定完全懂。 在4字节对齐的情况下： 当char类型成员后面的成员类型是short时，short占2字节，要尽量的确保char占字节数与short保持接近；2 = 1 + 1 当char类型成员的成员类型为int时，int占4字节，要尽量的确保char占字节数与int保持接近；4 = 1 + 3 当char类型成员是double时，double占8字节，要尽量的确保char占字节数与double保持接近，但是，这里是4字节对齐的情况，所以说4 = 1 + 3 在2字节对齐的情况下： 当char类型后面是short类型时，short占2字节，要尽量的确保char占字节数与short保持接近；2 = 1 + 1 当char类型后面是int类型时，int占4字节，要尽量的确保char占字节数与int保持接近，因为我们这里是2字节对齐的情况，所以说，2 = 1 + 1 当char类型后面是double类型时，double占8字节，要尽量的确保char类型占字节数与double保持接近，但是我们这里是2字节对齐的情况，所以说，2 = 1 + 1 同理呢，short所遵守的规则是和char类型是一模一样的。 嵌套类型： 123456789101112131415161718192021#pragma pack(4)typedef struct A&#123; char a; //1-&gt;4 int b; //4-&gt;4 double c; //8-&gt;8 共计16&#125;sa;struct B&#123; int a; //4-&gt;4 char b; //1-&gt;4 sa s; //13-&gt;16 short c; //2-&gt;4 共计28&#125;;struct C&#123; char a; //1-&gt;4 int b; //4-&gt;4 char c[15]; //15-&gt;16 共计24&#125;; 最后，2个关于结构体内存对齐，小知识点： 第1：static修饰的结构体成员是不占用内存空间的。 第2：空的结构体占用1字节大小的内存空间。 45. 1关于__attribute__((packed))和__attribute__((aligned(n)))的使用，暂且混个脸熟。 1234567891011121314struct A&#123; char a; //1-&gt;4 int b; //4-&gt;4 short c; //2-&gt;4 double d; //8-&gt;8 共计15(4字节对齐时，20字节)&#125;__attribute__((packed));结果分析：(1)加上__attribute__((packed))和我们#pragma pack(1)----#pragma pack()的效果是一样的。关于__attribute__((packed))这个玩意的使用效果，亲测与传说中所谓的平台是有关联的。在QT编辑器中，__attribute__((packed))它是不起任何的效果的，而换到Ubuntu中相同的代码__attribute__((packed))这个玩意才真正的起到效果。(2)而__attribute__((aligned(n)))这个东西与#pragma pack(n) 所起到的效果是有点相似的。不同的是#pragma pack(n)是对结构体各元素设置n字节对齐，而它是对整个结构体设置成为n字节对齐方式。意思就是说：譬如，__attribute__((aligned(1024)))；结构体成员内部的数据该按照几字节对齐、还按照它原来的几字节去对齐，而整个结构体是按照1024字节对齐。也就是4+4+4+8+填充(1024-(4+4+4+8))。 怎么样设置不对齐的访问呢？ 要在想要设置的那一些结构体的区间加上: 1234#pragma pack(1)......#pragma pack() 那，要想设置在这一块区域中n字节对其呢，只需要将”1”替换成为”n”即可实现。 46. 12345678910111213141516#define offsetof(TYPE,MEMBER) ((int) &amp;((TYPE *)0)-&gt;MEMBER)struct A&#123; char a; //1-&gt;4 int b; //4-&gt;4&#125;;main:int cnt;cnt = offsetof(struct A,b);printf(&quot;cnt = %d\n&quot;,cnt);运行结果：4分析：(TYPE *)0 将0强转成(TYPE *)，0指向了该结构体((TYPE *)0)-&gt;MEMBER 利用指针引用结构体成员的方式访问MEMBER成员&amp;(((TYPE *)0)-&gt;MEMBER)取该MEMBER成员的地址，最后将该地址强转为int目的：已知结构体中某一个元素和整个结构体的类型，求该元素与结构体首地址之间的偏移量。 2018-5-14 20:21:48刚刚电脑再一次黑屏、导致这一些东西又要重新写。我揣测是VMWare中的Ubuntu14.04版本与电脑不兼容所导致的，我又下载了一个Ubuntu16.04版本的。 记得记得记得，没事就按Ctrl+S，百利而无一害呀。 47. 关于typeof的理解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//demo 1 定义指针类型int a = 5;typeof(int *) pi = &amp;a;printf(&quot;&amp;a = %p\n&quot;,&amp;a);printf(&quot;pi = %p\n&quot;,pi);printf(&quot;a = %d\n&quot;,a);printf(&quot;*pi = %d\n&quot;,*pi);运行结果：&amp;a = 0x7ffe9296ed3cpi = 0x7ffe9296ed3ca = 5*pi = 5//demo 2 定义整形1. 简单的整形int *p = NULL;typeof(*p) a = 5;printf(&quot;a = %d\n&quot;,a);运行结果：a = 52. 结合函数指针数组定义的整形int add(int a,int b)&#123; return a+b;&#125;int sub(int a,int b)&#123; return a-b;&#125;int mul(int a,int b)&#123; return a*b;&#125;main：int (*fpa[4])(int a,int b) = &#123;add,sub,mul&#125;;typeof(fpa[0](1,1)) a = 12;typeof(fpa[1](1,1)) b = 34;typeof(fpa[2](1,1)) c = 56;printf(&quot;a=%d\tb=%d\tc=%d\n&quot;,a,b,c);运行结果：a=12 b=34 c=56//demo 3 定义数组int i = 0;int *p = NULL;typeof(*p) array[4] = &#123;1,2,3,4&#125;;for(i = 0;i &lt; 4;i++)&#123; printf(&quot;array[%d] = %d\n&quot;,i,array[i]) ;&#125;运行结果：array[0] = 1array[1] = 2array[2] = 3array[3] = 4//demo 4 定义字符串数组int i = 0;typeof(typeof(char *) [4]) pa = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;&#125;;for(i=0;i&lt;4;i++)&#123; printf(&quot;pa[%d] = %s\n&quot;,i,pa[i]) ;&#125;运行结果：pa[0] = onepa[1] = twopa[2] = threepa[3] = four//demo 5 结合#define,定义字符串数组#define pointer(T) typeof(T *) #define array(T, N) typeof(T[N])main:int i = 0;array(pointer(char),4) pc = &#123;&quot;one&quot;,&quot;two&quot;,&quot;three&quot;,&quot;four&quot;&#125;;//pointer(char)-&gt;typeof(char *) array(char *,4)-&gt;typeof(char *[4])for(i = 0;i &lt; 4;i++)&#123; printf(&quot;pc[%d] = %s\n&quot;,i,pc[i]) ;&#125;运行结果：pc[0] = onepc[1] = twopc[2] = threepc[3] = four//demo 6 linux源码摘录#define min(x,y) (&#123;typeof(x) _x=(x);typeof(y) _y=(y);(void) (&amp;_x==&amp;_y);_x&lt;_y?_x:_y;&#125;)main:float tmp ;tmp = min(1.2,3.4);printf(&quot;tmp = %f\n&quot;,tmp);运行结果：tmp = 1.200000解析：typeof(x) _x = (x);typeof(y) _y = (y);min()函数可以接受任何类型的参数(void)(&amp;_x == &amp;_y);使用指针类型来做比较，当两个指针类型不一致时，编译器就会给出相应的警告信息。总结：typeof就是用来获取变量的数据类型的。 48. 关于container_of宏： 12345678910111213141516171819#define container_of(ptr,type,member) (&#123; \ const typeof(((type *)0)-&gt;member) *__mptr = (ptr);\(type *) ((char *) __mptr - offsetof(type,member));&#125;)struct A&#123; int a; char b; double c;&#125;;main:struct A a;struct A *pa = NULL;char *pc = &amp;a.b;pa = container_of(pc,struct A,b);printf(&quot;pa = %p\n&quot;,pa);printf(&quot;&amp;a = %p\n&quot;,&amp;a);运行结果：pa = 0x7fff63258bb0&amp;a = 0x7fff63258bb0 关于container_of宏作用：通过结构体变量中某一个成员的首地址，从而获取整个结构体变量的首地址。 container_of(ptr,type,member) ptr:指向结构体成员的指针 type:整个结构体的类型 member:结构体中的数据成员 49. 关于共用体union 123456789101112131415161718192021222324252627282930struct S&#123; int a; char b;&#125;;union U&#123; int a; char b;&#125;;main:struct S s;union U u;s.a = 5;u.a = 5;printf(&quot;s.b = %d\n&quot;,s.b);printf(&quot;u.b = %d\n&quot;,u.b);printf(&quot;&amp;s.a = %p\t&amp;s.b = %p\n&quot;,&amp;s.a,&amp;s.b);printf(&quot;&amp;u.s = %p\t&amp;u.b = %p\n&quot;,&amp;u.a,&amp;u.b);printf(&quot;sizeof(s) = %d\n&quot;,sizeof(s));printf(&quot;sizeof(u) = %d\n&quot;,sizeof(u));运行结果：s.b = 0u.b = 5&amp;s.a = 0xbfb4e558 &amp;s.b = 0xbfb4e55c&amp;u.s = 0xbfb4e554 &amp;u.b = 0xbfb4e554sizeof(s) = 8sizeof(u) = 4分析：结构体变量a和b两者的地址是一样的，也就是它们是指向了同一块内存空间。当访问结构体成员a时，就按照int类型来解析这一段内存空间；当访问结构体成员b时，就按照char类型来解析这一段内存空间。 50. 关于大小端的概念 早起呢，在串口通信中，一次只可以发送一个字节，而当我们发送一个int类型的数据时，是先发送Byte0 Byte1 Byte2 Byte3呢，还是Byte3 Byte2 Byte1 Byte0呢？这就是通信中的大小端问题。 现在我们所讲的大小端问题指的是计算机存储系统的大小端问题。 1234567891011121314151617181920212223242526//采用union方式测试大小端union U&#123; int a; char b;&#125;;void endian(int data)&#123; if(data == 1) &#123; printf(&quot;小端模式\n&quot;); &#125; else &#123; printf(&quot;大端模式\n&quot;); &#125;&#125;main:union U u;u.a = 1;endian(u.b);运行结果：小端模式//采用指针方式测试大小端int a = 12345678;printf(&quot;%d\n&quot;,*(char *)&amp;a);运行结果：78 bit … … 7654 3210 每4bit为1组 小端 模式 7 8 大端 4 3 2 1 51. 枚举 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//demo 1 枚举类型的定义和枚举变量的声明分开来enum DAY&#123; Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday,&#125;;main:enum DAY d;d = Monday;switch(d)&#123; case Monday: printf(&quot;Today is Monday\n&quot;);Monday += 1;break; case Tuesday: printf(&quot;Today is Tuesday\n&quot;);Tuesday += 1;break; case Wednesday: printf(&quot;Today is Wednesday\n&quot;);Wednesday += 1;break; case Thursday: printf(&quot;Today is Thursday\n&quot;);Thursday += 1;break; case Friday: printf(&quot;Today is Friday\n&quot;);Friday += 1;break; case Saturday: printf(&quot;Today is Saturday\n&quot;);Saturday += 1;break; case Sunday: printf(&quot;Today is Sunday\n&quot;);Sunday += 1;break; default: break;&#125;运行结果：Today is Monday当d = Tuesday时，便会打印出Today is Tuesday//demo2 typedef的使用typedef enum workday //用workday代替enum workday&#123; Monday, Tuesday, Wednsday, Thursday, Friday, Saturday, Sunday,&#125;workday;main:workday w;w = Sunday;printf(&quot;w = %d\n&quot;,w);运行结果：w = 6 最后，在虚拟机中我把”加速3D图形”这一个选项给取消掉，目的是希望不要在我使用虚拟机的时候电脑给我突然地黑屏掉了，但愿如此。取消了之后，虚拟机开机变得很快的呢。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>标签</tag>
      </tags>
  </entry>
</search>
