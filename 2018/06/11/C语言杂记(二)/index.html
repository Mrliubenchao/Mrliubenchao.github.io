<!DOCTYPE html>



  





<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C语言," />










<meta name="description" content="1. 预处理  从最开始的源程序到最后的可执行程序的过程： 工具：预处理器编译器        汇编器        链接器 过程：预处理    编译        汇编        链接 对应文件：    (.i文件/源文件)(.s/汇编文件)    (.o/目标 文件)        (.elf/可执行文件)   上面的预处理器、编译器、汇编器、链接器再加上一些额外的可能会使用到的工具，合起">
<meta name="keywords" content="C语言">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言杂记(二)">
<meta property="og:url" content="http://yoursite.com/2018/06/11/C语言杂记(二)/index.html">
<meta property="og:site_name" content="lbc&#39;Blogs">
<meta property="og:description" content="1. 预处理  从最开始的源程序到最后的可执行程序的过程： 工具：预处理器编译器        汇编器        链接器 过程：预处理    编译        汇编        链接 对应文件：    (.i文件/源文件)(.s/汇编文件)    (.o/目标 文件)        (.elf/可执行文件)   上面的预处理器、编译器、汇编器、链接器再加上一些额外的可能会使用到的工具，合起">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-06-11T11:57:08.682Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C语言杂记(二)">
<meta name="twitter:description" content="1. 预处理  从最开始的源程序到最后的可执行程序的过程： 工具：预处理器编译器        汇编器        链接器 过程：预处理    编译        汇编        链接 对应文件：    (.i文件/源文件)(.s/汇编文件)    (.o/目标 文件)        (.elf/可执行文件)   上面的预处理器、编译器、汇编器、链接器再加上一些额外的可能会使用到的工具，合起">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/06/11/C语言杂记(二)/"/>





  <title>C语言杂记(二) | lbc'Blogs</title>
  








</head>




<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lbc'Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">生活不止眼前的苟且,还有诗和远方。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/11/C语言杂记(二)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="刘本超">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://ss0.bdstatic.com/7Ls0a8Sm1A5BphGlnYG/sys/portrait/item/a02079656172e58898e5b08fe4ba8cb386">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lbc'Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C语言杂记(二)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-11T18:32:22+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C语言/" itemprop="url" rel="index">
                    <span itemprop="name">C语言</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/11/C语言杂记(二)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2018/06/11/C语言杂记(二)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2018/06/11/C语言杂记(二)/" class="leancloud_visitors" data-flag-title="C语言杂记(二)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  25,309
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  107
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>1.</p>
<p>预处理</p>
<ul>
<li><p>从最开始的源程序到最后的可执行程序的过程：</p>
<p>工具：预处理器编译器        汇编器        链接器</p>
<p>过程：预处理    编译        汇编        链接</p>
<p>对应文件：    (.i文件/源文件)(.s/汇编文件)    (.o/目标 文件)        (.elf/可执行文件)</p>
</li>
</ul>
<p>上面的预处理器、编译器、汇编器、链接器再加上一些额外的可能会使用到的工具，合起来叫做编译工具链。gcc就是一个编译工具链。</p>
<ul>
<li>预处理器存在的目的：帮助编译器做一些编译之前的杂碎的事，让编译器的功能聚焦。</li>
<li>常见的预处理操作：</li>
</ul>
<p>(1).  头文件包含</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;与#include &quot;a.h&quot;两种形式。带&quot;&lt;&gt;&quot;与带&quot; &quot;两类。</span><br></pre></td></tr></table></figure>
<p>&lt;&gt;    第一点：专门用来包含系统提供的头文件的，也就是说这一些头文件是系统自带的，非程序员自己写的。第二点：C语言编译器只会到系统指定的目录，也就是编译器中配置好的目录中去寻找这个头文件，隐含的意思是说不回去到当前的目录下面寻找。假如找不到，那就会提示这个头文件不存在。譬如说。Linux中，所有的头文件都在/usr/include该目录下面存放着的。第三点：我们自己写的头文件也是可以使用&lt;&gt;来包含的，这种情况是：自己写了一个专门存放头文件的目录，将来在编译时使用-I参数来指定相应的目录。</p>
<p>“ “    系统会默认的先从当前目录寻找相应的头文件，假如找不到则再去系统所指定的目录下面寻找。</p>
<p>头文件包含真正意义：在与处理阶段，将#include “a.h”这一行，将a.h这个头文件里面的内容原地展开、替换掉#include “a.h”这一句语句。</p>
<p>(2).    注释。</p>
<p>这预处理阶段，预处理器会拿掉程序中所有的注释语句，到了编译阶段以后程序中其实已经是没有注释了的。</p>
<p>(3).    条件编译</p>
<p>有时候程序希望可以有多种配置，我们在源代码编写时写好了各种的配置的代码，然后给它一个配置开关，然后在源码中修改配置开关来让程序可以编译出来不同的效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		#ifdef的使用</span><br><span class="line">#define TRUE 0		//这里无论为0，还是1，下面输出的结果是一样的，只要有定义。</span><br><span class="line">main:</span><br><span class="line">#ifdef TRUE</span><br><span class="line">	printf(&quot;#define TRUE is exit\n&quot;);</span><br><span class="line">#else</span><br><span class="line">	printf(&quot;#define TRUE is not exit\n &quot;);</span><br><span class="line">#endif	</span><br><span class="line">运行结果：#define TRUE is exit</span><br><span class="line">//demo 2		#ifdef的进一步使用，使用宏定义实现条件编译。</span><br><span class="line">#define DEBUG</span><br><span class="line">#undef	DEBUG</span><br><span class="line"></span><br><span class="line">#ifdef	DEBUG</span><br><span class="line">#define debug(x)		printf(x)</span><br><span class="line">#else</span><br><span class="line">#define debug(x)</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">main:</span><br><span class="line">debug(&quot;This is a debug info\n&quot;);</span><br><span class="line">运行结果：当使用&quot;#define DEBUG&quot;时，输出打印信息；当使用&quot;#undef DEBUG&quot;时无信息输出。</span><br><span class="line">//demo 3		#if的使用</span><br><span class="line">#define TRUE	1	//这里当TRUE定义为1时，打印第一句，否则打印第二句。</span><br><span class="line">main:</span><br><span class="line">#if (TRUE == 1)</span><br><span class="line">	printf(&quot;TRUE is 1\n&quot;);</span><br><span class="line">#else</span><br><span class="line">	printf(&quot;TRUE is 0\n&quot;);</span><br><span class="line">#endif</span><br><span class="line">运行结构：TRUE is 1</span><br><span class="line">需要注意：无论是#ifdef---#endif还是#if---#endif使用时一定要配对使用的。</span><br></pre></td></tr></table></figure>
<p>(4).    宏定义</p>
<p>定义：宏定义就是原封不动的替换。</p>
<p>注意：使用宏定义时，是不可以吝啬使用”()”这个玩意的，以免引起不必要的错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		1年中多少秒</span><br><span class="line">#define SEC_PER_YEAR	(365*24*60*60UL)/*之所以加UL原因：保证在不同的设备上，都可以保证不会因为int的位数，而导致的溢出问题。*/</span><br><span class="line">main:</span><br><span class="line">unsigned int a = SEC_PER_YEAR;</span><br><span class="line">printf(&quot;a = %u\n&quot;,a);		//%u以无符号整数的形式打印输出</span><br><span class="line">运行结果：a = 31536000</span><br><span class="line">总结：</span><br><span class="line">我们平时写的int a;此时编译器默认把当做a是一个有符号数。而当我们明确的写出unsigned int时，此时才是一个无符号的整数。8个二进制位，所能表示的无符号数范围：0~255；有符号数的范围-128~+127，当做结论记住这个规律。</span><br><span class="line">//demo 2		关于#define与typedef在预处理中的作用</span><br><span class="line">在源文件中</span><br><span class="line">#define pChar	char *		//顺口溜&quot;红富士&quot;来记忆</span><br><span class="line">typedef int *	pInt;</span><br><span class="line">main:</span><br><span class="line">char a = &apos;A&apos;;</span><br><span class="line">int b = 5;</span><br><span class="line">pChar pc = &amp;a;</span><br><span class="line">pInt pi = &amp;b;</span><br><span class="line">printf(&quot;*pc = %c\n&quot;,*pc);</span><br><span class="line">printf(&quot;*pi = %d\n&quot;,*pi);</span><br><span class="line">运行结果：</span><br><span class="line">*pc = A</span><br><span class="line">*pi = 5</span><br><span class="line">在使用gcc -E a.c -o a.i命令进行预处理以后生成的的.i文件中2处改动。</span><br><span class="line">main函数上面的#define pChar	char*这一句消失了；在main函数中的第3行变成了</span><br><span class="line">char * pc = &amp;a;</span><br><span class="line">总结：实验表明，宏定义的确在预处理阶段已经给搞定了，而typedef定义的是在编译阶段处理的。</span><br><span class="line">//demo 3		带参宏与带参函数得举例</span><br><span class="line">int max_f(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a&gt;b)  </span><br><span class="line">		return a;</span><br><span class="line">	else</span><br><span class="line">		return b;</span><br><span class="line">&#125;</span><br><span class="line">#define max_i(a,b)	(a)&gt;(b)?(a):(b)</span><br><span class="line">main:</span><br><span class="line">int f,i;</span><br><span class="line">f = max_f(1,6);</span><br><span class="line">i = max_i(1,6);</span><br><span class="line">printf(&quot;f = %d\n&quot;,f);</span><br><span class="line">printf(&quot;i = %d\n&quot;,i);</span><br><span class="line">运行结果：</span><br><span class="line">f = 6</span><br><span class="line">i = 6</span><br><span class="line">总结：2者的区别。</span><br><span class="line">(1). 带参宏在预处理阶段被处理的，而函数是在编译阶段处理的。</span><br><span class="line">(2). 带参宏是原地展开，是没有调用开销的，因此效率比较高的；而带参函数不是原地展开的，是跳转执行，然后再返回过来的过程，是有调用开销的，因此效率相对慢。</span><br><span class="line">(3). 宏定义不会做类型检查，返回值也不会附带类型的；而函数是有明确的参数类型与返回值类型的。带参函数编译器会帮助我们做类型检查工作，而当带参宏类型不匹配时，编译时不会报错，但是可能此时实验结果已经是错误的了。</span><br><span class="line">这里很自然的就引入了内联函数inline关键字。</span><br><span class="line">内联函数：兼具函数的类型检查、宏定义的不调用开销，效率高的2个优点。</span><br><span class="line">使用条件：通常一个3~5行代码的函数，可以考虑使用内联函数。</span><br></pre></td></tr></table></figure>
<p>2.</p>
<p>浅谈函数</p>
<p>(1). 函数将来被编译成可执行代码段，变量(主要指全局变量)，经过编译以后变成数据或者在运行时变为数据。基本上，所有的函数都是要有代码和数据的。代码是为了加工数据，而数据必须依赖代码才得以起作用。</p>
<p>(2).  函数的实质，就是数据处理器。函数是程序的一个缩影，函数的参数列表其实是为了给函数输入原材料；函数的返回值以及输出型参数是为了想外部输出目标数据。</p>
<p>(3). 函数载没有被执行时，是位于硬盘当中的，就好比是一台没有开动的机器一样，此时只是占用了一些存储空间但是并不占用资源(CPU+内存)的；而函数的每一次运行，就好比每一次机器开机运行一样，运行时是需要耗费资源(CPU+内存)的，运行时可以对数据加工成为目标数据。函数运行完毕以后，会释放掉之前所占用的资源。</p>
<p>(4). 整个程序的运行其实就是很多个函数相继的、连续的执行的过程。</p>
<p>3.</p>
<p>递归函数</p>
<p>递归的概念：只要是递归函数，那么必须总从：”只有最内的一层函数完成了任务以后，才轮得到它外面的一层函数执行任务。”</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		正常的递归函数简单的实现</span><br><span class="line">int factorial(int a)</span><br><span class="line">&#123;</span><br><span class="line">	if(a == 0&amp;&amp; a &lt; 1)  </span><br><span class="line">		return 1;</span><br><span class="line">	else</span><br><span class="line">		return a*factorial(a-1);</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">int a = 0;</span><br><span class="line">a = factorial(3);</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">运行结果：a = 6</span><br><span class="line">总结：这里意外的出现了由于有符号与无符号数而引出的段错误问题。当factorial(-5),此时会打印出Segmentation fault (core dumped)段错误的提示信息。原因：编译器默认的情况是无符号数，而当我们(a==0&amp;&amp;a&lt;1),此时问题就出在了(a&lt;1)的这个比较上面了。编译器会默认的把-5转化成为无符号数。就是，原先最高位1是符号位，而现在1也是填充了有效的数据位。导致了程序一直处在else处循环的执行，当栈内存耗尽时，就出现了段错误。</span><br><span class="line">写个简单的程序验证一下：</span><br><span class="line">signed int a = -5;		//定义a为有符号数</span><br><span class="line">printf(&quot;a = 0x%x\ta = %u\n&quot;,a,a);</span><br><span class="line">运行结果：a = 0xfffffffb	a = 4294967291</span><br><span class="line">//demo 2		通过一个简单的递归程序，展现递归实现的原理</span><br><span class="line">int factorial(int a)</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;before factorial: a = %d\t&amp;a = %p\n&quot;,a,&amp;a);</span><br><span class="line">	if(a &gt; 1)</span><br><span class="line">		factorial(a - 1);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;factorial is stop，now a = %d\t&amp;a = %p\n&quot;,a,&amp;a);</span><br><span class="line">	printf(&quot;after factorial: a = %d\ta = %p\n&quot;,a,&amp;a);</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">factorial(3);</span><br><span class="line">运行结果：</span><br><span class="line">before factorial: a = 3	&amp;a = 0xbffd8a30</span><br><span class="line">before factorial: a = 2	&amp;a = 0xbffd8a10</span><br><span class="line">before factorial: a = 1	&amp;a = 0xbffd89f0</span><br><span class="line">factorial is stop，now a = 1	&amp;a = 0xbffd89f0</span><br><span class="line">after factorial: a = 1	a = 0xbffd89f0</span><br><span class="line">after factorial: a = 2	a = 0xbffd8a10</span><br><span class="line">after factorial: a = 3	a = 0xbffd8a30</span><br><span class="line">总结:1. 每一级函数都有自己的变量； 2. 每一次函数调用都会有一次返回； 3. 在递归函数中，位于递归函数之前的语句和各级被调用函数具有相同的执行顺序； 4. 在递归函数中，位于递归函数之后的语句和各级被调用函数的顺序相反。5. 必须要有终止递归语句。</span><br><span class="line">//demo 3		菲波那切数列的实现</span><br><span class="line">//菲波那切数列：F(0)=0;F(1)=1;F(n)=F(n-1)+F(n-2),(n&gt;=2)</span><br><span class="line">int Fib(int a)</span><br><span class="line">&#123;</span><br><span class="line">	if(a == 0|| a == 1)  </span><br><span class="line">		return a;</span><br><span class="line">	else if(a &gt;= 2)</span><br><span class="line">		return (Fib(a-1)+Fib(a-2));</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">Fib(3);</span><br><span class="line">运行结果：a = 2</span><br></pre></td></tr></table></figure>
<p>4.</p>
<p>函数库</p>
<p>定义：函数库是一些事先写好了的函数的集合，当我们使用库中的某一个函数时，只需要包含相应的头文件，之后就可以不需要自己写该函数，直接调用该函数即可。</p>
<p>函数库的提供形式：动态链接库与静态链接库</p>
<p>作用：作为参与链接过程的一份子，函数库与编译所生成的目标文件(.obj)，一起生成可执行代码(.exe)。由于，函数库是在此时可参与完成链接操作的，所以说它本身就是一连串的二进制序列。</p>
<p>5.</p>
<p>(接下来的这一些概念，估计要至少记上个10几遍，这样才勉强把文字转化为自己的知识)。</p>
<p>角度1：</p>
<p>静态链接：把静态链接库文件中所使用到的函数代码直接链接进入目标程序，此时程序在运行的时候就不再需要其他的库文件了；</p>
<p>动态链接：把调用的函数所在的文件模块(DLL–动态链接库)——交代了使用的是那一个库文件，和调用函数在文件中的位置等信息链接入目标程序，此时仅仅是相当于把一个真正所需要的实体的一个引子链接进入了目标程序中。当程序运行的时候，再从DDL中通过这个引子来找到相应的函数代码，从而找到函数的实体，从而完成链接的这个动作。</p>
<p>角度2：</p>
<p>静态链接：库中所使用到的函数(指令)都全部的伴随着链接的过程，最终包含在了可执行文件中了。</p>
<p>动态链接：而使用动态链接的方式，库中所要使用到的函数(指令)在伴随着链接的过程中，所生成的可执行程序中并不包含，我们之前所需要的函数的实体，仅仅包含了这个实体的一个索引。</p>
<p>角度3：</p>
<p>站在开发者的角度</p>
<p>作为开发者我们只需要给用户提供库的.h头文件和库文件(是由ar工具将目标文件转化成为静态链接库文件)。客户拿到静态链接库文件(.a)和头文件(.h)时，通过.h文件可以得知函数的原型，然后就可以在自己的程序中直接拿来使用(调用)，在链接时，链接器会自动到.a文件中拿出这个函数所对应的.o文件，然后与自己本身程序所生成的.o文件结合起来，共同的来完成链接过程，最终生成可执行程序。</p>
<p>角度4：</p>
<p>静态链接库由于在链接时将库文件中函数的实体所对应的目标文件，与本身的目标文件一起扮演了链接的过程，所以说，当库文件内容更改时，那么程序将要重新的再执行编译、链接的过程。不利于代码的可维护性。</p>
<p>而动态链接库库文件与可执行文件是分离开来的，并且在运行时或者是加载时才与可执行程序拼凑在一块的，有利于程序的可维护性。</p>
<p>重点语句：动态链接的时机有2个：一个是在载入时动态链接；而另一是在运行时动态链接。</p>
<p>6.</p>
<p>加载：把硬盘上的程序调到内存中的过程。由于软件想要运行必须先加载到内存里面，加载就是把所需要的文件以及信息读取到内存中，一般在启动程序时都伴随着加载的过程。</p>
<p>7.</p>
<p>位置有关码与位置无关码</p>
<p>通俗的例子：教室里面有6排8列一共48个座位。标号分别给编为1-48。分别有甲、乙两人。</p>
<p>位置有关：甲，你坐在1号位置；乙，你坐在8号位置。</p>
<p>​    (拘谨，不需要PC，每一次操作都需要提供特定的地址)</p>
<p>​    位置有关码不依赖于PC，是根据所给定的链接地址，而完成相应的操作的。</p>
<p>位置无关：甲坐在乙的前面。(随意，只要给我一个PC，接下来我就按部就班的走)</p>
<p>​    位置无关码依赖于当前的PC，在PC基础上有条不紊的连续+4操作。</p>
<p>B、BL、MOV都属于位置无关码。</p>
<p>LDR PC,=LABEL等类似的代码都属于位置有关码。</p>
<p>8.</p>
<p>加载地址与运行地址</p>
<p>加载地址<->存储地址，只是说法不同而已。程序保存在NandFlash中的地址。</-></p>
<p>运行地址<->链接地址，只是说法不同而已。程序在SRAM中执行时的地址。</-></p>
<p>当我们从NandFlash启动时，硬件会自动的将NandFlash前xxKB代码拷贝到SRAM中，CPU从SRAM中起始地址处开始执行。</p>
<p>9.</p>
<p>虚拟内存：从硬盘上面划分出来一部分空间来作为内存使用。</p>
<p>假如说虚拟内存对应的有实际的物理内存单元，那么两者的地址一般是不相等的。通过操作系统的某一种内存管理和映射技术，可以建立虚拟内存与实际物理内存之间的对应关系，当程序员在访问虚拟地址是会自动的转化成为另一个实际的物理地址。</p>
<p>10.</p>
<p>什么是进程？</p>
<p>在操作系统中运行的程序，它是操作系统资源管理的最小的单位。进程是一个动态的实体，它是程序的一次执行过程。进程与程序的区别在于：进程是动态的，程序是静止的，进程是正在运行的程序，而程序是一些保存在硬盘上的一些可执行代码。</p>
<p>进程由3部分组成：代码段、数据段、堆栈段，也就是进程 = 程序段+数据段+进程控制块PCB。而代码段、数据段、bss段的内容是可执行文件中所对应的内容。</p>
<p>PCB进程控制块是进程存在的惟一的标识，操作系统通过PCB的存在而感知到进程的存在。进程控制块是通过一个名字叫做task_struct的结构体实现的，存在的主要目的是操作系统通过PCB对进程进行管理以及调度。进程与PCB是一一对应的关系。</p>
<p>每当创建一个进程时，便在内存中申请一个task_struct的结构体来表示。</p>
<p>总结：</p>
<p>加载程序时并不是把这些程序的内容从可执行程序中填充到内存当中，而是将它们的信息(基地址、长度)更新到PCB进程控制块(task_struct)中，当CPU第一次实际寻址执行时，会触发缺页中断，操作系统在这个过程中会再将实际的内容从可执行文件中复制内容到内存中去。</p>
<p>11.</p>
<p>编程中遇到十进制数与十六进制数相加时的处理方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int a = 0x1234;</span><br><span class="line">a = a + 12;</span><br><span class="line">printf(&quot;a = 0x%x\n&quot;,a);		//以十六进制方式打印</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);		//以十进制方式打印</span><br><span class="line">运行结果：</span><br><span class="line">a = 0x1240</span><br><span class="line">a = 4672</span><br><span class="line">总结：当十六进制数与十进制数相加时，要么统一的都换算成为十六进制数来计算，OK；要么都换算成十进制来计算也是OK的。总之，就是要化成统一的形式来计算。</span><br></pre></td></tr></table></figure>
<p>12.</p>
<p>关于返回值为指针和返回值为数组名的理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">char *returnStr()</span><br><span class="line">&#123;</span><br><span class="line">	char *p = &quot;Good Morning&quot;;  	//编译时&quot;Good Morning&quot;的值就已经确定了(ROData)</span><br><span class="line">	return p;</span><br><span class="line">&#125;</span><br><span class="line">char *returnArray()</span><br><span class="line">&#123;</span><br><span class="line">	char arr[] = &quot;hello world&quot;;	//运行时初始化&quot;hello world&quot;的值才确定(栈)</span><br><span class="line">	return arr;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *pS = NULL;</span><br><span class="line">char *pA = NULL;</span><br><span class="line">pS = returnStr();</span><br><span class="line">pA = returnArray();</span><br><span class="line">printf(&quot;pS = %s\n&quot;,pS);</span><br><span class="line">printf(&quot;pA = %s\n&quot;,pA);</span><br><span class="line">运行结果：</span><br><span class="line">pS = Good Morning</span><br><span class="line">Segmentation fault (core dumped)</span><br><span class="line">问题：</span><br><span class="line">什么导致了段错误的发生？解释原因。</span><br><span class="line">答：函数returnStr中p虽然是局部变量，被分配在栈上面，它的作用域是整个returnStr函数内部。但是它所指向的&quot;Good Morning&quot;是存放在只读数据段(ROData)中的，直到整个程序结束以后才会被销毁掉的。这也就意味着，我们在main函数中来引用这个指针里面的内容是有意义的。而returnArray函数中arr是一个数组名，被分配到栈上面，&quot;hello world&quot;作为数组中的各个元素值放进数组中，一点returnArray函数退出，栈中的这一块内存也就随之被释放掉了。而在main函数种，虽然说同样的返回了一个地址，但是这个地址所指向的存储区域已经失去了意义了，故，引发了段错误的发生。</span><br></pre></td></tr></table></figure>
<p>13.</p>
<p>关于局部变量的地址排序有规则嘛？讨论</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//demo 1</span><br><span class="line">int a;</span><br><span class="line">int b;</span><br><span class="line">printf(&quot;&amp;a = %p\n&quot;,&amp;a);</span><br><span class="line">printf(&quot;&amp;b = %p\n&quot;,&amp;b);//运行结果：&amp;a = 0xbf8a3428	&amp;b = 0xbf8a342c</span><br><span class="line">//demo 2</span><br><span class="line">double a;</span><br><span class="line">int b ;</span><br><span class="line">printf(&quot;&amp;a = %p\n&quot;,&amp;a);</span><br><span class="line">printf(&quot;&amp;b = %p\n&quot;,&amp;b);//运行结果：&amp;a = 0xbfc319c8	&amp;b = 0xbfc319c4</span><br><span class="line">从实验结果观察、加上网上的查询结果暂且如下：</span><br><span class="line">局部变量在栈上面的排列顺序取决于编译器，也就是说随机的。一般来讲，当两个数据类型相同的变量时，地址排序是按照递增的方式进行排布的。</span><br></pre></td></tr></table></figure>
<p>14.</p>
<p>memcpy函数</p>
<p>原型：void <em>memcpy(void </em>dest, const void *src, size_t n)</p>
<p>作用：把src所指向的内存单元中的内容复制n字节带des所指向的内存单元中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		对memcpy函数的简单使用</span><br><span class="line">char *p = &quot;Good Morning&quot;;</span><br><span class="line">char buf[1024];</span><br><span class="line">strcpy(buf,memcpy(buf,p,15));</span><br><span class="line">printf(&quot;buf = %s\n&quot;,buf);</span><br><span class="line">运行结果：buf = Good Morning</span><br><span class="line">//demo 2		对memcpy函数的实现</span><br><span class="line">void *_memcpy(void *des,const void *src,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  char *d = des;</span><br><span class="line">  const char *s = src;</span><br><span class="line">  while(cnt--)</span><br><span class="line">  &#123;</span><br><span class="line">    *d++ = *s++;</span><br><span class="line">  &#125;</span><br><span class="line">  return des;</span><br><span class="line">&#125;</span><br><span class="line">main：</span><br><span class="line">char *p = &quot;Good Morning&quot;;</span><br><span class="line">char buf[1024];</span><br><span class="line">strcpy(buf,_memcpy(buf,p,15));</span><br><span class="line">printf(&quot;buf = %s\n&quot;,buf);</span><br><span class="line">运行结果：</span><br><span class="line">buf = Good Morning</span><br></pre></td></tr></table></figure>
<p>15.</p>
<p>memmove函数</p>
<p>原型：void <em>memmove(void </em>dest, const void *src, size_t n)通过man手册查知</p>
<p>作用：与memcpy函数一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		简单使用memmove函数</span><br><span class="line">char *p = &quot;hello world&quot;;</span><br><span class="line">char buf[100];</span><br><span class="line">strcpy(buf,memmove(buf,p,11));</span><br><span class="line">printf(&quot;buf = %s\n&quot;,buf);</span><br><span class="line">运行结果：buf = hello world</span><br><span class="line">//demo 2		自己实现memmove函数</span><br><span class="line">void *_memmove(void *des,const void *src,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">	char *d = NULL;</span><br><span class="line">	const char *s = NULL;</span><br><span class="line">	if(des&gt;src+cnt || src&gt;des)</span><br><span class="line">	&#123;</span><br><span class="line">      d = des;</span><br><span class="line">      s = src;</span><br><span class="line">      while(cnt--)</span><br><span class="line">      &#123;</span><br><span class="line">      *d++ = *s++;</span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">      d = (des+cnt-1);</span><br><span class="line">      s = (src+cnt-1);</span><br><span class="line">      while(cnt--)</span><br><span class="line">      &#123;</span><br><span class="line">        *d-- = *s--;</span><br><span class="line">      &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return des;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *p = &quot;hello world&quot;;</span><br><span class="line">char buf[1024];</span><br><span class="line">strcpy(buf,_memmove(buf,p,strlen(p)));</span><br><span class="line">printf(&quot;buf = %s\n&quot;,buf);</span><br><span class="line">运行结果：buf = hello worldd��</span><br><span class="line">总结：理解好以下几点。</span><br><span class="line">第一，void _memmove(void *des,const void *src,int cnt),形式参数中的void *理解</span><br><span class="line">void test(void *a,void *b)</span><br><span class="line">&#123;</span><br><span class="line">	if(a&gt;b)</span><br><span class="line">		printf(&quot;address a is larger than b\n&quot;);</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;address a is smaller than b\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">int a = 2,b = 5;</span><br><span class="line">test(&amp;a,&amp;b);</span><br><span class="line">运行结果：address a is smaller than b</span><br><span class="line">第二，if(des&gt;src+cnt || src&gt;des)，这里涉及到一个小小的逻辑问题。des地址的大小满足src地址的大小+偏移量cnt，就不会发生重叠问题。</span><br><span class="line">第一反应的理解：src&gt;des,此时也是可以保证不会发生重叠的，但是src+cnt&gt;des，就不一定可以保证的哟。这里有一种&quot;比最大的值要大，小要比最小的值要小&quot;的味道，哈哈哈。</span><br><span class="line">第二反应的理解：看到一篇博客后，发现上面的第一反应是有错误的，&quot;src&gt;des&quot;此时，是有可能发生内存重叠的情况的。当des追上src的屁股尾巴以后，此时就发生了重叠问题。</span><br><span class="line">另外，只要把不发生重叠的这两种情况给理解好了，发生重叠的两种情况也就很好理解了。</span><br><span class="line">第三，strcpy(buf,_memmove(buf,p,strlen(p)));这句代码的理解。</span><br><span class="line">起初时，我写成buf = _memmove(buf,p,strlen)但是实践验证得知，是行不通的。这里面使用strcpy来给buf赋值时最好用的方法。</span><br><span class="line">第四，d = (des+cnt-1),s = (src+cnt-1)在else的src与des有重叠时，复制数据时要从高地址处开始复制地址。</span><br><span class="line">//demo 3	采用自己写的_memmove函数，访问结构体成员</span><br><span class="line">struct Stu</span><br><span class="line">&#123;</span><br><span class="line">  char name[20];</span><br><span class="line">  int age;</span><br><span class="line">&#125;;</span><br><span class="line">main:</span><br><span class="line">struct Stu st;</span><br><span class="line">char *p = &quot;Good Morning&quot;;</span><br><span class="line">strcpy(st.name,_memmove(st.name,p,strlen(p)));</span><br><span class="line">printf(&quot;st.name = %s\n&quot;,st.name);</span><br><span class="line">运行结果：st.name = Good Morning��u�</span><br></pre></td></tr></table></figure>
<p>总结：memcpy与memmove函数的主要区别：memmove是在memcpy之上做了进一步的改善工作，memcpy不可以处理src与des之间内存重叠的问题，而memmove函数可以。</p>
<p>16.</p>
<p>memset函数</p>
<p>函数原型：void <em>memset(void </em>s, int c, size_t n)    man手册查询得知</p>
<p>作用：将以s指向的内存单元的n字节填充为c,常用于内存空间的初始化,多用于清空数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//demo 1	简单演示用法</span><br><span class="line">char arr[] = &quot;abcdefg&quot;;</span><br><span class="line">memset(arr,&apos;A&apos;,sizeof(arr));</span><br><span class="line">printf(&quot;arr = %s\n&quot;,arr);</span><br><span class="line">memset(arr,0,sizeof(arr));</span><br><span class="line">printf(&quot;arr = %s\n&quot;,arr);</span><br><span class="line">运行结果：</span><br><span class="line">arr = AAAAAAAA</span><br><span class="line">arr = </span><br><span class="line">//demo 2	清除结构体变量中的内容</span><br><span class="line">struct Stu</span><br><span class="line">&#123;</span><br><span class="line">	char name[1024];</span><br><span class="line">	int age;</span><br><span class="line">&#125;;</span><br><span class="line">main:</span><br><span class="line">struct Stu st;</span><br><span class="line">strcpy(st.name,&quot;auto man&quot;);</span><br><span class="line">st.age = 12;</span><br><span class="line">printf(&quot;st.name = %s\n&quot;,st.name);</span><br><span class="line">printf(&quot;st.age = %d\n&quot;,st.age);</span><br><span class="line">memset(&amp;st,0,sizeof(st));</span><br><span class="line">printf(&quot;st.name = %s\n&quot;,st.name);</span><br><span class="line">printf(&quot;st.age = %d\n&quot;,st.age);</span><br><span class="line">运行结果：</span><br><span class="line">st.name = auto man</span><br><span class="line">st.age = 12</span><br><span class="line">st.name = </span><br><span class="line">st.age = 0</span><br><span class="line">总结：写这个程序时遇到的问题：结构体成员变量是数组时的赋值如何操作？</span><br><span class="line">一开始我想到的是st.name=&quot;auto man&quot;可是编译时就给报错。解决的方法就是使用strcpy这个神器，即可轻松地搞定。</span><br><span class="line">//demo 3	对memset函数的实现</span><br><span class="line">void *_memset(void *s,int val,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  if(s == NULL|| cnt &lt; 0)</span><br><span class="line">  	return 0;</span><br><span class="line">  char *ret = s;</span><br><span class="line">  while(cnt--)</span><br><span class="line">  &#123;</span><br><span class="line">    *ret++ = val;</span><br><span class="line">  &#125;</span><br><span class="line">  return ret;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char arr[] = &quot;I am a good student&quot;;</span><br><span class="line">printf(&quot;%s\n&quot;,arr);</span><br><span class="line">_memset(arr,0,sizeof(arr));</span><br><span class="line">printf(&quot;%s\n&quot;,arr);</span><br><span class="line">运行结果：</span><br><span class="line">p = I am a good student</span><br><span class="line">p =</span><br></pre></td></tr></table></figure>
<p>17.</p>
<p>memcmp函数</p>
<p>原型：int memcmp(const void <em>s1, const void </em>s2, size_t n);</p>
<p>作用：比较内存区域s1与s2的前n个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		memcmp简单使用</span><br><span class="line">int a = 0;</span><br><span class="line">const char *p = &quot;hello world&quot;;</span><br><span class="line">const char *q = &quot;hello earth&quot;;</span><br><span class="line">a = memcmp(p,q,7);</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">a = memcmp(p,q,10);</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">运行结果：</span><br><span class="line">a = 1</span><br><span class="line">a = 1</span><br><span class="line">实验结果：想要验证的是两者第7个字符&apos;w&apos;和&apos;e&apos;，以及第10个字符&apos;l&apos;和&apos;t&apos;的大小比较。</span><br><span class="line">但是实验的结果却显示都是a = 1.得出的结论是，当我们想比较第10个字符时，但是第10个字符之前一旦遇到有不相等的字符出现时，后面的字符的大小它将不会去理会了。</span><br><span class="line">//demo 2	memcmp的简单实现</span><br><span class="line">int _memcmp(const void *s1,const void *s2,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  const char *str1 = s1;</span><br><span class="line">  const char *str2 = s2;</span><br><span class="line">  while(cnt != 0&amp;&amp;*str1 == *str2)</span><br><span class="line">  &#123;</span><br><span class="line">    str1++;</span><br><span class="line">    str2++;</span><br><span class="line">    cnt--;</span><br><span class="line">  &#125;</span><br><span class="line">  if(cnt == 0)</span><br><span class="line">  &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  return (*str1)&gt;*(str2)?1:-1;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">int a = 0;</span><br><span class="line">char *p = &quot;hello world&quot;;</span><br><span class="line">char *q = &quot;hello earth&quot;;</span><br><span class="line">a = _memcmp(p,q,7);</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">运行结果：a = 1</span><br></pre></td></tr></table></figure>
<p>18.</p>
<p>memchr函数</p>
<p>原型：void <em>memchr(const void </em>s, int c, size_t n);</p>
<p>作用：s指向的字符串的前n个字节中，搜索第一次出现字符c的位置。若找到返回找到的这个字符的地址；若没有找到则返回NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		简单的使用</span><br><span class="line">char *p = &quot;hello world&quot;;</span><br><span class="line">char *q = NULL;</span><br><span class="line">q = memchr(p,&apos;w&apos;,5);</span><br><span class="line">if(q == NULL)</span><br><span class="line">  printf(&quot;search failed\n&quot;);</span><br><span class="line">else</span><br><span class="line">  printf(&quot;search success\n&quot;);</span><br><span class="line">运行结果：</span><br><span class="line">search failed</span><br><span class="line">//demo 2		更进一步理解参数列表中的void *s是什么意思</span><br><span class="line">const char *p = &quot;hello world&quot;;</span><br><span class="line">const char *q = NULL;</span><br><span class="line">q = memchr(p,&apos;o&apos;,12);</span><br><span class="line">if(q == NULL)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;search error\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;search success\n&quot;);</span><br><span class="line">  printf(&quot;the start:%p\tthe end:%p\tthe sub:%x\n&quot;,p,q,q-p);</span><br><span class="line">  printf(&quot;the contents from %p is %s\n&quot;,q,q);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">search success</span><br><span class="line">the start:0x80485c0	the end:0x80485c4	the sub:4</span><br><span class="line">the contents from 0x80485c4 is: o world</span><br><span class="line">//demo 3		对memchr函数的实现</span><br><span class="line">void *_memchr(const void *s,int c,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  const char *pTmp= s;</span><br><span class="line">  char *pReturn = NULL;</span><br><span class="line">  if(cnt&gt;0 &amp;&amp; s!=NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    while(cnt)</span><br><span class="line">    &#123;</span><br><span class="line">      if(*pTmp == c)</span><br><span class="line">      &#123;</span><br><span class="line">        pReturn = pTmp;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      pTmp++;</span><br><span class="line">      cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return pReturn;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：main函数利用demo 2中的代码，再匹配上我们自己实现的_memchr()函数，即可实现一模一样的效果。</span><br><span class="line">在书写demo 3的这一部分代码时，出现的疑惑还是蛮多的，这里给它一一的记录下来。</span><br><span class="line">第一点：充分的理解break在if、while、if嵌套的比较复杂的语境中的执行顺序。慎用自增、自减的运算符在有break的循环语句中。(自己遇到这种情况时，最好拆开一个一个的写)</span><br><span class="line">int a = 5;</span><br><span class="line">if(a &gt; 0)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;I am count %d\n&quot;,a);</span><br><span class="line">  while(a--)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;start: Now I am count %d\n&quot;,a);</span><br><span class="line">    if(a == 1)</span><br><span class="line">    &#123;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;End: Now I am count %d\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">I am count 5</span><br><span class="line">start: Now I am count 4</span><br><span class="line">start: Now I am count 3</span><br><span class="line">start: Now I am count 2</span><br><span class="line">start: Now I am count 1</span><br><span class="line">End: Now I am count 1</span><br><span class="line">第二点：充分理解break、和continue的使用</span><br><span class="line">//使用break的情况</span><br><span class="line">int a = 0;</span><br><span class="line">for(a=0;a&lt;5;a++)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;start:a = %d\n&quot;,a);</span><br><span class="line">  if(a == 2)</span><br><span class="line">  &#123;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;End:a = %d\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">start:a = 0</span><br><span class="line">End:a = 0</span><br><span class="line">start:a = 1</span><br><span class="line">End:a = 1</span><br><span class="line">start:a = 2</span><br><span class="line">//使用continue的情况</span><br><span class="line">int a = 0;</span><br><span class="line">for(a=0;a&lt;5;a++)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;start:a = %d\n&quot;,a);</span><br><span class="line">  if(a == 2)</span><br><span class="line">  &#123;</span><br><span class="line">    continue;</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;End:a = %d\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">start:a = 0</span><br><span class="line">End:a = 0</span><br><span class="line">start:a = 1</span><br><span class="line">End:a = 1</span><br><span class="line">start:a = 2</span><br><span class="line">start:a = 3</span><br><span class="line">End:a = 3</span><br><span class="line">start:a = 4</span><br><span class="line">End:a = 4</span><br><span class="line">总结：当continue作为循环体的一部分时，一旦遇到continue时，立即结束本次循环，跳过循环体中尚未执行的部分，接着执行是否要继续执行的条件判断。</span><br><span class="line">而break作为循环体的一部分时，一旦遇到break立即退出当前的循环体，接着执行循环体之后的语句。</span><br></pre></td></tr></table></figure>
<p>19.</p>
<p>昨天晚上，偶遇一道C语言题目，并且自己独立的解决掉了，收获蛮多的，特此记录下来。</p>
<p>2018-5-23 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//原始题目</span><br><span class="line">void get_memory(char *p)</span><br><span class="line">&#123;</span><br><span class="line">  p = (char *)malloc(1024);</span><br><span class="line">  strcpy(p,&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void free_memroy(char *p)</span><br><span class="line">&#123;</span><br><span class="line">  free(p);</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *str;</span><br><span class="line">get_memroy(str);</span><br><span class="line">printf(&quot;%s\n&quot;,str);</span><br><span class="line">free_memroy(str);</span><br><span class="line">运行结果：</span><br><span class="line">*** Error in `./a.out&apos;: free(): invalid pointer: 0xb77ae000 ***</span><br><span class="line">Aborted (core dumped)</span><br><span class="line">//版本1		利用二重指针实现</span><br><span class="line">void get_memroy(char **p)</span><br><span class="line">&#123;</span><br><span class="line">  *p = (char*)malloc(1024);</span><br><span class="line">  strcpy(*p,&quot;Hello World&quot;);</span><br><span class="line">&#125;</span><br><span class="line">void free_memroy(char *p)</span><br><span class="line">&#123;</span><br><span class="line">  free(p);</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *str;</span><br><span class="line">get_memroy(&amp;str);</span><br><span class="line">printf(&quot;%s\n&quot;,str);</span><br><span class="line">free_memroy(str);</span><br><span class="line">运行结果：</span><br><span class="line">Hello World</span><br><span class="line">//版本2		利用设置一个中间变量作为返回值来实现</span><br><span class="line">void *get_memroy(char *p)</span><br><span class="line">&#123;</span><br><span class="line">  char *pReturn = NULL;</span><br><span class="line">  p = (char *)malloc(1024);</span><br><span class="line">  pReturn = strcpy(p,&quot;Hello World&quot;);</span><br><span class="line">  free(p);</span><br><span class="line">  return pReturn;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *pTmp;</span><br><span class="line">char *str;</span><br><span class="line">pTmp = get_memroy(str);</span><br><span class="line">printf(&quot;%s\n&quot;,pTmp);</span><br><span class="line">运行结果：Hello World</span><br><span class="line">从版本1与版本2两个版本得出一个疑惑，为什么当传二重指针时，free内存就没有问题，而一级指针时就出现了问题呢？</span><br><span class="line">答：自己总结、感悟出来的。</span><br><span class="line">第一点：</span><br><span class="line">char *p = (char *)malloc(1024);</span><br><span class="line">p = p + 1;</span><br><span class="line">free(p);</span><br><span class="line">运行结果：Segmentation fault (core dumped)</span><br><span class="line">总结：在使用malloc时，malloc的是谁？那么我们就应该free谁。在中间过程中是不可以另外的赋值的。</span><br><span class="line">第二点：</span><br><span class="line">当我们传的是二级指针即p或者是&amp;str时，get_memory函数结束以后只是二级指针对一级指针的指向断掉了，而一级指针还是任然的存在的。而当我们传递的是一级指针时，get_memory函数结束以后一级指针对字符串的指向断掉了，此时还free一级指针时，就会报错。</span><br></pre></td></tr></table></figure>
<p>20.</p>
<p>对二重指针的初步理解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		</span><br><span class="line">void dPointer(char **p)</span><br><span class="line">&#123;</span><br><span class="line">  *p = &quot;change value success&quot;;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *p = &quot;Hello world&quot;;</span><br><span class="line">dPointer(&amp;p);</span><br><span class="line">printf(&quot;%s\n&quot;,p);</span><br><span class="line">运行结果：change value success</span><br><span class="line">//demo 2</span><br><span class="line">void dPointer(char **p)</span><br><span class="line">&#123;</span><br><span class="line">  *p = (char *)malloc(1024);//这里强调、二级指针和一级指针本质是一模一样的，	                        //也是一个指针，只不过它里面存储的值是一个一级的指针而已。</span><br><span class="line">  strcpy(*p,&quot;change value success&quot;)</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *p = &quot;Good Morning&quot;;</span><br><span class="line">dPointer(&amp;p);</span><br><span class="line">printf(&quot;%s\n&quot;,p);</span><br><span class="line">运行结果：change value success</span><br></pre></td></tr></table></figure>
<p>21.</p>
<p>strcpy函数</p>
<p>原型：char <em>strcpy(char </em>dest, const char *src);</p>
<p>作用：将src起始地址开始且含有’\0’结束符的字符串复制到以dest开始的地址空间。返回值的类型为char*型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		strcpy把字符串复制到数组中</span><br><span class="line">char arr[1024];</span><br><span class="line">strcpy(arr,&quot;Hello world&quot;);</span><br><span class="line">printf(&quot;%s\n&quot;,arr);</span><br><span class="line">运行结果：Hello world</span><br><span class="line">//demo 2		strcpy把字符串复制到指针变量所指向的内存单元中，指针--malloc</span><br><span class="line">char *p = (char *)malloc(1024);</span><br><span class="line">strcpy(p,&quot;Hello world&quot;);</span><br><span class="line">printf(&quot;%s\n&quot;,p);</span><br><span class="line">运行结果：Hello world</span><br><span class="line">特殊案例：</span><br><span class="line">char *p;</span><br><span class="line">strcpy(p,&quot;Hello world&quot;);</span><br><span class="line">运行结果：Segmentation fault (core dumped)</span><br><span class="line">总结:p未被初始化，所以&quot;Hello world&quot;字符串有可能被赋值到任何的地方，因而触发的段错误。</span><br><span class="line">//demo 3	对strcpy函数的简单实现</span><br><span class="line">char *_strcpy(char *dest,const char *src)</span><br><span class="line">&#123;</span><br><span class="line">  char *pReturn = dest;</span><br><span class="line">  if(dest==NULL || src==NULL)</span><br><span class="line">  	return 0;</span><br><span class="line">  while((*dest++ = *src++)!= &apos;\0&apos;);</span><br><span class="line">  return pReturn;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *p = (char *)malloc(1024);</span><br><span class="line">_strcpy(p,&quot;Hello world&quot;);</span><br><span class="line">printf(&quot;%s\n&quot;,p);</span><br><span class="line">运行结果：</span><br><span class="line">Hello world</span><br><span class="line">//demo 4		对strcpy函数做进一步的了解</span><br><span class="line">char p[] = &quot;abcdefgh&quot;;</span><br><span class="line">char q[] = &quot;ABCD&quot;;</span><br><span class="line">_strcpy(p,q);</span><br><span class="line">printf(&quot;%s\n&quot;,p);</span><br><span class="line">运行结果：ABCD</span><br><span class="line">解释：我们都知道strcpy()函数赋值字符串时是连带&apos;\0&apos;一起都赋值过来的。这就是问题的根本所在。</span><br><span class="line">须知点：printf函数在遇到第一个&apos;\0&apos;时，就会停止往外输出。</span><br><span class="line">char *p = &quot;Hello\nworld\n&quot;;</span><br><span class="line">char *q = &quot;Hello\n\0world\n&quot;;</span><br><span class="line">printf(&quot;%s\n&quot;,p);</span><br><span class="line">printf(&quot;%s\n&quot;,q);</span><br><span class="line">运行结果：</span><br><span class="line">Hello</span><br><span class="line">world</span><br><span class="line">Hello</span><br><span class="line"></span><br><span class="line">看到这里以后，再回过头来看上面的调用strcpy函数打印出来的信息也就不足为怪了。</span><br></pre></td></tr></table></figure>
<p>22.</p>
<p>strncpy函数</p>
<p>函数原型：char <em>strncpy(char </em>dest, const char *src, size_t n);</p>
<p>作用：将字符串src中最多n个字符复制到字符数组dest中，返回指向dest的指针。</p>
<p>它在复制过程中相比strcpy()有2个终止条件，1. 当遇到’\0’是终止复制    2. 当复制到了第n个字符，此时还没有赋值完时也会自动的终止。</p>
<p>首先给函数中涉及到的3个长度，起3个名字。</p>
<p>n    :指定长度</p>
<p>strlen(src)    :源长度</p>
<p>strlen(dest)    :目标长度</p>
<p>特点：</p>
<ol>
<li>当指定长度小于源长时，将源长中按指定长度拷贝到目标字符串，此时不包括’\0’</li>
<li>当指定长度大于源长时，将源长全部拷贝到目标字符串，(指定长度-源长)这么长空间使用’\0’来作为填充</li>
<li>当指定长度大于目标长度时，由于会产生数组越界，故会产生报错”<strong><em> stack smashing detected </em></strong>: ./a.out terminated  Aborted (core dumped)”</li>
</ol>
<p>补充一点：NULL与’\0’是等价的验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">char arr[1024] = &#123;NULL,NULL,NULL&#125;;</span><br><span class="line">printf(&quot;arr[0] = %c\n&quot;,arr[0]);</span><br><span class="line">printf(&quot;arr[0] = %d\n&quot;,arr[0]);</span><br><span class="line">运行结果：</span><br><span class="line">arr[0] = </span><br><span class="line">arr[0] = 0</span><br><span class="line">char arr[1024] = &#123;&apos;\0&apos;,&apos;\0&apos;,&apos;\0&apos;&#125;;</span><br><span class="line">printf(&quot;arr[0] = %c\n&quot;,arr[0]);</span><br><span class="line">printf(&quot;arr[0] = %d\n&quot;,arr[0]);</span><br><span class="line">运行结果：</span><br><span class="line">arr[0] = </span><br><span class="line">arr[0] = 0</span><br></pre></td></tr></table></figure>
<p>接下来使用一个一个的demo来理解strncpy函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		指定长度小于源长度</span><br><span class="line">char a[20] = &quot;abcde fghij&quot;;</span><br><span class="line">char b[20] = &quot;ABCDE&quot;;</span><br><span class="line">strncpy(a,b,2);</span><br><span class="line">printf(&quot;%s\n&quot;,a);</span><br><span class="line">运行结果：ABcde fghij</span><br><span class="line">//demo 2		指定长度等于源长度</span><br><span class="line">char a[20] = &quot;abcde fghij&quot;;</span><br><span class="line">char b[20] = &quot;ABCDE&quot;;</span><br><span class="line">strncpy(a,b,5);</span><br><span class="line">printf(&quot;%s\n&quot;,a);</span><br><span class="line">运行结果：ABCDE fghij</span><br><span class="line">//demo 3		指定长度大于源长度</span><br><span class="line">char a[20] = &quot;abcde fghij&quot;;</span><br><span class="line">char b[20] = &quot;ABCDE&quot;;</span><br><span class="line">strncpy(a,b,6);</span><br><span class="line">printf(&quot;%s\n&quot;,a);</span><br><span class="line">运行结果：ABCDE</span><br><span class="line">//demo 4		对strncpy函数的简单实现，版本1</span><br><span class="line">char *_strncpy(char *dest,const char *src,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  char *pReturn = dest;</span><br><span class="line">  while(cnt &amp;&amp; (*dest = *str)!=&apos;\0&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    dest++;</span><br><span class="line">    src++;</span><br><span class="line">    cnt--;</span><br><span class="line">  &#125;</span><br><span class="line">  while(cnt--)</span><br><span class="line">  &#123;</span><br><span class="line">    *dest++ = &apos;\0&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//demo 5	   对strncpy函数的简单实现，版本2</span><br><span class="line">char *_strncpy(char *dest,const char *src,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  int offset = 0;</span><br><span class="line">  char *pReturn = dest;</span><br><span class="line">  while(!(src!=NULL &amp;&amp;dest!=NULL));</span><br><span class="line">  if(cnt &gt; strlen(src))</span><br><span class="line">  &#123;</span><br><span class="line">    offset = cnt-strlen(src);</span><br><span class="line">    cnt = strlen(src);</span><br><span class="line">  &#125;</span><br><span class="line">  while(cnt--)</span><br><span class="line">  &#123;</span><br><span class="line">    *dest++ = *src++;</span><br><span class="line">  &#125;</span><br><span class="line">  while(offset--)</span><br><span class="line">  &#123;</span><br><span class="line">    *dest++ = &apos;\0&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  return pReturn;</span><br><span class="line">&#125;</span><br><span class="line">注意点：在&quot;if(cnt&gt;strlen(src))&quot;这个判断中，是不可以写成为&quot;if(cnt-strlen(src))&gt;0&quot;</span><br><span class="line">这一种形式的，假如写成为是这样子的话，就会报段错误。</span><br><span class="line">原因：cnt-strlen(src)之差是一个负数，相当于一个有符号数，它自动的转化成为无符号数。你想，此时把那个负数的最高位1，转成了实打实的无符号数，那么条件就会一直的成立，因此会出现段错误的情况。</span><br><span class="line">//demo 6		这是我们通常容易犯的错误的一种写法，但是是错误的。</span><br><span class="line">char *_strncpy(char *dest,const char *src,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  char *pReturn = dest;</span><br><span class="line">  while(!(src!=NULL &amp;&amp; dest!=NULL));</span><br><span class="line">  while(cnt--)</span><br><span class="line">  &#123;</span><br><span class="line">    *dest++ = *src++;</span><br><span class="line">  &#125;</span><br><span class="line">  return pReturn;</span><br><span class="line">&#125;</span><br><span class="line">问题出在：当指定长度大于源长度时，这份代码是没有做处理的。</span><br></pre></td></tr></table></figure>
<p>23.</p>
<p>strcat函数</p>
<p>函数原型：char <em>strcat(char </em>dest, const char *src);</p>
<p>函数作用：将src指向的字符串内容追加到dest所指向的字符串的后面，dest末尾的’\0’将会被覆盖掉，所以，’\0’这东西要自己添加上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		strcat函数简单的使用</span><br><span class="line">char a[20] = &quot;abcde fghij&quot;;</span><br><span class="line">char b[20] = &quot;ABCDE&quot;;</span><br><span class="line">strcat(a,b);</span><br><span class="line">printf(&quot;%s\n&quot;,a);</span><br><span class="line">运行结果：abcde fghijABCDE</span><br><span class="line">//demo 2		strcat函数简单的实现</span><br><span class="line">char *_strcat(char *dest,const char *src)</span><br><span class="line">&#123;</span><br><span class="line">  char *pReturn = dest;</span><br><span class="line">  if(dest==NULL || src==NULL)</span><br><span class="line">  	return 0;</span><br><span class="line">  while(*dest != &apos;\0&apos;)</span><br><span class="line">  	dest++;</span><br><span class="line">  while((*dest++ = *src++)!=&apos;\0&apos;);</span><br><span class="line">  *dest = &apos;\0&apos;;</span><br><span class="line">  return pReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>24.</p>
<p>strncat函数</p>
<p>函数原型：char <em>strncat(char </em>dest, const char *src, size_t n);</p>
<p>函数作用：把src指向的前n个字符追加到dest的末尾，dest末尾的’\0’将会被覆盖掉，所以，自己要给添加上去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		strncat函数简单的使用</span><br><span class="line">char a[20] = &quot;abcde fghij&quot;;</span><br><span class="line">char b[20] = &quot;ABCDE&quot;;</span><br><span class="line">strcat(a,b,2);</span><br><span class="line">printf(&quot;%s\n&quot;,a);</span><br><span class="line">运行结果：abcde fghijAB</span><br><span class="line">//demo 2		strncat函数的简单实现</span><br><span class="line">char *_strncat(char *dest,const char *src,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  char *pReturn = dest;</span><br><span class="line">  if(dest==NULL || src==NULL || cnt&lt;0)</span><br><span class="line">  	return 0;</span><br><span class="line">  while(*dest != &apos;\0&apos;)</span><br><span class="line">  	dest++;</span><br><span class="line">  for(i=0;i&lt;cnt;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    *dest++ = *src++;</span><br><span class="line">  &#125;</span><br><span class="line">  *dest = &apos;\0&apos;;</span><br><span class="line">  return pReturn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>25.</p>
<p>strcmp函数</p>
<p>函数原型：int strcmp(const char <em>s1, const char </em>s2);</p>
<p>函数作用：比较两个字符串s1、s2,当s1&gt;s2时，返回1；当s1&lt;s2时，返回-1；当s1=s2时返回0 。以遇到的第一个字符判断条件成立的为标准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//demo 1</span><br><span class="line">int _strcmp(const char *s1,const char *s2)</span><br><span class="line">&#123;</span><br><span class="line">  int ret;</span><br><span class="line">  while(!(ret=*s1-*s2) &amp;&amp; *s2!=&apos;\0&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    s1++;</span><br><span class="line">    s2++;</span><br><span class="line">  &#125;</span><br><span class="line">  if(ret&gt;0)</span><br><span class="line">  	return 1;</span><br><span class="line">  else if(ret&lt;0)</span><br><span class="line">  	return -1;</span><br><span class="line">  else</span><br><span class="line">  	return 0;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">int ret;</span><br><span class="line">char a[20] = &quot;abcde fghij&quot;;</span><br><span class="line">char b[20] = &quot;abcde fghik&quot;;</span><br><span class="line">ret = _strcmp(a,b);</span><br><span class="line">printf(&quot;%d\n&quot;,ret);</span><br><span class="line">运行结果：-1</span><br></pre></td></tr></table></figure>
<p>26.</p>
<p>strncmp函数</p>
<p>函数原型：int strncmp(const char <em>s1, const char </em>s2, size_t n);</p>
<p>函数作用：比较s1与s2字符串的大小，比较的个数为n个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//demo 1</span><br><span class="line">int _strncmp(const char *s1,const char *s2,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  int i,ret;</span><br><span class="line">  for(i=0;i&lt;cnt;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    while(!(ret=*s1-*s2) &amp;&amp; *s2!=&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">      s1++;</span><br><span class="line">      s2++;</span><br><span class="line">    &#125;</span><br><span class="line">    if(ret&gt;0)</span><br><span class="line">       return 1;</span><br><span class="line">    else if(ret&lt;0)</span><br><span class="line">      return -1;</span><br><span class="line">    else</span><br><span class="line">      return 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">int ret;</span><br><span class="line">char a[20] = &quot;abcde fghij&quot;;</span><br><span class="line">char b[20] = &quot;azcde fghij&quot;;</span><br><span class="line">ret = _strncmp(a,b,2);</span><br><span class="line">printf(&quot;%d\n&quot;,ret);</span><br><span class="line">运行结果：-1</span><br></pre></td></tr></table></figure>
<p>27.</p>
<p>strdup函数</p>
<p>函数原型：char <em>strdup(const char </em>s);</p>
<p>函数功能：将字符串拷贝到新建的位置处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		strdup函数的简单使用</span><br><span class="line">char *p = &quot;Hello world&quot;;</span><br><span class="line">char *q;</span><br><span class="line">q = strdup(p);</span><br><span class="line">printf(&quot;%s\n&quot;,q);</span><br><span class="line">运行结果：Hello world</span><br><span class="line">//demo 2		strdup函数的简单实现</span><br><span class="line">char *_strdup(const char *s)</span><br><span class="line">&#123;</span><br><span class="line">  if(s==NULL)</span><br><span class="line">  	return 0;</span><br><span class="line">  char *pReturn =(char *)malloc(strlen(s)+1);</span><br><span class="line">  strcpy(s,pReturn);</span><br><span class="line">  return pReturn;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *p = &quot;Hello world&quot;;</span><br><span class="line">char *q;</span><br><span class="line">q = _strdup(p);</span><br><span class="line">printf(&quot;%s\n&quot;,q);</span><br><span class="line">运行结果：</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>
<p>28.</p>
<p>strndup函数</p>
<p>函数原型：char <em>strndup(const char </em>s, size_t n);</p>
<p>函数作用：将字符串s的前n字节拷贝到新的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		strndup函数的简单使用</span><br><span class="line">char *p = &quot;Hello world&quot;;</span><br><span class="line">char *q;</span><br><span class="line">q = strndup(p,5);</span><br><span class="line">printf(&quot;%s\n&quot;,q);</span><br><span class="line">运行结果：Hello</span><br><span class="line">//demo 2		strndup函数的简单实现</span><br><span class="line">char *_strndup(const char *s,int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  if(s==NULL || cnt&lt;0)</span><br><span class="line">  	return 0;</span><br><span class="line">  char *pReturn = (char *)malloc(cnt+1);</span><br><span class="line">  strncpy(pReturn,s,cnt);</span><br><span class="line">  return pReturn;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char *p = &quot;Hello world&quot;;</span><br><span class="line">char *q;</span><br><span class="line">q = strndup(p,5);</span><br><span class="line">printf(&quot;%s\n&quot;,q);</span><br><span class="line">运行结果：Hello</span><br></pre></td></tr></table></figure>
<p>29.</p>
<p>strchr函数</p>
<p>函数原型：char <em>strchr(const char </em>s, int c);</p>
<p>函数作用：查找字符串s中首次出现c的位置，并且返回给位置处的指针，假如找不到则返回NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		strchr函数的简单使用</span><br><span class="line">char *p = &quot;Hello world&quot;;</span><br><span class="line">char *q;</span><br><span class="line">q = strchr(p,&apos;w&apos;);</span><br><span class="line">printf(&quot;%c\n&quot;,q);</span><br><span class="line">运行结果：world</span><br><span class="line">//demo 2		strchr函数的简单实现</span><br><span class="line">char *_strchr(const char *s,int c)</span><br><span class="line">&#123;</span><br><span class="line">  if(s==NULL || c&lt;0)</span><br><span class="line">  	return 0;</span><br><span class="line">  char *pReturn = s;</span><br><span class="line">  while(!(*pReturn == c) &amp;&amp; *pReturn!=&apos;\0&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    pReturn++;</span><br><span class="line">    if(*pReturn == c)</span><br><span class="line">    	break;</span><br><span class="line">  &#125;</span><br><span class="line">  return pReturn?pReturn:NULL;//pReturn为真则返回pReturn，若为假则返回NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>30.</p>
<p>strstr函数</p>
<p>函数原型：char <em>strstr(const char </em>str1, const char *str2);</p>
<p>函数作用：字符串str2是否是str1的子串，若是，则该函数返回str2在str1中首次出现的地址，若不是则返回NULL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		strstr函数简单的使用</span><br><span class="line">char *p = &quot;Hello world&quot;;</span><br><span class="line">char *q = &quot;wo&quot;;</span><br><span class="line">char *r;</span><br><span class="line">r = strstr(p,q);</span><br><span class="line">printf(&quot;%s\n&quot;,r);</span><br><span class="line">运行结果：world</span><br><span class="line">//demo 2		strstr函数的简单实现</span><br><span class="line">char *_strstr(const char str1,const char *str2)</span><br><span class="line">&#123;</span><br><span class="line">  if(str1==NULL || str2==NULL)</span><br><span class="line">  	return 0;</span><br><span class="line">  while(*str1 != &apos;\0&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    char *p = str1;</span><br><span class="line">    char *q = str2;</span><br><span class="line">    char *pReturn = NULL;</span><br><span class="line">    if(*p==*q)</span><br><span class="line">    &#123;</span><br><span class="line">      pReturn = p;</span><br><span class="line">      while(*p&amp;&amp;*q&amp;&amp;*p==*q)</span><br><span class="line">      &#123;</span><br><span class="line">        p++;</span><br><span class="line">        q++;</span><br><span class="line">      &#125;</span><br><span class="line">      if(*q == &apos;\0&apos;)</span><br><span class="line">      	return pReturn;</span><br><span class="line">    &#125;</span><br><span class="line">    str1++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">总结：这个函数的实现还是有一些难度的。一开始书写时我犯的2个错误。</span><br><span class="line">第一个，将p,q,pReturn这3个指针变量的声明放在了while(*str1!=&apos;\0&apos;)的外面，导致编译、运行时报段错误。原因，p所指向的字符串内容是会随着str++的变化而变化的，是不断在更新值的，假如我们把它放到了while循环的外面，它所指向的从一开始就一直的不变，一直是str1字符串中第一个字符。</span><br><span class="line">第二个，while(*p&amp;&amp;*q&amp;&amp;*p++==*q++),这样书写是不可以的，++自增运算符要写在括号里面。原因，假设*p和*q都成立，而*p==*q不成立时，自增运算符不放在括号时，它仍旧会进行+1操作，这就不是我们所想要的结果了。</span><br><span class="line">总结，像这种库函数是非常的多的，至此先到这里了，花了将近一个星期总结这10多个库函数。</span><br></pre></td></tr></table></figure>
<p>31.</p>
<p>数学库函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//demo 1</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a = 9;</span><br><span class="line">  a = sqrt(a);//这里括号里面要是写&quot;9&quot;,则不会报链接时错误的。</span><br><span class="line">  printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">gcc a.c	</span><br><span class="line">a.c: In function ‘main’:</span><br><span class="line">a.c:10:6: warning: incompatible implicit declaration of built-in function ‘sqrt’ [enabled by default]</span><br><span class="line">  a = sqrt(a);</span><br><span class="line">      ^</span><br><span class="line">/tmp/ccPhSlhz.o: In function `main&apos;:</span><br><span class="line">a.c:(.text+0x19): undefined reference to `sqrt&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">从运行结果看，前面的4行表示&quot;函数未声明&quot;，属于编译时错误。加#include &lt;math.h&gt;即可。</span><br><span class="line">后面的3行，&quot;.text+0x19&quot;属于链接时错误。加gcc a.c -lm即可。这个链接错误表示的是，函数有声明(math.h)、有引用(a.c)，但是没有定义，链接器(ld)找不到函数体。</span><br><span class="line">1. 为什么说链接器(ld)会找不到函数体呢？</span><br><span class="line">答：首先要明确的一点是：链接器(ld)的作用是，到库函数中去搜索到我们所需要的函数。由于库函数的数量实在是太大了，所以链接器(ld)通常的做法是，它会默认的去那几个比较常用的库中去寻找。假如说，我们所需要的函数，它正好不在那几个比较常用的库中，那么需要我们程序员自己特意的指出来(gcc a.c -lm)。</span><br><span class="line">我们这里使用的是数学库，所以用的是&quot;-lm&quot;。假如说使用的是其他的库，那就需要加另外的符号。</span><br><span class="line">2. 使用ldd a.out可以来查看，可执行程序a.out到底使用到了那一些库。</span><br><span class="line">就本例子而言：ldd a.out打印内容：</span><br><span class="line">	linux-gate.so.1 =&gt;  (0xb773b000)</span><br><span class="line">	libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb7575000)</span><br><span class="line">	/lib/ld-linux.so.2 (0xb773c000)</span><br></pre></td></tr></table></figure>
<p>32.</p>
<p>静态链接库的创建并且使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">(一)静态链接库的创建分3步骤：</span><br><span class="line">第一步，新建一个sLib.c和sLib.h文件</span><br><span class="line">sLib.c:</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;void func1()\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int func2(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;int func2(int a,int b)\n&quot;);</span><br><span class="line">  return (a+b);</span><br><span class="line">&#125;</span><br><span class="line">sLib.h:</span><br><span class="line">void func1();</span><br><span class="line">int func2(int a,int b);</span><br><span class="line">第二步，gcc sLib.c -o sLib.o -c(-o指定目标文件，-c只编译、不链接)，生成sLib.o</span><br><span class="line">第三步，ar -rc libsLib.a sLib.o(libsLib.a中lib只固定的，后面sLib.a是静态链接库名)</span><br><span class="line">ar和gcc差不多都只是一个工具，ar是用来生成静态链接库的。</span><br><span class="line">(二)使用刚刚创建的静态链接库</span><br><span class="line">第一步，新建一个main.c，然后将libsLib.a和sLib.h这2个文件和main.c放在同一目录下</span><br><span class="line">main.c:</span><br><span class="line">#include &quot;sLib.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a = 0;</span><br><span class="line">  func1();</span><br><span class="line">  a = func2(5,5);</span><br><span class="line">  printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">第一次编译：gcc main.c</span><br><span class="line">错误信息：/tmp/cc0SMkCk.o: In function `main&apos;:</span><br><span class="line">main.c:(.text+0xa): undefined reference to `func1&apos;</span><br><span class="line">main.c:(.text+0x1e): undefined reference to `func2&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">分析，由&quot;.text&quot;可知该错误属于链接时错误。那是因为func1()和func2()函数是在sLib.a这个库中的，而sLib.a这个库并不是链接器默认寻找的库。故，需要给指出链接器需要寻找的库名。</span><br><span class="line">第二次编译：gcc main.c -lsLib(-l命令指定库名。需要注意这里是-lsLib而不是-lsLib.a噢)</span><br><span class="line">错误信息：/usr/bin/ld: cannot find -lsLib</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">分析，&quot;cannot find -lsLib&quot;说明，链接器去找了，但是没找着。我们需要给它明确的路径，才可以确保链接器可以找得到对应的库。</span><br><span class="line">第三次编译：gcc main.c -lsLib -L.(-L命令指定库的位置。由于我们的sLib.a和main.c在同一目录下，故使用&quot;-L.&quot;)。最终编译通过，没有任何警告信息。</span><br><span class="line">最后，&quot;./a.out&quot;</span><br><span class="line">void func1()</span><br><span class="line">int func2(int a,int b)</span><br><span class="line">a = 10</span><br></pre></td></tr></table></figure>
<p>最后，再安利一个很好用的命令mn,用来查看该静态链接库文件一共包含了几个目标文件，以及每一个目标文件有那一些函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mn libsLib.a		(前面的lib是固定不变的，后面的sLib.a是静态链接库名)</span><br><span class="line">显示结果：</span><br><span class="line">sLib.o:</span><br><span class="line">00000000 T func1</span><br><span class="line">00000014 T func2</span><br><span class="line">         U puts</span><br><span class="line">值得注意的是，这里面细节还是蛮多的，这里是&quot;sLib.a&quot;而上面的一处是&quot;sLib&quot;，细节很多。</span><br></pre></td></tr></table></figure>
<p>33.</p>
<p>动态链接库的创建并且使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">(一)动态链接库的创建</span><br><span class="line">第一步，新建一个dLib.c和dLib.h文件</span><br><span class="line">dLib.c:</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void func1()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;void func1()\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int func2(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;int func2(int a,int b)\n&quot;);</span><br><span class="line">  return (a+b);</span><br><span class="line">&#125;</span><br><span class="line">dLib.h:</span><br><span class="line">void func1();</span><br><span class="line">int func2(int a,int b);</span><br><span class="line">第二步，gcc dLib.c -o dLib.o -c -fPIC(生成目标文件dLib.o,-c只编译不链接，fPIC位置无关码)</span><br><span class="line">第三步，gcc -o libdLib.so dLib.o -shared(libdLib.so中&quot;lib&quot;是固定的，后面一部分是动态链接库名字)，至此，动态链接库已经制作成功。</span><br><span class="line">(二)动态链接库的使用</span><br><span class="line">第一步，新建一个main.c，把libdLib.so和dLib.h这2个文件放在与main函数同一个目录下。</span><br><span class="line">main.c:</span><br><span class="line">#include &quot;dLib.h&quot;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int a = 0;</span><br><span class="line">  func1();</span><br><span class="line">  a = func2(5,5);</span><br><span class="line">  printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">第二步，gcc main.c </span><br><span class="line">/tmp/ccknLm4r.o: In function `main&apos;:</span><br><span class="line">main.c:(.text+0x12): undefined reference to `func1&apos;</span><br><span class="line">main.c:(.text+0x26): undefined reference to `func2&apos;</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">第三步，gcc main.c -ldLib(-l指定动态链接库名，注意这里不是dLib.so哦，而是dLib)</span><br><span class="line">/usr/bin/ld: cannot find -llibdLib</span><br><span class="line">collect2: error: ld returned 1 exit status</span><br><span class="line">第四步，gcc main.c -ldLib -L.(-L指定动态链接库位置)，至此编译没有问题。</span><br><span class="line">第五步，但是./a.out时，出现错误。原因，该程序使用的是动态链接，链接器在使用库时(它不再默认的库存放的目录下面)，是找不到库在那里存放的。因此，需要指定库的位置。</span><br><span class="line">2种方法：</span><br><span class="line">1. 在默认路径/usr/lib，中添加一个libdLib.so文件。即cp libdLib.so /usr/lib，再次执行即可。</span><br><span class="line">2. 使用LD_LIBRARY_PATH指定目录。因为操作系统在加载/usr/lib目录之前，会先到环境变量LD_LIBRARY_PATH该路径下面去寻找，该路径下找不着时，才会到/usr/lib目录下寻找。</span><br><span class="line">具体步骤：</span><br><span class="line">&lt;1&gt;使用pwd命令，查找出libdLib.so的目录，譬如叫做list</span><br><span class="line">&lt;2&gt;export LD_LIBRARY_PATH=list,即可。需要注意的是，&quot;=&quot;的两边是不可以有空格的哦。</span><br><span class="line">最后，</span><br><span class="line">ldd命令可以帮助我们在不需要&quot;./a.out&quot;来预先得知该可执行程序是否出现问题。</span><br><span class="line">具体使用方法：</span><br><span class="line">ldd a.out(export LD_LIBRARY_PATH=)，即环境变量置空。</span><br><span class="line">linux-gate.so.1 =&gt;  (0xb76e5000)</span><br><span class="line">libdLib.so =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/i386-linux-gnu/libc.so.6 (0xb751f000)</span><br><span class="line">/lib/ld-linux.so.2 (0xb76e6000)</span><br><span class="line">上面的&quot;libdLib.so=&gt;not found&quot;表示这里出了问题——找不到libdLib.so库文件。</span><br></pre></td></tr></table></figure>
<p>34.</p>
<p>深入理解结构体</p>
<p>由于关于结构体的代码量有点大，所以代码是边参考、边码字的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		接下来2个代码属于自己可以看得懂写不出来的代码，没事多温习、温习</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">struct Company</span><br><span class="line">&#123;</span><br><span class="line">  int num;</span><br><span class="line">  char name[20];</span><br><span class="line">  float score[30];</span><br><span class="line">  float aver;</span><br><span class="line">&#125;;</span><br><span class="line">void input(struct Company st[]);</span><br><span class="line">struct Company max(struct Company st[]);</span><br><span class="line">void print(struct Company st);</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  struct Company st[3];</span><br><span class="line">  struct Company *p = st;</span><br><span class="line">  input(p);</span><br><span class="line">  print(max(p));</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">void input(struct Company st[])</span><br><span class="line">&#123;</span><br><span class="line">  int i;</span><br><span class="line">  printf(&quot;请依次输入学号、姓名、3科成绩:\n&quot;);</span><br><span class="line">  for(i=0;i&lt;3;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    scanf(&quot;%d %s %f %f %f&quot;,&amp;st[i].num,(char *)&amp;st[i].name,&amp;st[i].score[0],&amp;st[i].score[1],&amp;st[i].score[2]);</span><br><span class="line">    st[i].aver=(st[i].score[0]+st[i].score[1]+st[i].score[2])/3.0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">struct Company max(struct Company st[])</span><br><span class="line">&#123;</span><br><span class="line">  int i,m=0;</span><br><span class="line">  for(i=1;i&lt;3;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    if(st[i].aver&gt;st[m].aver)</span><br><span class="line">    	m=i;</span><br><span class="line">  &#125;</span><br><span class="line">  return st[m];</span><br><span class="line">&#125;</span><br><span class="line">void print(struct Company st)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;成绩最高的同学成绩如下:\n&quot;);</span><br><span class="line">  printf(&quot;学号:%d\n姓名:%s\n3科成绩:%5.1f,%5.1f,%5.1f\n平均成绩:%5.1f\n&quot;, st.num,st.name,st.score[0],st.score[1],st.score[2],st.aver);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">请依次输入学号、姓名、3科成绩:</span><br><span class="line">1 a 12 12 12</span><br><span class="line">2 b 45 45 45</span><br><span class="line">3 c 80 80 80</span><br><span class="line">成绩最高的同学成绩如下:</span><br><span class="line">学号:3</span><br><span class="line">姓名:c</span><br><span class="line">3科成绩: 80.0, 80.0, 80.0</span><br><span class="line">平均成绩: 80.0</span><br><span class="line"></span><br><span class="line">总结：</span><br><span class="line">尽管是边参考代码边自己敲，但是中间还是遇到了不少的问题的。</span><br><span class="line">第一，input函数中scanf(&quot;%d %s %f %f %f&quot;),这其中也是很有讲究的，%d与%f之间是不可以加&quot;,&quot;间隔的，以实现连续输入；而且一开始把后面的&quot;%f&quot;写成了&quot;%d&quot;导致程序运行的结果是错误的。其二，末尾出是不可以加&quot;\n&quot;的，暂且不明白为什么，经过实践可得，加了&apos;\n&apos;之后运行结果是会出现问题的。</span><br><span class="line">第二，注意结构体数组在引用成员时，下标的书写。</span><br></pre></td></tr></table></figure>
<p>深入理解结构体2</p>
<p>同样的由于代码量还是偏大的，所以一边看着一边敲一边。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">//demo 2</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">struct Company</span><br><span class="line">&#123;</span><br><span class="line">  int num;			//工号</span><br><span class="line">  char *tel;		//电话</span><br><span class="line">  int *score;		//积分</span><br><span class="line">&#125;;</span><br><span class="line">struct Social</span><br><span class="line">&#123;</span><br><span class="line">  int id;			//身份证号</span><br><span class="line">  char name[10];	//姓名</span><br><span class="line">  int *age;			//年龄</span><br><span class="line">  struct Company st;</span><br><span class="line">  struct Company *pSt;</span><br><span class="line">  int (*fpAdd)(int a,int b);</span><br><span class="line">  int (*fpSub)(int a,int b);</span><br><span class="line">  int (*fpMult)(int a,int b);</span><br><span class="line">&#125;;</span><br><span class="line">int add(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">  return (a+b);</span><br><span class="line">&#125;</span><br><span class="line">int sub(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">  return (a-b);</span><br><span class="line">&#125;</span><br><span class="line">int mult(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">  return (a*b);</span><br><span class="line">&#125;</span><br><span class="line">void usage(char *p)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;%s &lt;para1&gt; &lt;para2&gt;\n&quot;,p);</span><br><span class="line">&#125;</span><br><span class="line">int cnt=2018,cnt1;</span><br><span class="line">struct Company zhang = &#123;</span><br><span class="line">  .num = 2017,</span><br><span class="line">  .tel = &quot;110&quot;,</span><br><span class="line">  .score = &amp;cnt,</span><br><span class="line">&#125;;</span><br><span class="line">struct Company wang = &#123;</span><br><span class="line">  .num = 2018,</span><br><span class="line">  .tel = &quot;119&quot;,</span><br><span class="line">  .score = &amp;cnt1,</span><br><span class="line">&#125;;</span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  int a,b;</span><br><span class="line">  struct Social boss[] = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      .id = 411302199,</span><br><span class="line">      .name = &quot;小张&quot;,</span><br><span class="line">      .age = &amp;b,</span><br><span class="line">      .st = &#123;</span><br><span class="line">        .num = 111,</span><br><span class="line">        .tel = &quot;110&quot;,</span><br><span class="line">        .score = &quot;666&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      .pSt = &amp;zhang,</span><br><span class="line">      .fpSub = sub,</span><br><span class="line">      .fpMult = mult,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      .id = 411302199,</span><br><span class="line">      .name = &quot;小王&quot;,</span><br><span class="line">      .age = &amp;a,</span><br><span class="line">      .st = &#123;</span><br><span class="line">        .num = 222,</span><br><span class="line">        .tel = &quot;119&quot;,</span><br><span class="line">        .score = &quot;999&quot;,</span><br><span class="line">      &#125;,</span><br><span class="line">      .pSt = &amp;wang,</span><br><span class="line">      .fpAdd = add,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;;</span><br><span class="line">  if(argc != 3)</span><br><span class="line">  &#123;</span><br><span class="line">    usage(argv[0]);</span><br><span class="line">    return -1;</span><br><span class="line">  &#125;</span><br><span class="line">  a = strtoul(argv[1],NULL,0);</span><br><span class="line">  b = strtoul(argv[2],NULL,0);</span><br><span class="line">  printf(&quot;a=%d\tb=%d\n&quot;,a,b);</span><br><span class="line">  </span><br><span class="line">  printf(&quot;boss[0].id=%d\tboss[1].id=%d\n&quot;,boss[0].id,boss[1].id);</span><br><span class="line">  printf(&quot;boss[0].name=%s\tboss[1].id=%s\n&quot;,boss[0].name,boss[1].name);</span><br><span class="line">  printf(&quot;boss[0].age=%d\tboss[1].age=%d\n&quot;,*(boss[0].age),*(boss[1].age));</span><br><span class="line">  </span><br><span class="line">  printf(&quot;boss[0].st.num=%d\n&quot;,boss[0].st.num);</span><br><span class="line">  printf(&quot;boss[0].st.tel=%s\n&quot;,boss[0].st.tel);</span><br><span class="line">  printf(&quot;boss[0].st.score=%d\n&quot;,*(boss[0].st.score));</span><br><span class="line">  </span><br><span class="line">  printf(&quot;boss[0].pSt-&gt;num=%d\n&quot;,boss[0].pSt-&gt;num);</span><br><span class="line">  printf(&quot;boss[0].pSt-&gt;tel=%s\n&quot;,boss[0].pSt-&gt;tel);</span><br><span class="line">  printf(&quot;boss[0].pSt-&gt;score=%d\n&quot;,*(boss[0].pSt-&gt;score));</span><br><span class="line">  </span><br><span class="line">  printf(&quot;a-b=%d\n&quot;,boss[0].fpSub(a,b));</span><br><span class="line">  printf(&quot;a*b=%d\n&quot;,boss[0].fpMult(a,b));</span><br><span class="line">  printf(&quot;a+b=%d\n&quot;,boss[1].fpAdd(a,b));</span><br><span class="line">  </span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">a=10	b=5</span><br><span class="line">boss[0].id=411302199	boss[1].id=411302199</span><br><span class="line">boss[0].name=小张	boss[1].id=小王</span><br><span class="line">boss[0].age=5	boss[1].age=10</span><br><span class="line">boss[0].st.num=111</span><br><span class="line">boss[0].st.tel=110</span><br><span class="line">boss[0].st.score=3552822</span><br><span class="line">boss[0].pSt-&gt;num=2017</span><br><span class="line">boss[0].pSt-&gt;tel=110</span><br><span class="line">boss[0].pSt-&gt;score=2018</span><br><span class="line">a-b=5</span><br><span class="line">a*b=50</span><br><span class="line">a+b=15</span><br><span class="line">总结：</span><br><span class="line">第一，结构体变量定义时使用&quot;;&quot;而结构体变量初始化时使用的是&quot;,&quot;</span><br><span class="line">第二，结构体成员中有结构体变量、结构体变量指针时，对结构体成员的引用</span><br><span class="line">第三，里面涉及了字符串处理函数strtoul()函数，而strtoul()函数的理解，又涉及到二重指针的充分理解，所以接下里会对2着依次做探究。</span><br></pre></td></tr></table></figure>
<p>35.</p>
<p>strtoul函数——string to unsigned long</p>
<p>函数原型：unsigned long int strtoul(const char *str, char **endstr, int base);</p>
<p>函数作用：str要转化的字符串；endstr第一个不能转换的字符的指针；base为str采用的进制。将str按照base进制方式，将字符串str转化为long int型。</p>
<p>使用说明：strtol函数当检测到第一个非法字符时立即停止检测，其后的所有字符都会被当做是非法字符来处理。合法的字符串会被转化成为long int，作为函数的返回值。非法字符串，即第一个非法字符的地址被赋给*endstr(隐含意思：对指针endstr进行了更改操作)，故采用了二重指针传参的手法。</p>
<p>多数情况下，endstr设置为NULL，即不返回非法字符串的地址。文字讲的比较抽象，具体看代码实现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">//demo 1			strtol函数简单使用</span><br><span class="line">char buffer[20]=&quot;10379cend$3&quot;;</span><br><span class="line">char *stop;</span><br><span class="line">printf(&quot;%d\n&quot;,strtol(buffer, &amp;stop, 2));//2-&gt;8-&gt;10-&gt;16运行结果如下</span><br><span class="line">printf(&quot;%s\n&quot;, stop);</span><br><span class="line">运行结果：</span><br><span class="line">      2			8			10		    16(0-f为合法)</span><br><span class="line">      2			543			10379		17005006(字符串中的数字以不同进制的解析，得到十进制数)</span><br><span class="line">      379cend$3	9cend$3		 cend$3		 nd$3</span><br><span class="line">注意：</span><br><span class="line">当base=0，&lt;1&gt;默认以10进制进行转化；&lt;2&gt;字符串是以0x开头,按16进制&lt;3&gt;以0开头按8进制</span><br><span class="line">//demo 2			strtol函数简单实现</span><br><span class="line">#define TOLOWER(x)		(x|(0x20))</span><br><span class="line">unsigned int _base(const char *pStr)</span><br><span class="line">&#123;</span><br><span class="line">  if(pStr[0]==&apos;0&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    if(TOLOWER(pStr[1])==&apos;x&apos;&amp;&amp;isxdigit(pStr[2]))</span><br><span class="line">    	return 16;</span><br><span class="line">    else</span><br><span class="line">    	return 8;</span><br><span class="line">  &#125;</span><br><span class="line">  else </span><br><span class="line">  	return 10;</span><br><span class="line">&#125;</span><br><span class="line">unsigned long _strtoul(const char *str,char **endStr,int base)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned int result = 0;</span><br><span class="line">  if(!base)</span><br><span class="line">  	base = _base(str);</span><br><span class="line">  if(base==16 &amp;&amp; str[0]==&apos;0&apos; &amp;&amp; TOLOWER(str[1])==&apos;x&apos;)</span><br><span class="line">  	str+=2;</span><br><span class="line">  while(isxdigit(*str))</span><br><span class="line">  &#123;</span><br><span class="line">    unsigned int value = 0;</span><br><span class="line">    value = isdigit(*str)?*str-&apos;0&apos;:TOLOWER(*str)-&apos;a&apos;+10;</span><br><span class="line">    result = result*base + value;</span><br><span class="line">    if(value&gt;=base)</span><br><span class="line">    	break;</span><br><span class="line">    str++;</span><br><span class="line">  &#125;</span><br><span class="line">  if(endStr)</span><br><span class="line">  	*endStr=(char *)str;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">unsigned int value = 0;</span><br><span class="line">char *p = &quot;0xf&quot;;</span><br><span class="line">value = _strtoul(p,NULL,0);</span><br><span class="line">printf(&quot;value=%d\n&quot;,value);</span><br><span class="line">运行结果：value=15</span><br><span class="line">总结：</span><br><span class="line">&lt;1&gt;x=x|0x20,这是一种常见的手法，通过加32(0x20)，让大写字母变成为小写字母。</span><br><span class="line">&lt;2&gt;&quot;isdigit(*str)?*str-&apos;0&apos;:TOLOWER(*str)-&apos;a&apos;+10&quot;，0-9则，执行前半部分；a-f则，执行后半部分。</span><br><span class="line">&lt;3&gt;&quot;result=result*base+value&quot;是一种常见的按权相加计算的方法。</span><br><span class="line">&lt;4&gt;if(endStr)	*endStr=(char *)str;这种手法的简介。</span><br><span class="line">&lt;5&gt;isdigit()与isxdigit()函数使用介绍。</span><br></pre></td></tr></table></figure>
<p>36.</p>
<p>关于strtoul函数而延伸出的需要注意的点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		isxdigit()函数简介</span><br><span class="line">char *p = &quot;abcde&quot;;</span><br><span class="line">if(isxdigit(p[0]))</span><br><span class="line">	printf(&quot;this is a amount of 0x\n&quot;);</span><br><span class="line">else</span><br><span class="line">	printf(&quot;this is not a amount of 0x\n&quot;);</span><br><span class="line">运行结果：若&quot;abcde&quot;，则打印：&quot;this is a amount of 0x&quot;;若&quot;zbcde&quot;，则打印:&quot;this is not a amount 0f 0x&quot;</span><br><span class="line">作用：检查字符串中的某个字符是否是16进制，若是返回TRUE。否则返回FAULSE。</span><br><span class="line">//demo 2		if(二重指针)&#123;对一重指针赋值操作&#125;这种手法</span><br><span class="line">char *p = &quot;abcdefg&quot;;</span><br><span class="line">p = 0;</span><br><span class="line">*(p+0) = &apos;A&apos;;</span><br><span class="line">printf(&quot;%c\n&quot;,*(p+0));</span><br><span class="line">运行结果：Segmentation fault (core dumped)</span><br><span class="line">char a = &apos;A&apos;;</span><br><span class="line">char *p = &quot;abcdefg&quot;;</span><br><span class="line">p = &amp;a;</span><br><span class="line">*(p+0) = &apos;A&apos;;</span><br><span class="line">printf(&quot;%c\n&quot;,*(p+0);</span><br><span class="line">运行结果：A</span><br><span class="line">总结以上两组代码：第一组代码指针p=0时，p所指向的内容是不可以更改的；而p!=0时，p所指向的内容是可以更改的。</span><br><span class="line">//demo 3		对二重指针进一步加深理解</span><br><span class="line">&lt;1&gt;一级指针</span><br><span class="line">void func(int *p)</span><br><span class="line">&#123;</span><br><span class="line">  int a=5;</span><br><span class="line">  *p=5;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">int a = 1;</span><br><span class="line">printf(&quot;before:a = %d\n&quot;,a);</span><br><span class="line">func(&amp;a);</span><br><span class="line">printf(&quot;after:a = %d\n&quot;,a);</span><br><span class="line">运行结果：</span><br><span class="line">before:a = 1</span><br><span class="line">after:a = 5</span><br><span class="line">总结：传参数是一级指针，可以更改p所指向的内存单元中的内容。</span><br><span class="line">&lt;2&gt;二级指针</span><br><span class="line">void func(int **p)</span><br><span class="line">&#123;</span><br><span class="line">  int a = 15;</span><br><span class="line">  *p = &amp;a;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">int a = 5;</span><br><span class="line">int *pa = &amp;a;</span><br><span class="line">printf(&quot;before:*pa = %d\n&quot;,*pa);</span><br><span class="line">func(&amp;pa);</span><br><span class="line">printf(&quot;after:*pa = %d\n&quot;,*pa);</span><br><span class="line">运行结果：</span><br><span class="line">before:*pa = 5</span><br><span class="line">after:*pa = 15</span><br><span class="line">总结：传参数二级指针，可以更改指针的指向(p之前指向&quot;a=5&quot;,而后指向&quot;a=15&quot;)，也就是更改了p本身的值。</span><br><span class="line">&lt;3&gt;实现一个函数，在数组arr中查找c，若找到则使用pa返回arr中第一个找到c的地址,否则返回NULL。</span><br><span class="line">void func1(char arr[],char c,char **pa)</span><br><span class="line">&#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  for(i=0;arr[i]!=&apos;\0&apos;;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    if(arr[i]==c)</span><br><span class="line">    &#123;</span><br><span class="line">      *pa=&amp;arr[i];</span><br><span class="line">      printf(&quot;&amp;arr[%d]=%p\n&quot;,i,&amp;arr[i]);</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">    else if(arr[i]==&apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">      *pa=NULL;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">char arr[]=&quot;abcdefg&quot;;</span><br><span class="line">char a = &apos;d&apos;;</span><br><span class="line">char *p = NULL;</span><br><span class="line">func1(arr,a,&amp;p);</span><br><span class="line">if(p!=NULL)</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;查找到了，%c\n&quot;,*p);</span><br><span class="line">  printf(&quot;p=%p\n&quot;,p);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">  printf(&quot;没有查找到！\n&quot;);</span><br><span class="line">运行结果：</span><br><span class="line">&amp;arr[3]=0xbff91c37</span><br><span class="line">查找到了，d</span><br><span class="line">p=0xbff91c37</span><br></pre></td></tr></table></figure>
<p>37.</p>
<p>关于typedef结合const之后的使用情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//demo 1</span><br><span class="line">typedef char *		pChar;</span><br><span class="line">main:</span><br><span class="line">const pChar p = &quot;abcdefg&quot;;</span><br><span class="line">p = p+1;</span><br><span class="line">运行结果：</span><br><span class="line">error: assignment of read-only variable ‘p’</span><br><span class="line">p = p+1;</span><br><span class="line">总结：而把&quot;typedef char*	pChar&quot;换成为&quot;#define pChar char *&quot;，则是正确的。</span><br><span class="line">解析：</span><br><span class="line">现象一：const int a,此时a是不可以改变的；</span><br><span class="line">现象二：const int *p,此时不可改变的是&quot;把类型去掉以后的那一坨东西&quot;，这里指的是&quot;*p&quot;，即p所指向的内容是不可以改变的。</span><br><span class="line">以此类推，const pChar p,pChar是一个类型，因此是可以把pChar去掉的，即const p，即p是不可以改变的，故，p=p+1时，就会报错。</span><br></pre></td></tr></table></figure>
<p>38.</p>
<p>atoi函数</p>
<p>函数原型：int atoi(const char *nptr);</p>
<p>函数作用：将字符串转化成整数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		atoi函数简单使用</span><br><span class="line">int a = 0;</span><br><span class="line">char *p = &quot;1234&quot;;</span><br><span class="line">a = atoi(p);</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">运行结果：a = 1234</span><br><span class="line">//demo 2		atoi函数简单实现</span><br><span class="line">int _atoi(const char *str)</span><br><span class="line">&#123;</span><br><span class="line">  int result=0;</span><br><span class="line">  int flags=0;</span><br><span class="line">  if(*str == &apos; &apos;)</span><br><span class="line">  	str++;</span><br><span class="line">  if(*str==&apos;+&apos;||*str==&apos;-&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    if(*str==&apos;-&apos;)</span><br><span class="line">    	flags = 1;</span><br><span class="line">    str++;</span><br><span class="line">  &#125;</span><br><span class="line">  while(*str&gt;&apos;0&apos;&amp;&amp;*str&lt;&apos;9&apos;)</span><br><span class="line">  &#123;</span><br><span class="line">    result = result*10+*str-&apos;0&apos;;</span><br><span class="line">    if(result&lt;0)</span><br><span class="line">    &#123;</span><br><span class="line">      printf(&quot;this amount is too large\n&quot;);</span><br><span class="line">      return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    str++;</span><br><span class="line">  &#125;</span><br><span class="line">  return result*(flags?-1:1);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：a = 1234,同上。</span><br><span class="line">分析：为什么&quot;if(result&lt;0)&quot;这一条件会写在程序中呢？我本能的以为，这种情况是不可能发生的。但是，经过一番研究以后，发现当result值大到一定程度时，是会成立的。</span><br><span class="line">&lt;1&gt;char型正数范围(0-127)</span><br><span class="line">范围之内：</span><br><span class="line">char a = (127-1);</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">printf(&quot;a = %u\n&quot;,a);</span><br><span class="line">运行结果：</span><br><span class="line">a = 126</span><br><span class="line">a = 126</span><br><span class="line">超过范围：</span><br><span class="line">char a = (127+1);//7f=127=0111 1111</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);//a = -128 = 1000 0000</span><br><span class="line">printf(&quot;a = %u\n&quot;,a);</span><br><span class="line">运行结果：</span><br><span class="line">a = -128	</span><br><span class="line">a = 4294967168</span><br><span class="line">分析：a=4294967168=FFFFFF80=80加上前面补FFFFFF，充分说明&quot;%u&quot;打印是是按照32bit来进行的。</span><br><span class="line">&lt;2&gt;int型正数范围(0-2147483647)</span><br><span class="line">范围之内：</span><br><span class="line">int a = (2147483647-1);//4字节——可以表示正数范围7FFF FFFF(0-2147483647)</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">printf(&quot;a = %u\n&quot;,a);</span><br><span class="line">运行结果：</span><br><span class="line">a=2147483646</span><br><span class="line">a=2147483646</span><br><span class="line">超过范围：</span><br><span class="line">int a = (2147483647+1);//4字节——可以表示正数范围7FFF FFFF(0-2147483647)</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">printf(&quot;a = %u\n&quot;,a);</span><br><span class="line">运行结果：</span><br><span class="line">a = -2147483648</span><br><span class="line">a = 2147483648</span><br><span class="line">总结：</span><br><span class="line">定义某一个类型的数(int、char..)，当这个数的值在该类型的正数范围之内时，打印出的有符号数和无符号数的结果是一模一样的；当这个数的值超出了该类型所可以表示的正数的范围时，因为，它已经超出了该类型所可以表达的最大的正数了，所以它只好以负数的解析方式去对它进行解析。</span><br><span class="line">总之一句话，内存里面放的这一堆二进制数字，在默认的情况下是以无符号数来进行解析的。但是当以无符号数的解析方式盛不下该数字时，此时那就只好按照有符号数的解析方式进行解析。</span><br><span class="line">给我们造成的一种视觉上的现象是：明明我刚开始时，是以一个整数作为基础，在整数的基础之上不断地给它累加、累加，累加到一定程度时它的值竟然变成了负数了。</span><br></pre></td></tr></table></figure>
<p>39.</p>
<p>存储类、作用域、生命周期、链接属性</p>
<ul>
<li>存储类，指的是存储类型的意思，描述的是C语言的变量存储的什么地方。</li>
</ul>
<p>存储类一般包括数据段、代码段、bss段、堆、栈，一共5个部分。那么这5个段又是怎么引出来的呢？</p>
<p>a. 一个可执行程序在存储时，包含3部分：代码段、数据段、bss段。即可执行程序(存储时) = 代码段+数据段+bss段。</p>
<p>b. 当可执行程序被加载到内存单元时，则需要另外的2个段，堆、栈。即可执行程序(正在运行) = 代码段+数据段+bss段+堆+栈。</p>
<p>总结：进程(正在运行的可执行程序)会占用一定的内存空间，每一个进程对应到内存空间中大致上可以分为5个段。</p>
<p>以上的5个段又是可以分为2类，静态存储区、动态存储区。</p>
<p>静态存储区：包括常量、全局变量、静态变量(静态全局变量、静态局部变量)</p>
<p>动态存储区：堆和栈。堆内存一般使用malloc申请完以后，使用free手工释放掉。栈，存放函数的返回地址，函数形参、以及局部变量。</p>
<p>有了这2种类型的分区以后，自然地衍生出2种存储方式，静态存储方式与动态存储方式。</p>
<p>静态存储方式，指的是这一些变量在程序的编译阶段就已经分配好了内存空间的，生命周期一直延续到整个程序的结束为止。</p>
<p>动态存储方式，指的是这一些变量在程序的运行阶段，根据需要进行动态的分配内存空间的，使用完该内存空间以后立即释放掉。</p>
<p>那么思考一下全局变量存放在什么位置？而局部变量又存放在什么位置呢？</p>
<p>答：全局变量分为2种，一种初始化为非0的全局变量分配在数据段上；另一种显式初始化为0的全局变量或者未初始化的全局变量分配在栈上。一般情况下，也就是没有加任何的修饰符的局部变量是存放在栈上的；而加了static修饰的局部变量存放在数据段或者bss段，当初始化为非0的static局部变量时，存放在数据段中。而未初始化的static局部变量和初始化为0的static局部变量存放在bss段中。</p>
<ul>
<li>作用域</li>
</ul>
<p>作用域指的是某一个变量起作用的范围。C语言变量的作用域规则是代码块作用域，代码块也就是一对{}括起来所囊括的范围。</p>
<p>局部变量的作用域：</p>
<p>局部变量的作用域为代码块作用域。</p>
<p>函数名和全局变量的作用域为文件作用域：</p>
<p>即，在整个.c文件中都是可以对全局变量和函数名进行访问的。</p>
<p>关于同名变量的掩蔽规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//demo 1</span><br><span class="line">main:</span><br><span class="line">int a;</span><br><span class="line">int a;</span><br><span class="line">运行结果：</span><br><span class="line">error: redeclaration of ‘a’ with no linkage</span><br><span class="line">//demo 2</span><br><span class="line">int a = 5;</span><br><span class="line">main:</span><br><span class="line">int a = 10;</span><br><span class="line">运行结果：此时没有警告、没有错误。全局变量a和局部变量a尽管说变量名是相同的，但是由于作用域是不相同的，所以不会报错。此时，起作用的变量类似于&quot;县官不如现管&quot;的味道。</span><br></pre></td></tr></table></figure>
<ul>
<li>生命周期</li>
</ul>
<p>指的是这个变量从什么时间诞生的、什么时间消亡，这个从诞生到消亡的这一个时间段。</p>
<p>诞生的意思是说，从给该变量分配内存空间开始；消亡的意思是，回收该变量的内存空间，也是说这个内存空间与该变量已经没有任何的关系了。</p>
<p>研究变量存储在不同的存储类时，所对应的生命周期。</p>
<p>代码段：</p>
<p>代码段里面放的，其实就是程序执行的代码，即一个个的函数。它的生命周期是永久的，一般来说代码段的生命周期是不需要我们来关注的。</p>
<p>数据段、bss段：</p>
<p>存放在该段的全局变量的生命周期是永久的，即在程序中执行时诞生，在程序终止时消亡。所以，当一个程序中有大量的全局变量时，就会导致这个程序一直占用大量的内存。</p>
<p>栈：</p>
<p>里面的变量，生命周期是临时的。譬如，在一个函数中所定义的局部变量，函数在每一次调用时，该局部变量都会被创建一次，然后使用，当函数返回时消亡。</p>
<p>堆：</p>
<p>堆内存里面的变量的生命周期是有程序员手动的支配的。从malloc申请时开始诞生，然后使用，直到free时消亡。但我们需要一大块临时的内存时，最好使用malloc申请一段堆内存空间。</p>
<ul>
<li>链接属性</li>
</ul>
<p>大家都知道源程序(.c)到最终的可执行程序(.elf)，经历了编译、链接过程。</p>
<p>编译阶段就是把源程序(.c)变成目标文件(.o),目标文件中包含了很多符号、代码段、数据段、bss段等。符号就是程序中的变量名、函数名。那么目标文件中的这一些符号起什么作用？</p>
<p>答：程序在运行时，变量名和函数名能够和对应的段联系起来，就是依靠的这一些符号。</p>
<p>链接，指的是把目标文件(.obj)和库文件(也就是一堆的.obj文件)，组合到一块的过程。</p>
<p>首先要声明的一点是我们平时所说的链接属性指的是符号的链接属性。</p>
<p>1.</p>
<p>链接属性分为3类：</p>
<p>a. 外链接(external)    b. 内部链接(internal)        c. 无链接(none)</p>
<p>2.</p>
<p>3种链接方式的定义、以及各自的影响。</p>
<p>外链接，指多个源文件中相同的标识符指向同一个实体。导致结果，拥有external链接属性的符号是可以被其他的所有的文件所访问的，但前提是使用extern关键字进行声明。</p>
<p>内链接，指同一个源文件中相同的标识符指向同一个实体。结果导致，拥有internal链接属性的符号，只可以在其定义的文件中才可以被访问，也就是变成了当前源文件的私有符号。</p>
<p>无链接，该标识符当做单独的实体，只有在代码块内部出现，每一次出现都是不同的独立的实体。导致的结果，拥有无链接属性的符号它的可访问区间为：从其定义出开始到该代码块作用域结束为止。</p>
<p>3.</p>
<p>那么怎么样让一个符号具有外部链接、内部链接、无链接的这一些属性呢？</p>
<p>第一，默认情况下全局变量和函数的声明都是具有外部链接属性的。extern关键字可以把一个符号的链接属性设置为外部链接。</p>
<p>第二，static关键字可以把一个符号的链接属性设为内部链接。</p>
<p>第三，函数内部的代码块以及函数的形参都默认是none属性的。</p>
<p>总结、注意：</p>
<p>第一点，static关键字修饰的对象，该对象原本的属性类型原本应该是external类型的变量(也可以认为是全局变量)，而对于链接属性为内链接型的变量是不起作用的。</p>
<p>第二点，extern关键字修饰的对象，前提是该对象之前是没有被其他的关键字所修饰过的，此时extern关键字才起作用的。假如说，该变量之前已经被static关键字修饰过了，当使用extern再一次修饰该变量时，是不起任何作用的，仍旧保持原来的属性不变的。</p>
<ul>
<li>和链接属性相关的延伸：</li>
</ul>
<p>宏定义和inline的链接属性都是无链接的。</p>
<p>inline函数与宏定义是非常类似的。</p>
<p>a. inline 函数代码是存放在符号表中的，在编译阶段展开；而宏定义是在预处理阶段展开。</p>
<p>b. 内联函数是有做类型检查、语法判断的；而宏定义没有这些。</p>
<p>40.</p>
<p>C语言程序的内存映像</p>
<p>组成部分：内核虚拟存储器、代码段、数据段、bss段、栈、堆…….</p>
<p>内核虚拟存储器——将操作系统的内核程序映射到这个区域。</p>
<p>对于Linux中的每一个进程而言，它都以为整个操作系统中只有自己和内核，认为其他的进程是不存在的。</p>
<p>关于虚拟地址的一些概念，迷糊但是还是先记录下来。2018-6-4</p>
<p>a. 每一个进程都有自己独立的进程空间(0G-3G)，对进程的访问是虚拟地址，而并非物理地址</p>
<p>b. 虚拟地址可以通过每一个进程的页表与物理地址进行映射，从而获取真正的物理地址。</p>
<p>c. 虚拟地址实际上是操作系统对内存管理的一种方式。可能进程A的虚拟地址对应了物理地址0x10，而进程B的虚拟地址对应了物理地址0x20，虚拟地址提供了一种有效的进程间隔离的方式，这就导致了任何一个进程它不管在做一些什么，都是在自己的地址空间做的，是不会影响到其他的进程的。</p>
<p>d. CPU采用虚拟地址到物理地址的映射技术的目的？答：对于每一进程而言，它们每一个进程都以为自己独占了4G的内存空间(3G用户进程使用的，对应代码段、数据段、bss段….)；1G内核(Kernel)所有的进程是可以共享使用的)。操作系统会自动的为不同的进程分配合适的、不同的物理内存空间。</p>
<p>Linux内核的5大组成部分：</p>
<p>内存管理、进程管理、进程间通信、虚拟文件系统、网路接口。</p>
<p>41.</p>
<p>和存储类相关的关键字介绍。</p>
<ul>
<li>auto</li>
</ul>
<p>auto关键字在C语言中只有一哥作用：修饰局部变量。我们平时所写的局部变量，其实都是auto类型的，只不过平时我们把auto这个关键字给省略掉了。</p>
<ul>
<li>static</li>
</ul>
<p>C语言中static关键字有2种截然不同的用法。</p>
<p>用法1：</p>
<p>用来修饰局部变量。那么局部变量就自然地分为2类，一类是没有static修饰的局部变量；另一类就是有static修饰的局部变量。</p>
<p>无static修饰的局部变量，它的存储类属于栈。而static修饰的局部变量的存储类为数据段或bss段。当初始化为非0时，分配到数据段；当初始化为0时，分配到bss段。</p>
<p>总结：static修饰局部变量时，改变的是变量的存储类。</p>
<p>用法2：</p>
<p>用来修饰全局变量。那么全局变量也就和自然的可以分为带static修饰的全局变量、和不带static修饰的全局变量。这2中不同的全局变量的主要区别在于，它们的链接属性发生了改变。没有static修饰的函数和全局变量，默认的链接属性为外链接的；使用static修饰的函数和全局变量的链接属性变成了内链接。</p>
<p>总结：static修饰的函数和全局变量，改变的是它们的链接属性。</p>
<ul>
<li>register</li>
</ul>
<p>作用：使用register关键字来修饰的变量，编译器会尽量的保证把该类型的变量分配到寄存器中。而我们平时定义的那一些变量都是分配在内存中的。</p>
<p>我们都知道计算机CPU对数据的处理速度，寄存器&gt;内存。使用register关键字，那么数据直接分配到寄存器中，那么相应的读写速度、效率就会提高很多的。</p>
<p>注意：我们这里使用register定义的变量，编译器只是尽量的保证将register修饰的变量存放于寄存器中，主要的原因是，寄存器的数量是非常的有限的。</p>
<ul>
<li>extern</li>
</ul>
<p>作用：声明全局变量。声明的主要目的是，假设一个全局变量g_a在a.c中定义了，可b.c中是没有定义g_a这个变量的，可是b.c中又很想的使用该变量，此时就可以在b.c中使用extern关键字对g_a该变量进行声明，然后在b.c中就可以使用g_a了。</p>
<p>注意：使用extern声明全局变量时，是不可以进行初始化操作的，否则就会报错。</p>
<ul>
<li>volatile</li>
</ul>
<p>字面意思：直接从原始内存地址中读取。即告诉编译器不要做任何的优化操作，从而可以保证程序原来的本意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//demo 1</span><br><span class="line">int a,b,c;</span><br><span class="line">a = 3;</span><br><span class="line">b = a;</span><br><span class="line">c = a;</span><br><span class="line">总结，</span><br><span class="line">当编译器没有做优化时，对于2,3,4这3个语句，要对内存进行读取3次，写入3次；而有编译器优化时，对内存只需要读取一次，写入3次(即c = b = a)。</span><br><span class="line">这3条语句中并没有出现对a的值进行改变的语句，所以编译器在编译过程中会将a的值备份到一个寄存器中，之后的&quot;b=a&quot;,&quot;c=a&quot;语句在执行时，就不会再跑到内存中去读取数据了，而是直接的从寄存器中读取那一份备份得到的a的值。</span><br><span class="line">正常情况下，编译器这样做的话，会提升CPU对数据得访问效率，是很好的操作。但是，假如在执行完&quot;a=3&quot;这一条语句时，外部突然来了一个中断，在这个中断程序中对a的值进行了更改，那么，此时再按照编译器优化以后的&quot;c=b=a&quot;这样的操作的话，就会出问题了。我们程序原本的初衷是实现&quot;c=b=a&quot;这样的效果的，但是来了这么一个中断以后，b的值将不等于a，c的值也将不等于a了。而，我们还一直的以为&quot;c=b=a&quot;是正确的。</span><br></pre></td></tr></table></figure>
<p>再次探讨关于volatile</p>
<p>a. 在本次线程内，当读取一个变量时为了提高存取的速度，编译器会做一些优化——把变量读取到一个寄存器中，以后取变量时，直接去寄存器中取就OK了，不需要跑到内存中了。当变量的值在本线程被改变时，会同时把变量的新值copy到该寄存器中，以便保持一致。</p>
<p>当变量的值由于别的线程(外部的一个中断)而更改时，该寄存器中的值是不会发生改变的，从而造成了读取到的值和实际的值不一致的情况。</p>
<p>b. 使用volatile定义的变量，有可能在该程序之外被修改的，此时每一次读取变量时都必须要从该变量的内存地址处进行读取，而不可以反复的使用之前备份在cache或者寄存器中的那一份值。</p>
<p>volatile可能使用的场景：</p>
<p>a. 并行设备的硬件寄存器(状态寄存器)</p>
<p>b. 一个中断服务子程序会访问到的非自动变量</p>
<p>c. 多线程应用中被几个任务共享的变量</p>
<ul>
<li>restrict</li>
</ul>
<p>该关键字与volatile是有点意思的，volatile强调的是告诉编译器不要给我进行优化操作；而restrict关键字是为了使编译器可以更好的优化代码。</p>
<p>restrict关键字用来修饰指针，用来告诉编译器所有的试图修改该指针变量所指向的内存单元中的内容的操作，都必须是通过该指针进行操作的。</p>
<p>譬如说，int *restrict p;该指针p所指向的内存单元，该内存单元中的内容是只可以通过p来进行访问的，p是访问这一块内存空间的惟一的途径。</p>
<p>理论终究是理论知识，理论终究知识理论知识点，但我在编译器中试图使用另一个指针q访问p所指向的那一块内存空间时，实践表明是可以进行访问的。呵呵。</p>
<p>但是，注意一点，使用restrict关键字时，编译时使用”gcc a.c -std=c99”类似于这种，要在编译时添加-std=c99后缀，否则编译编译是通不过的。</p>
<p>42.</p>
<p>操作系统的概念：</p>
<p>引言，人类社会在最开始的时候，每个人都是需要干活的，是没有专职的管理者的(不干活、只是指挥其他人干活的)。而随着社会的进步，人口越来越多了，此时假如还是每个人都在忙头的干活的话，此时尽管说干活的人数非常的多，但是实际上他们相当于忙头苍蝇一般，效率是非常的低下的，此时假如找几个人，这几个人是专门来负责安排其他人如何如何的干活的，此时尽管说干活的人的确少了一些，但是从宏观上来看，整体的效率、以及工作量是非常的可观的。</p>
<p>a. 操作系统就非常的类似于这一种概念。操作系统这一部分代码本身并不是直接的产生价值的，而是为那一些直接劳动的(各种的应用程序)提供服务的。</p>
<p>b. 操作系统可以被认为是计算机所有的资源(cpu、内存…)的管理者。操作系统的这一部分代码是并不参与生产价值的，它主要是为那一些直接、真正产生价值、真正劳动的各种应用程序提供服务的。所以说，操作系统既是管理者、又是服务者。</p>
<p>c. 操作系统是为用户(使用计算机的人)提供服务的，使用户可以在计算机上使用各种各样的应用程序(QQ、浏览器)来操控计算机资源(QQ的显示需要显示器资源、浏览器下载资料时，同时需要硬盘、同时这一些应用程序都在共同使用着CPU资源)。</p>
<p>d. 操作系统是处于应用程序和计算机硬件资源(CPU、内存、IO设备)的中间层。</p>
<p>那么操作系统和内核之间有什么瓜葛呢？一两句话，是说不清楚的，先浅浅的了解一些。</p>
<p>a. 内核是操作系统的一个子集。</p>
<p>b. 内核是最直接的控制底层的硬件的(譬如，内核程序操作声卡发出声音)，API就是应用程序与内核之间的一个接口、应用程序通过调用API，来间接的控制计算机硬件资源。</p>
<p>43.</p>
<p>C库函数与API的关系</p>
<p>a. 应用程序是通过API函数来调用操作系统的。</p>
<p>b. 当应用程序需要使用计算机系统的硬件资源(CPU、内存、IO..)，应用程序会通过API向操作系统提出申请，然后操作系统响应申请，来帮助应用程序执行对应的功能。</p>
<p>c. API函数是别人写好的可以实现特定功能的函数，而我们只需要根据它所提供的接口，也就是调用它的方法(传入特定的参数)，那么这个函数就会帮助我们实现特定的功能。</p>
<p>d. 而C库函数可以理解为是对API函数进行了2次封装，做了进一步的改善。使用Windows API编写的程序放到其他的操作系统(linux)上就不工作了；假如是C语言库函数编写的程序，放到其他的操作系统上(linux)上，仍然是可以工作的。</p>
<p>44.</p>
<p>关于main函数</p>
<p>函数本质：是一段代码、是一个数据处理器，我们把数据输入进去，然后经过函数的加工，以得到我们所需要的数据。</p>
<p>main函数，它是比较特殊的，它是整个程序的入口。其他的函数只有被main函数直接或者间接的调用，该函数才可以被执行。</p>
<ul>
<li>那么main函数是被谁调用的呢？</li>
</ul>
<p>答：main函数从某一种角度，就代表了当前的这个程序。谁执行了这个程序，那么谁调用main函数。譬如说，”./a.out”这一个命令行，就代表了它——这个命令行调用了这个main函数。</p>
<ul>
<li>那么程序有哪几种被调用执行的方法呢？</li>
</ul>
<p>答：大概3种。</p>
<p>a. 常见的，在Linux命令行下面直接”./a.out”来执行一个程序</p>
<p>b. 通过shell脚本来调用执行一个程序</p>
<p>c. 在程序中去调用执行一个程序。具体方法，使用fork创建一个子进程，然后使用exec函数族去执行它。(这个暂且了解，到网络编程、应用编程时，会详细讲)</p>
<p>总结：Linux中执行一个程序的本质就是，创建一个新的进程，然后把这个程序丢到这个进程当中，去执行直到结束。也可以认为，父进程fork出来一个子进程,然后子进程和一个程序绑定起来去执行(exec函数族)，我们在exec的时候，就可以给main函数同时传参。</p>
<ul>
<li>进程究竟是由谁开启的呢？</li>
</ul>
<p>答：Linux中的进程都是被它的父进程fork出来的。命令行本身就是一个进程，在命令行底下”./a.out”去执行一个程序，其实相当于这个新程序是作为命令行进程的一个子进程去执行的。</p>
<p>总结：</p>
<p>一个程序(包括main函数)是被它的父进程所调用的。main函数通过返回值，返回给调用main函数的父进程。那么，父进程就得到了一个由main函数产生的返回值。父进程通过这个返回值，依此来判断子进程(main函数)是执行成功了？还是失败了？一般来说，return 0表示成功；而return -1即表示失败。</p>
<ul>
<li>实践获取main函数的返回值</li>
</ul>
<p>步骤：使用shell脚本执行程序可以获取程序的返回值，并且打印出来。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//demo 1</span><br><span class="line">a.c中</span><br><span class="line">main:</span><br><span class="line">return 210;//实践验证2018超范围了，随便给一个&lt;200的数字都可正常打印</span><br><span class="line">与a.c同目录下，使用vi新建一个return.sh脚本文件</span><br><span class="line">return.sh中</span><br><span class="line">#!/bin/sh			shell脚本的文件格式</span><br><span class="line">./a.out				表示执行这个文件</span><br><span class="line">echo $?				echo表示打印，与C语言中的printf一样，将程序执行的返回值存放                      在$?中</span><br><span class="line">最后，</span><br><span class="line">gcc a.c</span><br><span class="line">source return.sh</span><br><span class="line">运行结果：210</span><br><span class="line">总结：从运行结果可以看到，&quot;source return.sh&quot;是可以替代我们平时的&quot;./a.out&quot;的。从而，证明了利用shell脚本也是可以执行程序的。</span><br></pre></td></tr></table></figure>
<ul>
<li>main函数的参数是由谁提供的呢？</li>
</ul>
<p>答：调用main函数所在程序的，该程序的父进程给提供的参数，并且该父进程接收main函数的返回值。</p>
<ul>
<li>为什么要给main函数传递参数呢？</li>
</ul>
<p>答：父进程调用子程序时，并不一定要给子程序传递参数。譬如，我们平时书写的”int main(){}”里面就是属于没有传参的这种。传参的目的在于我们希望可以达到一种效果：不需要重新编译就可以更改程序运行的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//演示通过给main函数传递不同的参数，以达到不需要重新编译就可以更改程序运行结果。</span><br><span class="line">//程序功能：写一个简易的计算器，实现&quot;./a.out 12 &quot;+&quot; 12&quot;此时，打印出&quot;12+12=24&quot;</span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">  if(argc!=4)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;Please input the para at least 4 !\n&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  if(!strcmp(argv[2],&quot;+&quot;))</span><br><span class="line">  	printf(&quot;%s+%s=%d\n&quot;,argv[1],argv[3],atoi(argv[1])+atoi(argv[3]));</span><br><span class="line">  else if(!strcmp(argv[2],&quot;-&quot;))</span><br><span class="line">  	printf(&quot;%s-%s=%d\n&quot;,argv[1],argv[3],atoi(argv[1])-atoi(argv[3]));</span><br><span class="line">  else if(!strcmp(argv[2],&quot;*&quot;))</span><br><span class="line">  	printf(&quot;%s×%s=%d\n&quot;,argv[1],argv[3],atoi(argv[1])*atoi(argv[3]));</span><br><span class="line">  else if(!strcmp(argv[2],&quot;/&quot;))</span><br><span class="line">  	printf(&quot;%s/%s=%d\n&quot;,argv[1],argv[3],atoi(argv[1])/atoi(argv[3]));</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">只需要一次gcc a.c编译一次,a,b,c代表了不同的传参从而导致运行结果的不一致</span><br><span class="line">a. &quot;./a.out&quot;时，打印&quot;Please input the para at least 4 !&quot;</span><br><span class="line">b. &quot;./a.out 12 &quot;+&quot; 12&quot;,打印，&quot;12+12=24&quot;</span><br><span class="line">c. &quot;./a.out 12 &quot;-&quot; 12&quot;,打印，&quot;12-12=0&quot;</span><br><span class="line">d. &quot;./a.out 12 &quot;*&quot; 12&quot;,打印，&quot;12×12=144&quot;</span><br><span class="line">本程序使用了atoi——字符串转整数的一个小技巧。</span><br></pre></td></tr></table></figure>
<p>45.</p>
<p>void类型的本质</p>
<ul>
<li>引言：</li>
</ul>
<p>强类型语言：是一种强制类型定义的语言。某一个变量一旦被定义了类型，假如没有强制类型转化的话，该变量的类型是不会发生变化的。</p>
<p>弱类型语言：是一种弱类型定义的语言。某一个变量被定义了类型，该变量的类型是可以根据环境的变化，它的类型也是会跟着变化的，是不需要经过强制类型转化的。</p>
<p>而，C语言属于一种强类型语言。</p>
<ul>
<li>数据类型的本质</li>
</ul>
<p>该数据类型的变量所占用内存大小的别名。</p>
<p>a. C语言中是不存在没有类型(void)的变量的。因为，C语言并没有规定void类型的变量占多大的内存空间的。</p>
<p>b. C语言是可以有没有类型(void)的指针的。内存在没有和具体类型的变量绑定之前，是没有类型可言的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		演示不同数据类型的指针，对访问数据产生的影响</span><br><span class="line">int a = 0x12345678;</span><br><span class="line">int *p = (int *)&amp;a;</span><br><span class="line">printf(&quot;%x\n&quot;,*p);</span><br><span class="line">char *q = (char *)&amp;a;</span><br><span class="line">printf(&quot;%x\n&quot;,*q);</span><br><span class="line">运行结果：</span><br><span class="line">12345678</span><br><span class="line">78</span><br></pre></td></tr></table></figure>
<ul>
<li>void类型的本质</li>
</ul>
<p>不知道的类型、不确定的类型</p>
<p>46.</p>
<p>关于NULL</p>
<ul>
<li>NULL在C语言中并不是一个关键字，本质上是一个宏定义。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//demo 1</span><br><span class="line">#define NULL	(void *)0</span><br></pre></td></tr></table></figure>
<p>NULL的本质就是数字0，这个0并不是当做一个数字来处理的，而是当做一个内存地址来解析的。其实，是一个0x0000 0000，代表内存的0地址。</p>
<p>我们平时为什么定义一个指针时，顺手”int *p = NULL”呢？</p>
<p>在大部分的CPU，内存的0地址都是由操作系统严密掌控的，程序员是不可以随便的访问的。当我们”int *p = NULL”时，此时指针p指向的内存单元是不可以访问的，除非我们手动的给p置一个适当、合适的值，此时p指向的内存单元就是合法的。假如我们，没有手动的给p一个适当的、合适的值，那么访问p时，就会编译器会提示段错误。从而，我们可以通过编译器的提示来得知p所指向的内存单元是不合法的。</p>
<ul>
<li>‘\0’与’0’与NULL</li>
</ul>
<p>‘\0’是C语言字符串的结尾标志，一般用于比较字符串，以判断字符串有没有结束。</p>
<p>‘0’对应着0这个字符的ASCII编码，一般用于获取0的ASCII码值</p>
<p>NULL，一般作为判断是否是野指针的条件</p>
<p>47.</p>
<p>关于程序调试的DEBUG宏</p>
<p>调试版本(DEBUG版本)和发行版本(RELEASE版本)</p>
<p>调试版本：包含了调试信息输出的版本，这种版本可以辅助测试人员通过程序运行时打印出的打印信息/log文件，以此判断程序问题的所在。</p>
<p>发行版本：相比调试版本而言代码的功能是一模一样的，只不过去掉了一些调试信息。</p>
<p>2者比较：</p>
<p>由于调试版本在输出调试信息时，占用了系统的资源，拖慢了系统的运行速度。因此，调试版本本身的性能是低于发行版本的。</p>
<ul>
<li>程序是如何控制是生成调试版本呢？还是发行版本呢？</li>
</ul>
<p>答：宏。</p>
<p>48.</p>
<p>C语言可变参数的引入</p>
<p>关于可变参数，我们引入了4个陌生的东东。va_list,va_start,va_arg,va_end，下面一一介绍</p>
<ul>
<li><p>va_list: 是一种数据类型，用于定义一个字符指针类型的变量</p>
<p>​va_list vl;定义一个字符指针vl</p>
</li>
<li><p>va_start: 是一个宏，初始化可变参数列表</p>
<p>​va_list(vl,变量名)，vl指向参数表的起始地址</p>
</li>
<li><p>va_arg:是一个宏，获取下一个参数</p>
<p>​val=va_list(vl,变量类型)，本质从内存单元获取”变量类型”,赋值给val,然后再自动移动sizeof(变量类型)字节。</p>
</li>
<li><p>va_end:是一个宏，停止使用可变参数列表</p>
<p>​va_end(vl);使vl指向NULL</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">//demo 1	功能：利用可变参数，打印出n个浮点小数</span><br><span class="line">void f_print(int amount,...)</span><br><span class="line">&#123;</span><br><span class="line">  int i=0;</span><br><span class="line">  double d=0;</span><br><span class="line">  va_list vl;</span><br><span class="line">  va_start(vl,d);</span><br><span class="line">  printf(&quot;您输入的小数个数为：%d,分别为：\n&quot;,amount);</span><br><span class="line">  for(i=0;i&lt;amount;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    d = va_arg(vl,double);</span><br><span class="line">    printf(&quot;%lf\n&quot;,d);</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(vl);</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">f_print(3,1.23,1.23,1.23);</span><br><span class="line">运行结果：</span><br><span class="line">您输入的小数个数为：3,分别为：</span><br><span class="line">1.230000</span><br><span class="line">1.230000</span><br><span class="line">1.230000</span><br><span class="line">//demo 2	功能：利用可变参数，打印出n个整数中最大的整数</span><br><span class="line">int f_max(int amount,...)</span><br><span class="line">&#123;</span><br><span class="line">  int greater=0,val=0;</span><br><span class="line">  va_list vl;</span><br><span class="line">  va_start(vl,greater);</span><br><span class="line">  greater = va_arg(vl,int);</span><br><span class="line">  for(i=1;i&lt;amount;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    val = va_arg(vl,int);</span><br><span class="line">    greater=(greater&gt;val?greater:val);</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(vl);</span><br><span class="line">  return greater;</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">int a=0;</span><br><span class="line">a = f_max(3,10,20,30);</span><br><span class="line">printf(&quot;a = %d\n&quot;,a);</span><br><span class="line">运行结果：a = 30</span><br><span class="line">//demo 3	功能：利用可变参数，打印出n个字符串</span><br><span class="line">void s_print(char *first,...)</span><br><span class="line">&#123;</span><br><span class="line">  char *tmp=first;</span><br><span class="line">  va_list vl;</span><br><span class="line">  va_start(vl,tmp);</span><br><span class="line">  while(tmp != NULL)</span><br><span class="line">  &#123;</span><br><span class="line">    printf(&quot;%s\n&quot;,tmp);</span><br><span class="line">    tmp = va_arg(vl,char *);</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(vl);</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">s_print(&quot;One&quot;,&quot;Two&quot;,&quot;Three&quot;,NULL);</span><br><span class="line">运行结果：</span><br><span class="line">One</span><br><span class="line">Two</span><br><span class="line">Three</span><br></pre></td></tr></table></figure>
<p>49.</p>
<p>关于’\n’和’\r’的简单介绍，掺杂的有getchar()和putchar()的介绍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">//demo 1	功能：实现从键盘中输入任意内容、然后把该内容给输出到屏幕上</span><br><span class="line">char a;</span><br><span class="line">a = getchar();</span><br><span class="line">while(a!=EOF)</span><br><span class="line">&#123;</span><br><span class="line">  putchar(a);</span><br><span class="line">  a = getchar();</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">abcd</span><br><span class="line">abcd</span><br><span class="line">...</span><br><span class="line">总结：getchar()函数，从文本流读入一个输入字符，并将其作为结果返回回去。通俗来讲，从键盘上输入一个字符，getchar()函数的值就是从键盘中输入而得到的值。</span><br><span class="line">//demo 2	功能：&apos;\r&apos;与&apos;\n&apos;混合使用的效果</span><br><span class="line">putchar(&apos;5&apos;);</span><br><span class="line">putchar(&apos;5&apos;);</span><br><span class="line">putchar(&apos;5&apos;);</span><br><span class="line">putchar(&apos;\r&apos;);</span><br><span class="line">putchar(&apos;6&apos;);</span><br><span class="line">putchar(&apos;6&apos;);</span><br><span class="line">putchar(&apos;6&apos;);</span><br><span class="line">运行结果：</span><br><span class="line">666</span><br><span class="line">总结：putchar()的作用，向终端(显示屏)输出一个字符。&apos;\r&apos;的效果是返回到本行行首，它就会把这一行之前的输出给覆盖掉。</span><br><span class="line">//demo 3	</span><br><span class="line">printf(&quot;One:\r&quot;);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">运行结果：</span><br><span class="line">One:</span><br><span class="line">总结：</span><br><span class="line">本来应该打印出&quot;One:&quot;字样的，使用了&apos;\r&apos;以后，紧跟着后面有一个&apos;\n&apos;。</span><br><span class="line">导致的效果：原本应该打印输出&quot;One:&quot;字样的，使用了&apos;\r&apos;以后，光标就会移动到该行最开始的地方。相当于是把原本要打印输出的内容&quot;One:&quot;给抹掉了。但是，紧接着一个&apos;\n&apos;的效果，就是把原来擦除掉的东西给还原回来。</span><br><span class="line">//demo 4</span><br><span class="line">printf(&quot;One:\n&quot;);</span><br><span class="line">printf(&quot;012 3456 %d\r789&quot;,6666);</span><br><span class="line">printf(&quot;ABCD:&quot;);</span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line">printf(&quot;012 3456 %d\r789&quot;,6666);</span><br><span class="line">运行结果</span><br><span class="line">One:</span><br><span class="line">789ABCD: 6666</span><br><span class="line">789root@ubuntu:/mnt/hgfs/code#</span><br><span class="line">总结：这个demo很好的展示了demo 3所想要展示的原理。此外，可以看出printf函数是属于行缓冲的，当它没遇到&apos;\n&apos;时，该行的内容是不会被打印出来的。</span><br></pre></td></tr></table></figure>
<p>50.</p>
<p>关于47-&gt;debug宏的接续</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line">//demo 1		再一次的理解一下递归的含义是什么？递归的实现</span><br><span class="line">void func(int cnt)</span><br><span class="line">&#123;</span><br><span class="line">  if(cnt == 0)</span><br><span class="line">    return;</span><br><span class="line">  func(cnt/10);</span><br><span class="line">  printf(&quot;cnt=%d\n&quot;,cnt);</span><br><span class="line">&#125;</span><br><span class="line">main:</span><br><span class="line">func(1234);</span><br><span class="line">运行结果：</span><br><span class="line">cnt=1</span><br><span class="line">cnt=12</span><br><span class="line">cnt=123</span><br><span class="line">cnt=1234</span><br><span class="line">分析：</span><br><span class="line">func(1234)-&gt;func(123)-&gt;func(12)-&gt;func(1)-&gt;func(0)，到func(0)时，程序开始推出。</span><br><span class="line">递归，有一种&quot;咬到底&quot;的味道，&quot;咬到底&quot;指的是，当满足此时的条件已经开始不满足递归条件时，开始弹栈操作。之前的递归条件满足时，是一直的在压栈的。因而，结果如上。</span><br><span class="line">//demo 2	&quot;do&#123;&#125;while(0);&quot;的演示使用(一)</span><br><span class="line">(一)</span><br><span class="line">#define AB	printf(&quot;abcd\n&quot;);printf(&quot;ABCD\n&quot;);</span><br><span class="line">main:</span><br><span class="line">if(0)</span><br><span class="line">	AB</span><br><span class="line">运行结果：</span><br><span class="line">ABCD</span><br><span class="line">分析：我明明是if(0)条件不成立呀，但是AB的这个宏也是执行了一部分的。我在第一次书写时，写成了if(0)&#123;AB&#125;，那么别小看了这个&#123;&#125;，加上了它之后打印的结果肯定是2行都全部输出打印的。总结，宏定义的实现，原封不动的全部替换。</span><br><span class="line">(二)</span><br><span class="line">#define AB	do&#123;printf(&quot;abcd\n&quot;);printf(&quot;ABCD\n&quot;);&#125;while(0);</span><br><span class="line">main:</span><br><span class="line">if(0)</span><br><span class="line">	AB</span><br><span class="line">运行结果：</span><br><span class="line">什么也没有输出。</span><br><span class="line">分析：使用了&quot;do&#123;&#125;while(0);&quot;之后呢，我们使用if(0)，那么显然是条件不满足的情况，故什么也没打印出来。正好符合我们心中所想的。</span><br><span class="line">//demo 3	&quot;do&#123;&#125;while(0);&quot;的演示使用(二)</span><br><span class="line">(一)</span><br><span class="line">#define AB	printf(&quot;abcd\n&quot;);printf(&quot;ABCD\n&quot;);</span><br><span class="line">main:</span><br><span class="line">if(1)</span><br><span class="line">	AB	</span><br><span class="line">运行结果：</span><br><span class="line">abcd</span><br><span class="line">ABCD</span><br><span class="line">(二)</span><br><span class="line">#define AB	do&#123;printf(&quot;abcd\n&quot;);printf(&quot;ABCD\n&quot;);&#125;while(0);</span><br><span class="line">main:</span><br><span class="line">if(1)</span><br><span class="line">	AB</span><br><span class="line">运行结果：</span><br><span class="line">abcd</span><br><span class="line">ABCD</span><br><span class="line">总结，当if(1)时，无论使用do&#123;&#125;while(0);还是不使用，它们的结果是一样的。</span><br><span class="line">//demo 4	关于stdout与stderr</span><br><span class="line">printf(&quot;Hello world\n&quot;);</span><br><span class="line">fprintf(stdout,&quot;abcdefg&quot;);</span><br><span class="line">fprintf(stderr,&quot;ABCDEFG&quot;);</span><br><span class="line">运行结果：</span><br><span class="line">Hello world</span><br><span class="line">ABCDEFGabcdefgroot@ubuntu:/mnt/hgfs/code# </span><br><span class="line">分析，stdout属于行缓冲的——&lt;1&gt;遇到&apos;\n&apos;或者&apos;\r&apos;时  &lt;2&gt;遇到return 0；时。</span><br><span class="line">stderr属于没有行缓冲的形式，即会立即打印字符。</span><br><span class="line">//demo 5</span><br><span class="line">#define DEBUG(args)	(printf(&quot;DEBUG():&quot;),printf args)</span><br><span class="line">main:</span><br><span class="line">int a=5;</span><br><span class="line">if(a!=0)</span><br><span class="line">&#123;</span><br><span class="line">  DEBUG((&quot;a is %d\n&quot;,a));</span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">DEBUG():a is 5</span><br><span class="line">分析，这属于有一个参数的，带参宏。定义时，是要使用逗号来分离的。而，需要注意的是，在使用时，是需要加上2个括号的。否则是会报错的。</span><br><span class="line">//demo 6</span><br><span class="line">#define DEBUG(...)	fprintf(stderr,__VA_ARGS__)</span><br><span class="line">main:</span><br><span class="line">int a=5;</span><br><span class="line">if(a!=0)</span><br><span class="line">&#123;</span><br><span class="line">  DEBUG(&quot;a is %d\n&quot;,a);</span><br><span class="line">&#125;</span><br><span class="line">运行结果：a is 5</span><br><span class="line">分析，debug宏的可变参数，此时DEBUG是没有使用双括号的哦！</span><br><span class="line">//demo 7		版本(一)	&quot;##&quot;的引入</span><br><span class="line">#define debug(format,args...)	fprintf(stderr,format,args)</span><br><span class="line">main:</span><br><span class="line">char arr[20]=&quot;Hello world\n&quot;;</span><br><span class="line">int i=10;</span><br><span class="line">debug(&quot;i=%d,%s&quot;,i,arr);</span><br><span class="line">运行结果：i=10,Hello world</span><br><span class="line">//demo 8		版本(二)</span><br><span class="line">#define debug(format,args...)	fprintf(stderr,format,args)</span><br><span class="line">main:</span><br><span class="line">debug(&quot;Hello world\n&quot;);</span><br><span class="line">运行结果：</span><br><span class="line">error: expected expression before ‘)’ token</span><br><span class="line">#define debug(format,args...) fprintf(stderr,format,args)</span><br><span class="line">分析，在debug宏定义时，显示的是至少有2个参数的。可是，我们在使用时只提供了一个参数。导致了，定义时与使用时的规格不一致。编译器，因此报了错误。</span><br><span class="line">//demo 9		版本(三)</span><br><span class="line">&lt;1&gt;</span><br><span class="line">#define debug(format,args...)	fprintf(stderr,format,##args)</span><br><span class="line">main:</span><br><span class="line">debug(&quot;Hello world\n&quot;);</span><br><span class="line">运行结果：Hello world</span><br><span class="line">通过使用&quot;##&quot;可以完美的解决了，定义宏时与使用宏时，由于规格不一致而引发的问题。</span><br><span class="line">&lt;2&gt;</span><br><span class="line">上题中&quot;args...&quot;与&quot;##args&quot;是配对的；而在C99的标准中，&quot;...&quot;与&quot;##__VA_ARGS__&quot;是配对的。</span><br><span class="line">#define debug(format,...)	fprintf(stderr,format,##__VA_ARGS__)</span><br><span class="line">main：</span><br><span class="line">debug(&quot;Hello world\n&quot;);</span><br><span class="line">运行结果：Hello world</span><br><span class="line">//demo 10		综合(一)</span><br><span class="line">#define DEBUG</span><br><span class="line"></span><br><span class="line">#ifdef DEBUG</span><br><span class="line">#define DEG(...)	fprintf(stderr,&quot;DEG(%s,%s(),%d:)&quot;,__FILE__,__FUNCTION__,\</span><br><span class="line">__LINE__);fprintf(stderr,__VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line">#define DEG(...)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">main:</span><br><span class="line">DEG(&quot;hello world\n&quot;);</span><br><span class="line">运行结果：DEG(a.c,main(),41:)hello world</span><br><span class="line">分析，这个结果可是折腾了好久才成功运行了的。</span><br><span class="line">比如&quot;__FILE__&quot;这个东西必须是双下划线的；换行时，是要用&quot;\&quot;的；里面的一个一个&quot;,&quot;都是一个都不可以少的。</span><br><span class="line">__FILE__表示文件名</span><br><span class="line">__FUNCTION__表示函数名</span><br><span class="line">__LINE__表示调用&quot;DEG&quot;的行数。</span><br><span class="line">//demo 11	综合(二)</span><br><span class="line">#define _DEBUG do&#123;&#125;while(0)</span><br><span class="line"></span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">#define DEBUG(...)\</span><br><span class="line">        do&#123;\</span><br><span class="line">            fprintf(stderr,&quot;-----DEBUG-----\n&quot;);\</span><br><span class="line">            fprintf(stderr,&quot;%s %s\n&quot;,__TIME__,__DATE__);\</span><br><span class="line">            fprintf(stderr,&quot;%s:%d:%s():&quot;,__FILE__,__LINE__,__FUNCTION__);\</span><br><span class="line">            fprintf(stderr,__VA_ARGS__);\</span><br><span class="line">        &#125;while(0)</span><br><span class="line">#endif</span><br><span class="line">main:</span><br><span class="line">DEBUG(&quot;Hello world\n&quot;)</span><br><span class="line">运行结果：</span><br><span class="line">-----DEBUG-----</span><br><span class="line">15:06:41 Jun 11 2018</span><br><span class="line">a.c:25:main():Hello world</span><br><span class="line">分析，</span><br><span class="line">__TIME__编译的时间</span><br><span class="line">__DATE__编译的日期</span><br><span class="line">__FILE__文件名字</span><br><span class="line">__LINE__调用DEBUG的行数</span><br><span class="line">__FUNCTION__函数名</span><br><span class="line">总结：</span><br><span class="line">像着一些东西，稍微的稍微的，差了一个标点符号、大小写什么的都可能导致编译出现稀奇古怪的问题。所以，解决的方法，看懂它；然后学会使用就好，自己一个一个码字打上去，后果你可以尝试尝试，很痛苦的。</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C语言/" rel="tag"># C语言</a>
          
        </div>
      

      
      
      


	  
      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/16/C语言杂记(一)/" rel="next" title="C语言杂记(一)">
                <i class="fa fa-chevron-left"></i> C语言杂记(一)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/16/操作符重载_1/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://ss0.bdstatic.com/7Ls0a8Sm1A5BphGlnYG/sys/portrait/item/a02079656172e58898e5b08fe4ba8cb386"
                alt="刘本超" />
            
              <p class="site-author-name" itemprop="name">刘本超</p>
              <p class="site-description motion-element" itemprop="description">嵌入式|C语言|C++</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://blog.csdn.net/qq_41570500" target="_blank" title="CSDN">
                      
                        <i class="fa fa-fw fa-globe"></i>CSDN</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://mail.163.com/js6/main.jsp?sid=MCczXKZViURPVLEpNRVVIPAoehvxVhUV&df=email163#module=welcome.WelcomeModule%7C%7B%7D" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">刘本超</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  

  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'dm86LcmhYht6EPJdiDMFc3CH-gzGzoHsz',
        appKey: 'iI1CGk25JO4FMAA4f1EWP6go',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("dm86LcmhYht6EPJdiDMFc3CH-gzGzoHsz", "iI1CGk25JO4FMAA4f1EWP6go");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

  
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  
  
  <div class="bg_content">
    <canvas id="canvas"></canvas>
  </div>
  
<script>
	class Circle {
		//创建对象
		//以一个圆为对象
		//设置随机的 x，y坐标，r半径，_mx，_my移动的距离
		//this.r是创建圆的半径，参数越大半径越大
		//this._mx,this._my是移动的距离，参数越大移动
		constructor(x, y) {
			this.x = x;
			this.y = y;
			this.r = Math.random() * 10 ;
			this._mx = Math.random() ;
			this._my = Math.random() ;

		}

		//canvas 画圆和画直线
		//画圆就是正常的用canvas画一个圆
		//画直线是两个圆连线，为了避免直线过多，给圆圈距离设置了一个值，距离很远的圆圈，就不做连线处理
		drawCircle(ctx) {
			ctx.beginPath();
			//arc() 方法使用一个中心点和半径，为一个画布的当前子路径添加一条弧。
			ctx.arc(this.x, this.y, this.r, 0, 360)
			ctx.closePath();
			ctx.fillStyle = 'rgba(204, 204, 204, 0.3)';
			ctx.fill();
		}

		drawLine(ctx, _circle) {
			let dx = this.x - _circle.x;
			let dy = this.y - _circle.y;
			let d = Math.sqrt(dx * dx + dy * dy)
			if (d < 150) {
				ctx.beginPath();
				//开始一条路径，移动到位置 this.x,this.y。创建到达位置 _circle.x,_circle.y 的一条线：
				ctx.moveTo(this.x, this.y);   //起始点
				ctx.lineTo(_circle.x, _circle.y);   //终点
				ctx.closePath();
				ctx.strokeStyle = 'rgba(204, 204, 204, 0.3)';
				ctx.stroke();
			}
		}

		// 圆圈移动
		// 圆圈移动的距离必须在屏幕范围内
		move(w, h) {
			this._mx = (this.x < w && this.x > 0) ? this._mx : (-this._mx);
			this._my = (this.y < h && this.y > 0) ? this._my : (-this._my);
			this.x += this._mx / 2;
			this.y += this._my / 2;
		}
	}
	//鼠标点画圆闪烁变动
	class currentCirle extends Circle {
		constructor(x, y) {
			super(x, y)
		}

		drawCircle(ctx) {
			ctx.beginPath();
			//注释内容为鼠标焦点的地方圆圈半径变化
			//this.r = (this.r < 14 && this.r > 1) ? this.r + (Math.random() * 2 - 1) : 2;
			this.r = 8;
			ctx.arc(this.x, this.y, this.r, 0, 360);
			ctx.closePath();
			//ctx.fillStyle = 'rgba(0,0,0,' + (parseInt(Math.random() * 100) / 100) + ')'
			ctx.fillStyle = 'rgba(255, 77, 54, 0.3)'
			ctx.fill();

		}
	}
	//更新页面用requestAnimationFrame替代setTimeout
	window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;

	let canvas = document.getElementById('canvas');
	let ctx = canvas.getContext('2d');
	let w = canvas.width = canvas.offsetWidth;
	let h = canvas.height = canvas.offsetHeight;
	let circles = [];
	let current_circle = new currentCirle(0, 0)

	let draw = function () {
		ctx.clearRect(0, 0, w, h);
		for (let i = 0; i < circles.length; i++) {
			circles[i].move(w, h);
			circles[i].drawCircle(ctx);
			for (j = i + 1; j < circles.length; j++) {
				circles[i].drawLine(ctx, circles[j])
			}
		}
		if (current_circle.x) {
			current_circle.drawCircle(ctx);
			for (var k = 1; k < circles.length; k++) {
				current_circle.drawLine(ctx, circles[k])
			}
		}
		requestAnimationFrame(draw)
	}

	let init = function (num) {
		for (var i = 0; i < num; i++) {
			circles.push(new Circle(Math.random() * w, Math.random() * h));
		}
		draw();
	}
	window.addEventListener('load', init(60));
	window.onmousemove = function (e) {
		e = e || window.event;
		current_circle.x = e.clientX;
		current_circle.y = e.clientY;
	}
	window.onmouseout = function () {
		current_circle.x = null;
		current_circle.y = null;

	};
</script>

<a href="https://github.com/you"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_gray_6d6d6d.png" alt="Fork me on GitHub"></a>


</body>
</html>
